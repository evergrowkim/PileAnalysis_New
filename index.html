<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>말뚝 기초 설계 계산기 v2.0</title>
<link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;600;700&family=Noto+Sans+KR:wght@400;500;600;700;800&display=swap" rel="stylesheet">
<script src="https://cdn.sheetjs.com/xlsx-0.20.0/package/dist/xlsx.full.min.js"></script>
<script>window.MathJax={tex:{inlineMath:[['$','$']],displayMath:[['$$','$$']]}};</script>
<script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" async></script>
<style>
:root {
  --primary-navy: #1e3a5f;
  --primary-steel: #2c4e7e;
  --primary-slate: #3d5a80;
  --status-pass: #2e7d32;
  --status-fail: #c62828;
  --status-warning: #f57c00;
  --status-info: #0277bd;
  --bg-primary: #ffffff;
  --bg-secondary: #f8f9fa;
  --bg-tertiary: #e9ecef;
  --bg-header: #263238;
  --text-primary: #212529;
  --text-secondary: #495057;
  --text-muted: #6c757d;
  --text-light: #ffffff;
  --calc-bg: #f7f8fa;
  --calc-border: #d1d5db;
  --calc-formula: #1e3a5f;
  --calc-value: #2e7d32;
  --calc-step: #495057;
  --border-color: #d1d5db;
  --accent-coral: #e94560;
  --accent-green: #16a34a;
  --accent-blue: #3b82f6;
  --font-body: 'Noto Sans KR', 'Pretendard', -apple-system, sans-serif;
  --font-mono: 'JetBrains Mono', monospace;
}
*, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
html, body { height: 100%; }
body { font-family: var(--font-body); background: var(--bg-secondary); color: var(--text-primary); font-size: 13px; line-height: 1.5; }

/* Toolbar */
.toolbar { height: 42px; background: linear-gradient(135deg, var(--bg-header), #16213e, var(--primary-navy)); color: var(--text-light); display: flex; align-items: center; padding: 0 16px; gap: 12px; border-bottom: 3px solid var(--accent-coral); }
.toolbar .app-title { font-size: 14px; font-weight: 700; }
.toolbar .pipe-char { color: rgba(255,255,255,0.3); margin: 0 4px; }
.toolbar .bh-info { display: flex; align-items: center; gap: 6px; margin-left: auto; }
.toolbar .bh-label { font-size: 10px; color: #a8b2d1; }
.toolbar .bh-value { font-size: 13px; font-weight: 700; color: var(--accent-coral); }
.pile-tag { display: inline-block; padding: 2px 8px; border-radius: 10px; font-size: 10px; font-weight: 700; margin-left: 6px; }
.pile-tag.phc { background: #fef3c7; color: #92400e; }
.pile-tag.steel { background: #dbeafe; color: #1d4ed8; }

/* Toolbar Buttons */
.btn-toolbar { padding: 5px 12px; border: 1px solid rgba(255,255,255,0.3); border-radius: 4px; background: rgba(255,255,255,0.1); color: #fff; font-size: 10px; font-weight: 600; cursor: pointer; display: flex; align-items: center; gap: 4px; transition: background .2s; }
.btn-toolbar:hover { background: rgba(255,255,255,0.2); }

/* Tab Navigation */
.tab-nav { background: #445D73; display: flex; padding: 0 20px; gap: 4px; overflow-x: auto; border-bottom: 1px solid #324E67; }
.tab-btn { padding: 10px 16px; font-size: 11.5px; font-weight: 500; color: rgba(255,255,255,0.75); background: transparent; border: none; cursor: pointer; position: relative; white-space: nowrap; transition: all .2s; }
.tab-btn:hover { color: #fff; background: rgba(255,255,255,0.08); }
.tab-btn.active { color: #fff; font-weight: 700; background: rgba(255,255,255,0.15); }
.tab-btn.active::after { content: ''; position: absolute; bottom: 0; left: 0; right: 0; height: 3px; background: #fff; }

/* Tab Content */
.tab-content { display: none; padding: 20px; max-width: 1200px; margin: 0 auto; }
.tab-content.active { display: block; }

/* App Layout - Sidebar + Main */
.app-layout { display: flex; height: calc(100vh - 93px); }
.sidebar { width: 210px; min-width: 210px; background: #fff; border-right: 1px solid var(--border-color); overflow-y: auto; flex-shrink: 0; transition: width 0.2s, min-width 0.2s; }
.sidebar.collapsed { width: 0; min-width: 0; overflow: hidden; padding: 0; border-right: none; }
.sidebar-header { padding: 10px 14px; background: var(--primary-navy); color: #fff; font-size: 11px; font-weight: 700; display: flex; justify-content: space-between; align-items: center; }
.sidebar-header button { background: none; border: none; color: rgba(255,255,255,0.7); cursor: pointer; font-size: 11px; padding: 2px 4px; }
.sidebar-header button:hover { color: #fff; }
.bh-list-item { padding: 9px 12px; border-bottom: 1px solid #eee; cursor: pointer; font-size: 11px; transition: background 0.15s; display: flex; justify-content: space-between; align-items: center; }
.bh-list-item:hover { background: #f0f7ff; }
.bh-list-item.active { background: #e3f2fd; border-left: 3px solid var(--primary-navy); }
.bh-list-item .bh-name { font-weight: 600; color: var(--primary-navy); font-size: 11.5px; }
.bh-list-item .bh-qa { font-size: 9.5px; font-family: var(--font-mono); color: var(--text-muted); margin-top: 1px; }
.bh-list-item .bh-status { padding: 1px 5px; border-radius: 3px; font-size: 8px; font-weight: 700; }
.bh-list-item .bh-status.ok { background: #dcfce7; color: #15803d; }
.bh-list-item .bh-status.ng { background: #fee2e2; color: #dc2626; }
.sidebar-toggle { position: fixed; left: 210px; top: 50%; transform: translateY(-50%); z-index: 10; width: 18px; height: 36px; background: #f1f5f9; border: 1px solid var(--border-color); border-left: none; border-radius: 0 4px 4px 0; cursor: pointer; display: flex; align-items: center; justify-content: center; font-size: 9px; color: var(--text-muted); transition: left 0.2s; }
.sidebar.collapsed ~ .sidebar-toggle { left: 0; }
.main-content { flex: 1; overflow-y: auto; }

/* Section Headers */
.sec-title { font-size: 13px; font-weight: 700; color: var(--primary-navy); border-left: 3px solid var(--accent-coral); padding-left: 10px; margin: 18px 0 10px; }

/* Form Grid */
.form-grid { display: grid; gap: 10px; }
.form-grid.cols-2 { grid-template-columns: repeat(2, 1fr); }
.form-grid.cols-3 { grid-template-columns: repeat(3, 1fr); }
.form-grid.cols-4 { grid-template-columns: repeat(4, 1fr); }

/* Form Field */
.field { display: flex; flex-direction: column; gap: 3px; }
.field label { font-size: 10px; font-weight: 600; color: var(--text-secondary); text-transform: uppercase; letter-spacing: .3px; }
.field input, .field select { padding: 6px 8px; border: 1px solid var(--border-color); border-radius: 4px; font-size: 12px; font-family: var(--font-mono); outline: none; background: #fff; }
.field input:focus, .field select:focus { border-color: var(--primary-steel); box-shadow: 0 0 0 2px rgba(44,78,126,0.1); }
.field input:disabled { background: var(--bg-tertiary); color: var(--text-muted); }

/* Buttons */
.btn { padding: 6px 13px; background: var(--primary-navy); color: #fff; border: none; border-radius: 4px; font-size: 11px; font-weight: 600; cursor: pointer; transition: background .2s; }
.btn:hover { background: var(--primary-steel); }
.btn-sm { padding: 4px 8px; font-size: 10px; }
.btn-danger { background: #fee2e2; color: #dc2626; border: 1px solid #fca5a5; }
.btn-danger:hover { background: #fecaca; }
.btn-success { background: var(--status-pass); }
.btn-warning { background: var(--status-warning); color: #fff; }
.btn-outline { background: transparent; border: 1px solid var(--border-color); color: var(--text-secondary); }
.btn-outline:hover { background: var(--bg-tertiary); }

/* Tables */
table { width: 100%; border-collapse: collapse; font-size: 11px; }
table th { background: var(--bg-header); color: #fff; padding: 6px 7px; text-align: center; font-weight: 600; font-size: 10px; white-space: nowrap; }
table td { padding: 5px 7px; border-bottom: 1px solid #eee; text-align: center; font-family: var(--font-mono); font-size: 11px; }
table td.left { text-align: left; }
table tr:nth-child(even) { background: #fafbfc; }
table tr:hover { background: #f0f4ff; }
table input { padding: 4px 6px; border: 1px solid var(--border-color); border-radius: 3px; width: 55px; text-align: center; font-size: 11px; font-family: var(--font-mono); }
table select { padding: 3px 5px; border: 1px solid var(--border-color); border-radius: 3px; font-size: 10px; }

/* Calculation Line */
.cl { display: flex; align-items: center; gap: 6px; padding: 5px 10px; background: var(--calc-bg); border-radius: 4px; margin-bottom: 4px; font-family: var(--font-mono); font-size: 11px; flex-wrap: wrap; }
.cl .cl-label { font-weight: 600; color: var(--primary-navy); min-width: 50px; }
.cl .cl-formula { color: var(--text-secondary); }
.cl .cl-eq { margin: 0 3px; }
.cl .cl-val { color: var(--accent-coral); font-weight: 700; }
.cl .cl-unit { color: var(--text-muted); font-size: 10px; }

/* Formula Box */
.formula-box { font-family: var(--font-mono); font-size: 11.5px; padding: 7px 11px; background: #f1f5f9; border-radius: 4px; border: 1px solid #e2e8f0; margin-bottom: 5px; line-height: 1.4; }

/* Result Bar */
.result-bar { display: flex; justify-content: space-between; align-items: center; padding: 9px 13px; border-radius: 6px; margin-top: 8px; }
.result-bar.ok { background: #f0fdf4; border: 1px solid #86efac; }
.result-bar.ng { background: #fef2f2; border: 1px solid #fca5a5; }
.result-bar .rb-label { font-size: 12px; font-weight: 600; }
.result-bar .rb-val { font-size: 16px; font-weight: 800; font-family: var(--font-mono); }
.result-bar.ok .rb-val { color: var(--status-pass); }
.result-bar.ng .rb-val { color: var(--status-fail); }

/* Spec Card */
.spec-card { padding: 10px; border-radius: 5px; margin-top: 10px; }
.spec-card.phc { background: #fffbeb; border: 1px solid #fde68a; }
.spec-card.steel { background: #eff6ff; border: 1px solid #bfdbfe; }
.spec-card .spec-title { font-size: 10.5px; font-weight: 700; margin-bottom: 5px; }
.spec-card.phc .spec-title { color: #92400e; }
.spec-card.steel .spec-title { color: #1d4ed8; }

/* Derived Info */
.derived-grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 8px; margin-top: 10px; padding: 9px; background: var(--calc-bg); border-radius: 5px; }
.derived-grid .dg-item { font-size: 11px; }
.derived-grid .dg-item strong { color: var(--primary-navy); }

/* Soil Badge */
.soil-badge { padding: 2px 6px; border-radius: 8px; font-size: 9px; font-weight: 700; }
.soil-badge.sand { background: #dcfce7; color: #15803d; }
.soil-badge.clay { background: #dbeafe; color: #1d4ed8; }
.soil-badge.rock { background: #fef3c7; color: #92400e; }

/* Rock Params Box */
.rock-params { padding: 9px; background: #eff6ff; border-radius: 5px; border: 1px solid #bfdbfe; margin-top: 8px; }

/* Upload Zone */
.upload-zone { border: 2px dashed var(--border-color); border-radius: 8px; padding: 20px; text-align: center; cursor: pointer; transition: all .2s; margin-bottom: 15px; background: var(--bg-primary); }
.upload-zone:hover, .upload-zone.dragover { border-color: var(--primary-steel); background: #f0f7ff; }
.upload-zone .uz-icon { font-size: 28px; margin-bottom: 6px; }
.upload-zone .uz-text { font-size: 12px; color: var(--text-muted); }
.upload-zone .uz-sub { font-size: 10px; color: var(--text-muted); margin-top: 4px; }
.upload-zone.success { border-color: var(--status-pass); background: #f0fdf4; }
.upload-zone.error { border-color: var(--status-fail); background: #fef2f2; }
.upload-result { font-size: 11px; font-weight: 600; margin-top: 6px; }
.upload-result.success { color: var(--status-pass); }
.upload-result.error { color: var(--status-fail); }

/* Borehole Selector after upload */
.bh-selector { display: flex; align-items: center; gap: 10px; padding: 10px 14px; background: #eff6ff; border-radius: 6px; margin-bottom: 12px; border: 1px solid #bfdbfe; }
.bh-selector label { font-size: 11px; font-weight: 600; color: var(--primary-navy); }
.bh-selector select { padding: 5px 10px; border: 1px solid var(--border-color); border-radius: 4px; font-size: 12px; font-family: var(--font-mono); min-width: 140px; }
.bh-selector .btn { margin-left: auto; }

/* Summary Cards */
.summary-cards { display: grid; grid-template-columns: repeat(3, 1fr); gap: 12px; margin-bottom: 16px; }
.summary-card { padding: 14px; border-radius: 7px; background: var(--bg-primary); text-align: center; border-width: 2px; border-style: solid; }
.summary-card .sc-label { font-size: 10px; font-weight: 600; color: var(--text-muted); margin-bottom: 2px; }
.summary-card .sc-value { font-size: 20px; font-weight: 800; font-family: var(--font-mono); }
.summary-card .sc-unit { font-size: 10px; color: var(--text-muted); }

/* Slide Panel (Borehole Log) */
.panel-overlay { display: none; position: fixed; inset: 0; background: rgba(0,0,0,0.5); z-index: 9999; }
.panel-overlay.open { display: block; }
.slide-panel { position: fixed; top: 0; right: -540px; width: 520px; max-width: 95vw; height: 100vh; background: var(--bg-primary); box-shadow: -4px 0 20px rgba(0,0,0,0.2); z-index: 10000; transition: right .3s ease-out; overflow-y: auto; }
.slide-panel.open { right: 0; }
.panel-header { background: linear-gradient(135deg, #455A64, #2C5F8D); color: #fff; padding: 16px 18px; }
.panel-header .ph-title { font-size: 20px; font-weight: 700; }
.panel-header .ph-meta { display: flex; flex-wrap: wrap; gap: 12px; margin-top: 8px; font-size: 11px; }
.panel-header .ph-meta .pm-label { opacity: 0.7; }
.panel-header .ph-meta .pm-value { font-weight: 600; }
.panel-header .ph-close { position: absolute; top: 12px; right: 12px; width: 28px; height: 28px; border-radius: 50%; background: rgba(255,255,255,0.2); border: none; color: #fff; font-size: 16px; cursor: pointer; display: flex; align-items: center; justify-content: center; }
.panel-header .ph-close:hover { background: rgba(255,255,255,0.3); }
.panel-legend { display: flex; gap: 8px; margin-top: 10px; padding-top: 8px; border-top: 1px solid rgba(255,255,255,0.2); flex-wrap: wrap; }
.panel-legend .pl-item { display: flex; align-items: center; gap: 4px; font-size: 9px; }
.panel-legend .pl-swatch { width: 12px; height: 12px; border-radius: 2px; border: 1px solid rgba(255,255,255,0.3); }
.panel-body { padding: 12px 16px; }
.panel-columns { display: grid; grid-template-columns: 55px 1fr 130px; gap: 6px; position: relative; }
.panel-col-header { font-size: 10px; font-weight: 600; color: var(--text-secondary); text-align: center; padding: 4px 0; border-bottom: 2px solid var(--primary-navy); margin-bottom: 6px; position: sticky; top: 0; background: var(--bg-primary); z-index: 5; }

/* Depth markers in panel */
.depth-mark { position: absolute; left: 0; width: 55px; font-size: 10px; color: var(--text-secondary); text-align: right; padding-right: 4px; }
.depth-mark.major { font-weight: 700; color: #455A64; font-size: 11px; }
.depth-line { position: absolute; left: 60px; right: 0; height: 1px; background: #ddd; }
.depth-line.major { background: #aaa; }

/* Strat layer in panel */
.strat-layer { position: absolute; left: 0; right: 0; display: flex; border: 1px solid #888; border-radius: 2px; overflow: hidden; }
.strat-color-strip { width: 40px; display: flex; align-items: center; justify-content: center; font-size: 9px; font-weight: 700; color: rgba(0,0,0,0.6); writing-mode: vertical-rl; }
.strat-info { flex: 1; padding: 3px 6px; font-size: 11px; font-weight: 600; color: #455A64; }

/* N-value bar in panel */
.nval-bar-row { position: absolute; left: 0; right: 0; height: 12px; display: flex; align-items: center; }
.nval-bar { height: 10px; border-radius: 1px; min-width: 4px; box-shadow: 0 1px 2px rgba(0,0,0,0.15); }
.nval-bar.normal { background: linear-gradient(to right, #90CAF9, #1976d2); }
.nval-bar.refusal { background: linear-gradient(to right, #1976d2, #2E7D32); }
.nval-label { font-size: 9px; font-weight: 700; margin-left: 3px; font-family: var(--font-mono); }
.nval-label.normal { color: #1976d2; }
.nval-label.refusal { color: #2E7D32; }

/* Water/Excavation markers */
.marker-line { position: absolute; left: 0; right: 0; height: 0; z-index: 3; }
.marker-line.water { border-top: 2px dashed #2196F3; }
.marker-line.excavation { border-top: 3px dashed #FF6F00; }
.marker-badge { position: absolute; right: 0; padding: 1px 5px; border-radius: 3px; font-size: 8px; font-weight: 700; color: #fff; transform: translateY(-50%); }
.marker-badge.water { background: #2196F3; }
.marker-badge.excavation { background: #FF6F00; }

/* Verification Modal */
.modal-overlay { display: none; position: fixed; inset: 0; background: rgba(0,0,0,0.5); z-index: 9998; justify-content: center; align-items: center; }
.modal-overlay.open { display: flex; }
.modal { background: var(--bg-primary); border-radius: 10px; width: 90vw; max-width: 1000px; max-height: 85vh; overflow-y: auto; box-shadow: 0 8px 32px rgba(0,0,0,0.2); }
.modal-header { padding: 16px 20px; background: var(--primary-navy); color: #fff; border-radius: 10px 10px 0 0; display: flex; justify-content: space-between; align-items: center; }
.modal-header h2 { font-size: 15px; font-weight: 700; }
.modal-close { width: 30px; height: 30px; border-radius: 50%; background: rgba(255,255,255,0.2); border: none; color: #fff; font-size: 18px; cursor: pointer; }
.modal-body { padding: 20px; }
.modal-tabs { display: flex; gap: 4px; margin-bottom: 16px; }
.modal-tab { padding: 8px 16px; border: 1px solid var(--border-color); border-radius: 5px; background: var(--bg-secondary); font-size: 11px; font-weight: 600; cursor: pointer; }
.modal-tab.active { background: var(--primary-navy); color: #fff; border-color: var(--primary-navy); }
.verify-compare { display: grid; grid-template-columns: 1fr 1fr; gap: 16px; }
.verify-col { padding: 12px; border-radius: 6px; border: 1px solid var(--border-color); }
.verify-col h3 { font-size: 12px; font-weight: 700; margin-bottom: 10px; padding-bottom: 6px; border-bottom: 2px solid var(--primary-navy); }

/* Calc Tooltip */
.calc-tip { position: relative; cursor: help; border-bottom: 1px dotted var(--primary-navy); }
.calc-tip .tip-content { display: none; position: fixed; background: #1e293b; color: #fff; padding: 8px 12px; border-radius: 6px; font-size: 10px; line-height: 1.4; white-space: pre-line; min-width: 250px; max-width: 400px; z-index: 9999; box-shadow: 0 4px 12px rgba(0,0,0,0.3); pointer-events: none; }
.calc-tip:hover .tip-content { display: block; }

/* Info Button & Guide Modal */
.info-btn { display: inline-flex; align-items: center; justify-content: center; width: 15px; height: 15px; border-radius: 50%; background: var(--primary-slate); color: #fff; font-size: 8.5px; font-weight: 700; cursor: pointer; border: none; margin-left: 3px; vertical-align: middle; transition: background 0.2s; line-height: 1; }
.info-btn:hover { background: var(--accent-coral); }
.guide-overlay { display: none; position: fixed; inset: 0; background: rgba(0,0,0,0.4); z-index: 9998; justify-content: center; align-items: center; }
.guide-overlay.open { display: flex; }
.guide-modal { background: #fff; border-radius: 10px; width: 480px; max-width: 90vw; max-height: 70vh; overflow-y: auto; box-shadow: 0 8px 32px rgba(0,0,0,0.2); }
.guide-header { padding: 14px 18px; background: var(--primary-navy); color: #fff; border-radius: 10px 10px 0 0; display: flex; justify-content: space-between; align-items: center; }
.guide-header h3 { font-size: 13px; font-weight: 700; margin: 0; }
.guide-body { padding: 18px; }
.guide-body .guide-def { font-size: 12px; color: var(--text-primary); margin-bottom: 12px; line-height: 1.7; }
.guide-body .guide-range { padding: 10px 12px; background: #f0fdf4; border-radius: 6px; border: 1px solid #a5d6a7; margin-bottom: 12px; font-size: 11.5px; }
.guide-body .guide-range strong { color: #15803d; }
.guide-body .guide-ref { font-size: 10px; color: var(--text-muted); border-top: 1px solid #eee; padding-top: 8px; margin-top: 8px; }

/* SPT Paste */
.paste-area { width: 100%; height: 200px; font-family: var(--font-mono); font-size: 11px; border: 1px solid var(--border-color); border-radius: 4px; padding: 8px; resize: vertical; }

/* Dashboard */
.dash-stats { display: grid; grid-template-columns: repeat(4, 1fr); gap: 10px; margin-bottom: 16px; }
.dash-stat { padding: 12px; background: #fff; border-radius: 6px; text-align: center; border: 1px solid var(--border-color); }
.dash-stat .ds-val { font-size: 22px; font-weight: 800; font-family: var(--font-mono); color: var(--primary-navy); }
.dash-stat .ds-label { font-size: 10px; color: var(--text-muted); margin-top: 2px; }
.dash-toolbar { display: flex; gap: 8px; align-items: center; margin-bottom: 12px; flex-wrap: wrap; }
.dash-toolbar input { padding: 6px 10px; border: 1px solid var(--border-color); border-radius: 4px; font-size: 11px; min-width: 200px; }
.dash-table th { cursor: pointer; user-select: none; }
.dash-table th:hover { background: #37474f; }

/* Report */
.report-section { margin-bottom: 24px; padding: 16px; background: #fff; border-radius: 8px; border: 1px solid var(--border-color); }
.report-title { font-size: 15px; font-weight: 700; color: var(--primary-navy); margin-bottom: 12px; padding-bottom: 8px; border-bottom: 2px solid var(--primary-navy); }
.report-step { padding: 10px 14px; margin-bottom: 8px; background: var(--calc-bg); border-left: 3px solid var(--primary-navy); border-radius: 0 4px 4px 0; }
.report-step .step-num { display: inline-block; width: 24px; height: 24px; border-radius: 50%; background: var(--primary-navy); color: #fff; text-align: center; line-height: 24px; font-size: 11px; font-weight: 700; margin-right: 8px; }

/* SVG Container */
.svg-container { border: 1px solid #dee2e6; border-radius: 8px; overflow-x: auto; background: #fff; margin-top: 10px; }

/* Toast */
.toast-container { position: fixed; top: 16px; right: 16px; z-index: 99999; display: flex; flex-direction: column; gap: 8px; }
.toast { padding: 10px 16px; border-radius: 6px; box-shadow: 0 4px 16px rgba(0,0,0,0.15); font-size: 12px; font-weight: 500; display: flex; align-items: center; gap: 8px; animation: toastIn .3s ease-out; min-width: 250px; }
.toast.success { background: #f0fdf4; border-left: 4px solid var(--status-pass); color: var(--status-pass); }
.toast.error { background: #fef2f2; border-left: 4px solid var(--status-fail); color: var(--status-fail); }
.toast.warning { background: #fffbeb; border-left: 4px solid var(--status-warning); color: var(--status-warning); }
.toast.info { background: #eff6ff; border-left: 4px solid var(--status-info); color: var(--status-info); }
@keyframes toastIn { from { transform: translateX(100%); opacity: 0; } to { transform: translateX(0); opacity: 1; } }

/* Responsive */
@media (max-width: 1200px) {
  .form-grid.cols-4 { grid-template-columns: repeat(2, 1fr); }
  .summary-cards { grid-template-columns: repeat(2, 1fr); }
  .derived-grid { grid-template-columns: repeat(2, 1fr); }
  .dash-stats { grid-template-columns: repeat(2, 1fr); }
}
@media (max-width: 768px) {
  .form-grid.cols-3, .form-grid.cols-4 { grid-template-columns: 1fr; }
  .summary-cards { grid-template-columns: 1fr; }
  .verify-compare { grid-template-columns: 1fr; }
  .dash-stats { grid-template-columns: 1fr; }
}
/* ===== AI INTEGRATION STYLES ===== */
.ai-btn { padding:5px 12px; border:none; border-radius:4px;
  background:linear-gradient(135deg,#6366f1,#8b5cf6); color:#fff; font-size:10px;
  font-weight:600; cursor:pointer; display:inline-flex; align-items:center; gap:4px; transition:all .2s; }
.ai-btn:hover { background:linear-gradient(135deg,#4f46e5,#7c3aed); box-shadow:0 2px 8px rgba(99,102,241,.4); }
.ai-btn.btn-toolbar { margin-left:4px; }
#aiContent { white-space:pre-wrap; word-break:break-word; font-size:12px; line-height:1.5; color:var(--text-primary); }
#aiContent h3 { font-size:14px; font-weight:700; color:var(--primary-navy); margin:16px 0 6px; border-bottom:1px solid #e2e8f0; padding-bottom:4px; }
#aiContent h4 { font-size:12.5px; font-weight:600; color:var(--primary-steel); margin:10px 0 4px; }
#aiContent ul, #aiContent ol { margin:4px 0; padding-left:20px; }
#aiContent li { margin:3px 0; }
#aiContent strong { color:var(--primary-navy); }
#aiContent code { background:#f1f5f9; padding:1px 5px; border-radius:3px; font-size:11px; font-family:var(--font-mono); }
#aiContent blockquote { border-left:3px solid #6366f1; margin:8px 0; padding:4px 12px; background:#f8f9ff; }
.ai-loading { display:flex; align-items:center; gap:10px; padding:20px; color:var(--text-muted); font-size:12px; }
.ai-loading .ai-spinner { width:20px; height:20px; border:2px solid #e2e8f0; border-top-color:#6366f1;
  border-radius:50%; animation:aiSpin .8s linear infinite; }
@keyframes aiSpin { to { transform:rotate(360deg); } }
.ai-nl-box { margin-bottom:14px; padding:12px 14px; background:linear-gradient(135deg,#f8f9ff,#f0f4ff);
  border:1px solid #c7d2fe; border-radius:8px; }
.ai-nl-box input { flex:1; padding:8px 12px; border:1px solid #a5b4fc; border-radius:6px;
  font-size:12px; font-family:var(--font-body); outline:none; transition:border .2s; }
.ai-nl-box input:focus { border-color:#6366f1; box-shadow:0 0 0 3px rgba(99,102,241,.15); }

/* AI Chat Panel */
.chat-overlay { position:fixed; inset:0; background:rgba(0,0,0,.4); z-index:10000; display:none; }
.chat-overlay.open { display:flex; justify-content:flex-end; }
.chat-panel { width:480px; height:100vh; background:#fff; display:flex; flex-direction:column;
  transform:translateX(100%); transition:transform .3s ease; box-shadow:-4px 0 24px rgba(0,0,0,.15); }
.chat-panel.open { transform:translateX(0); }
.chat-header { padding:12px 16px; background:linear-gradient(135deg,#4f46e5,#7c3aed); color:#fff;
  display:flex; align-items:center; justify-content:space-between; flex-shrink:0; }
.chat-header .ch-title { font-size:14px; font-weight:700; display:flex; align-items:center; gap:6px; }
.chat-header .ch-sub { font-size:10px; opacity:.8; margin-top:2px; }
.chat-header .ch-close { background:none; border:none; color:#fff; font-size:18px; cursor:pointer; padding:4px 8px; border-radius:4px; }
.chat-header .ch-close:hover { background:rgba(255,255,255,.2); }
.chat-header .ch-actions { display:flex; gap:4px; align-items:center; }
.chat-header .ch-btn { background:rgba(255,255,255,.15); border:1px solid rgba(255,255,255,.3); color:#fff;
  font-size:10px; padding:3px 8px; border-radius:4px; cursor:pointer; }
.chat-header .ch-btn:hover { background:rgba(255,255,255,.3); }
.chat-messages { flex:1; overflow-y:auto; padding:12px 16px; display:flex; flex-direction:column; gap:10px; }
.chat-msg { max-width:92%; padding:10px 14px; border-radius:12px; font-size:12px; line-height:1.75; word-break:break-word; }
.chat-msg.user { align-self:flex-end; background:linear-gradient(135deg,#6366f1,#818cf8); color:#fff; border-bottom-right-radius:4px; }
.chat-msg.assistant { align-self:flex-start; background:#f1f5f9; color:var(--text-primary); border-bottom-left-radius:4px; }
.chat-msg.assistant h3 { font-size:13px; font-weight:700; color:var(--primary-navy); margin:10px 0 4px; }
.chat-msg.assistant h4 { font-size:12px; font-weight:600; color:var(--primary-steel); margin:8px 0 3px; }
.chat-msg.assistant strong { color:var(--primary-navy); }
.chat-msg.assistant code { background:#e2e8f0; padding:1px 4px; border-radius:3px; font-size:10.5px; }
.chat-msg.assistant ul, .chat-msg.assistant ol { margin:4px 0; padding-left:18px; }
.chat-msg.assistant li { margin:2px 0; }
.chat-msg.system { align-self:center; background:#eff6ff; color:#3b82f6; font-size:10px; padding:6px 12px;
  border-radius:20px; max-width:100%; text-align:center; }
.chat-msg .msg-time { font-size:9px; opacity:.5; margin-top:4px; text-align:right; }
.chat-typing { display:flex; gap:4px; padding:8px 14px; align-self:flex-start; }
.chat-typing span { width:6px; height:6px; background:#94a3b8; border-radius:50%;
  animation:chatBounce .6s infinite alternate; }
.chat-typing span:nth-child(2) { animation-delay:.2s; }
.chat-typing span:nth-child(3) { animation-delay:.4s; }
@keyframes chatBounce { to { transform:translateY(-6px); opacity:.4; } }
.chat-input-area { padding:10px 12px; border-top:1px solid #e2e8f0; background:#fafbfc; flex-shrink:0; }
.chat-input-row { display:flex; gap:8px; align-items:flex-end; }
.chat-input-row textarea { flex:1; resize:none; border:1px solid #d1d5db; border-radius:10px; padding:10px 14px;
  font-size:12px; font-family:var(--font-body); line-height:1.5; max-height:120px; min-height:40px;
  outline:none; transition:border .2s; }
.chat-input-row textarea:focus { border-color:#6366f1; box-shadow:0 0 0 3px rgba(99,102,241,.12); }
.chat-send-btn { width:38px; height:38px; border:none; border-radius:50%; cursor:pointer;
  background:linear-gradient(135deg,#6366f1,#8b5cf6); color:#fff; font-size:16px;
  display:flex; align-items:center; justify-content:center; flex-shrink:0; transition:all .2s; }
.chat-send-btn:hover { background:linear-gradient(135deg,#4f46e5,#7c3aed); box-shadow:0 2px 8px rgba(99,102,241,.4); }
.chat-send-btn:disabled { opacity:.4; cursor:not-allowed; }
.chat-context-badge { font-size:10px; color:var(--text-muted); padding:4px 0; display:flex; align-items:center; gap:4px; }
.chat-context-badge span { background:#e0e7ff; color:#4338ca; padding:1px 6px; border-radius:10px; font-weight:600; }
</style>
</head>
<body>

<!-- Toast Container -->
<div class="toast-container" id="toastContainer"></div>

<!-- Toolbar -->
<div class="toolbar">
  <span class="app-title">말뚝 기초 설계 계산기</span>
  <span class="pipe-char">|</span>
  <span class="pile-tag phc" id="pileTag">PHC</span>
  <div class="bh-info">
    <span class="bh-label">시추공:</span>
    <span class="bh-value" id="headerBH">-</span>
  </div>
  <button class="btn-toolbar" onclick="openVerifyModal()">&#10003; 검증</button>
  <button class="btn-toolbar" onclick="exportExcel()">&#128196; 엑셀</button>
  <button class="ai-btn btn-toolbar" onclick="runAIReview()">&#9889; AI 검토</button>
  <button class="ai-btn btn-toolbar" onclick="openChatPanel()" style="background:linear-gradient(135deg,#4f46e5,#7c3aed)">&#128172; AI 채팅</button>
</div>

<!-- Tab Navigation -->
<div class="tab-nav">
  <button class="tab-btn active" data-tab="input">입력</button>
  <button class="tab-btn" data-tab="vertical">수직지지력</button>
  <button class="tab-btn" data-tab="horizontal">수평지지력</button>
  <button class="tab-btn" data-tab="pullout">인발</button>
  <button class="tab-btn" data-tab="settlement">침하</button>
  <button class="tab-btn" data-tab="summary">요약</button>
  <button class="tab-btn" data-tab="report">상세보고서</button>
  <span style="flex:1"></span>
  <button class="tab-btn" data-tab="overall" style="background:rgba(233,69,96,0.18);border-radius:4px 4px 0 0">종합결과</button>
</div>

<!-- App Layout: Sidebar + Main -->
<div class="app-layout">

<!-- Sidebar: Borehole List -->
<div class="sidebar" id="sidebar">
  <div class="sidebar-header">
    <span>시추공 목록</span>
    <div style="display:flex;gap:4px;align-items:center">
      <button onclick="toggleBhSort()" id="bhSortBtn" title="시추공 정렬 (오름차순/내림차순)" style="font-size:9px;padding:2px 6px;border:1px solid rgba(255,255,255,0.3);border-radius:3px;background:rgba(255,255,255,0.15);cursor:pointer;color:#fff;letter-spacing:-0.5px">A↓</button>
      <button onclick="toggleSidebar()" title="접기">&#9664;</button>
    </div>
  </div>
  <div id="sidebarList"></div>
</div>
<div class="sidebar-toggle" id="sidebarToggle" onclick="toggleSidebar()" title="시추공 목록">&#9654;</div>

<!-- Main Content -->
<div class="main-content">

<div class="tab-content active" id="tab-input"></div>
<div class="tab-content" id="tab-vertical"></div>
<div class="tab-content" id="tab-horizontal"></div>
<div class="tab-content" id="tab-pullout"></div>
<div class="tab-content" id="tab-settlement"></div>
<div class="tab-content" id="tab-summary"></div>
<div class="tab-content" id="tab-overall"></div>
<div class="tab-content" id="tab-report"></div>

</div><!-- /main-content -->
</div><!-- /app-layout -->

<!-- Borehole Log Slide Panel -->
<div class="panel-overlay" id="panelOverlay" onclick="closeLogPanel()">
  <div class="slide-panel" id="slidePanel" onclick="event.stopPropagation()">
    <div class="panel-header" style="position:relative;">
      <div>
        <div class="ph-title" id="panelTitle">-</div>
        <div class="ph-meta" id="panelMeta"></div>
        <div class="panel-legend" id="panelLegend"></div>
      </div>
      <button class="ph-close" onclick="closeLogPanel()">&#10005;</button>
    </div>
    <div class="panel-body" id="panelBody"></div>
  </div>
</div>

<!-- AI Assistant Panel -->
<div class="panel-overlay" id="aiPanelOverlay" onclick="closeAIPanel()">
  <div class="slide-panel" id="aiSlidePanel" onclick="event.stopPropagation()" style="width:580px">
    <div class="panel-header">
      <div>
        <div class="ph-title" id="aiPanelTitle">AI 분석</div>
        <div class="ph-meta" id="aiPanelMeta"></div>
      </div>
      <button class="ph-close" onclick="closeAIPanel()">&#10005;</button>
    </div>
    <div class="panel-body" id="aiPanelBody" style="padding:16px;">
      <div id="aiContent"></div>
      <div id="aiTokenInfo" style="display:none;margin-top:14px;padding:8px 10px;
           background:#f8f9fa;border-radius:4px;font-size:10px;color:var(--text-muted);"></div>
    </div>
  </div>
</div>

<!-- AI Chat Panel -->
<div class="chat-overlay" id="chatOverlay" onclick="closeChatPanel()">
  <div class="chat-panel" id="chatPanel" onclick="event.stopPropagation()">
    <div class="chat-header">
      <div>
        <div class="ch-title">&#9889; AI &#51648;&#48152;&#44277;&#54617; &#51204;&#47928;&#44032;</div>
        <div class="ch-sub" id="chatContextInfo">&#52968;&#53581;&#49828;&#53944; &#50630;&#51020;</div>
      </div>
      <div class="ch-actions">
        <button class="ch-btn" onclick="clearChatHistory()" title="&#45824;&#54868; &#52488;&#44592;&#54868;">&#128260; &#52488;&#44592;&#54868;</button>
        <button class="ch-close" onclick="closeChatPanel()">&#10005;</button>
      </div>
    </div>
    <div class="chat-messages" id="chatMessages">
      <div class="chat-msg system">AI &#51648;&#48152;&#44277;&#54617; &#51204;&#47928;&#44032;&#50752; &#45824;&#54868;&#47484; &#49884;&#51089;&#54616;&#49464;&#50836;. &#49884;&#52628;&#44277; &#45936;&#51060;&#53552;&#50752; &#44228;&#49328; &#44208;&#44284;&#44032; &#51088;&#46041;&#51004;&#47196; &#51228;&#44277;&#46121;&#45768;&#45796;.</div>
    </div>
    <div class="chat-input-area">
      <div style="display:flex;align-items:center;gap:6px;margin-bottom:4px">
        <div class="chat-context-badge" id="chatBadge" style="flex:1"></div>
        <button id="chatScopeBtn" onclick="toggleChatScope()" style="font-size:9px;padding:3px 8px;border:1px solid #c7d2fe;border-radius:4px;background:#eef2ff;color:#4338ca;cursor:pointer;white-space:nowrap;font-weight:600">현재 시추공</button>
      </div>
      <div class="chat-input-row">
        <textarea id="chatInput" rows="1" placeholder="&#51656;&#47928;&#51012; &#51077;&#47141;&#54616;&#49464;&#50836;... (Shift+Enter: &#51460;&#48148;&#44984;)" onkeydown="handleChatKeydown(event)" oninput="autoResizeChatInput(this)"></textarea>
        <button class="chat-send-btn" id="chatSendBtn" onclick="sendChatMessage()">&#9654;</button>
      </div>
    </div>
  </div>
</div>

<!-- Engineering Guide Modal -->
<div class="guide-overlay" id="guideOverlay" onclick="closeGuide()">
  <div class="guide-modal" onclick="event.stopPropagation()">
    <div class="guide-header"><h3 id="guideTitle">-</h3><button onclick="closeGuide()" class="modal-close" style="background:none;border:none;color:#fff;font-size:18px;cursor:pointer">&times;</button></div>
    <div class="guide-body" id="guideBody"></div>
  </div>
</div>

<!-- Verification Modal -->
<div class="modal-overlay" id="verifyOverlay" onclick="closeVerifyModal()">
  <div class="modal" onclick="event.stopPropagation()">
    <div class="modal-header">
      <h2>&#10003; 검증 모듈</h2>
      <button class="modal-close" onclick="closeVerifyModal()">&#10005;</button>
    </div>
    <div class="modal-body" id="verifyBody"></div>
  </div>
</div>

<!-- SPT Paste Modal -->
<div class="modal-overlay" id="pasteOverlay" onclick="closePasteModal()">
  <div class="modal" style="max-width:820px" onclick="event.stopPropagation()">
    <div class="modal-header">
      <h2>SPT 데이터 붙여넣기</h2>
      <button class="modal-close" onclick="closePasteModal()">&#10005;</button>
    </div>
    <div class="modal-body">
      <p style="font-size:11px;color:var(--text-secondary);margin-bottom:8px">엑셀에서 복사한 SPT 데이터를 아래에 붙여넣으세요.<br>헤더, 빈 행, 다양한 열 순서를 자동 인식합니다. 탭/공백/혼합 구분 모두 지원.</p>
      <textarea class="paste-area" id="pasteArea" placeholder="1	128.38	1.0	10	성토층&#10;2	127.38	2.0	15	퇴적층&#10;&#10;또는 헤더 포함:&#10;No.  EL.+  Depth  N  Remark&#10;m    m     blow/30cm&#10;1    128.38  1.0  10  성토층" oninput="previewPastedSPT()"></textarea>
      <div id="pastePreviewArea" style="display:none;margin-top:10px">
        <div style="display:flex;align-items:center;justify-content:space-between;margin-bottom:6px">
          <span style="font-size:11px;font-weight:700;color:var(--primary-navy)" id="pastePreviewCount"></span>
          <span style="font-size:10px;color:var(--text-muted)" id="pasteDetectInfo"></span>
        </div>
        <div style="max-height:200px;overflow-y:auto;border:1px solid #e0e0e0;border-radius:6px">
          <table style="font-size:10.5px;margin:0" id="pastePreviewTable">
            <thead><tr><th>No.</th><th>Depth (m)</th><th>EL (m)</th><th>N값</th><th>비고(지층)</th></tr></thead>
            <tbody id="pastePreviewBody"></tbody>
          </table>
        </div>
      </div>
      <div style="display:flex;gap:8px;margin-top:10px">
        <button class="btn" id="pasteApplyBtn" onclick="applyParsedSPT()" disabled>적용</button>
        <button class="btn btn-outline" onclick="closePasteModal()">취소</button>
      </div>
    </div>
  </div>
</div>

<script>
// ===== CONSTANTS & CALCULATION ENGINE (from pile_calculator.jsx) =====

const PHC_SPECS = [
  { d: 350, t: 60, Ac: 547, Ic: 59930, wt: 142, types: { A: { Qap_kN: 863, Ze: 3508, Ie: 61400, ps: 40 }, B: { Qap_kN: 647, Ze: 3614, Ie: 63240, ps: 80 }, C: { Qap_kN: 539, Ze: 3655, Ie: 63960, ps: 100 } } },
  { d: 400, t: 65, Ac: 684, Ic: 99580, wt: 178, types: { A: { Qap_kN: 1050, Ze: 5104, Ie: 102100, ps: 40 }, B: { Qap_kN: 1050, Ze: 5229, Ie: 104600, ps: 80 }, C: { Qap_kN: 900, Ze: 5327, Ie: 106500, ps: 100 } } },
  { d: 450, t: 70, Ac: 836, Ic: 156000, wt: 217, types: { A: { Qap_kN: 667, Ze: 7121, Ie: 160200, ps: 40 }, B: { Qap_kN: 981, Ze: 7310, Ie: 164500, ps: 80 }, C: { Qap_kN: 824, Ze: 7437, Ie: 167300, ps: 100 } } },
  { d: 500, t: 80, Ac: 1055, Ic: 241200, wt: 274, types: { A: { Qap_kN: 1650, Ze: 9914, Ie: 247900, ps: 40 }, B: { Qap_kN: 1650, Ze: 10180, Ie: 254500, ps: 80 }, C: { Qap_kN: 1450, Ze: 10360, Ie: 258900, ps: 100 } } },
  { d: 600, t: 90, Ac: 1441, Ic: 483400, wt: 375, types: { A: { Qap_kN: 2550, Ze: 16560, Ie: 496900, ps: 40 }, B: { Qap_kN: 2300, Ze: 17010, Ie: 570400, ps: 80 }, C: { Qap_kN: 2000, Ze: 17330, Ie: 519800, ps: 100 } } },
];
const STEEL_SPECS = [
  { d: 406.4, options: [
    { t: 9, W: 88.2, Ap: 112.4, I: 22200, Z: 1090, K: 14.0, Qap: 1131 },
    { t: 10, W: 97.8, Ap: 124.5, I: 24500, Z: 1200, K: 14.0, Qap: 1426 },
    { t: 12, W: 117.0, Ap: 148.7, I: 28900, Z: 1420, K: 14.0, Qap: 1823 } ] },
  { d: 508.0, options: [
    { t: 9, W: 111.0, Ap: 141.1, I: 43900, Z: 1730, K: 17.6, Qap: 1520 },
    { t: 10, W: 123.0, Ap: 156.5, I: 48500, Z: 1910, K: 17.6, Qap: 1754 },
    { t: 12, W: 147.0, Ap: 187.0, I: 57500, Z: 2270, K: 17.5, Qap: 2233 } ] },
  { d: 609.6, options: [
    { t: 9, W: 133.0, Ap: 169.8, I: 76600, Z: 2510, K: 21.2, Qap: 1808 },
    { t: 10, W: 148.0, Ap: 188.4, I: 84700, Z: 2780, K: 21.2, Qap: 2082 },
    { t: 12, W: 177.0, Ap: 225.3, I: 101000, Z: 3300, K: 21.1, Qap: 2642 } ] },
];
const SOIL_OPTS = ["성토층","전답토(CL)","퇴적층(SM)","퇴적층(CL)","퇴적층(SP)","풍화토(SM)","풍화토(CL)","풍화암(WR)","연암(SR)","경암(HR)","자갈층(GP)","모래층(SP)","실트층(ML)"];
const SOIL_CLS = {"성토층":"sand","전답토(CL)":"clay","퇴적층(SM)":"sand","퇴적층(CL)":"clay","퇴적층(SP)":"sand","풍화토(SM)":"sand","풍화토(CL)":"clay","풍화암(WR)":"sand","연암(SR)":"rock","경암(HR)":"rock","자갈층(GP)":"sand","모래층(SP)":"sand","실트층(ML)":"clay"};
const UW_DEF = {"성토층":18,"전답토(CL)":16,"퇴적층(SM)":18,"퇴적층(CL)":17,"퇴적층(SP)":18,"풍화토(SM)":19,"풍화토(CL)":18,"풍화암(WR)":20,"연암(SR)":22,"경암(HR)":24,"자갈층(GP)":19,"모래층(SP)":18,"실트층(ML)":17};
const SOIL_COLORS = {"매립":"#8B7355","붕적":"#C4A484","퇴적":"#D2B48C","충적":"#DEB887","풍화잔류토":"#E8C872","풍화토":"#DEB887","풍화암":"#BDB76B","연암":"#A9A9A9","경암":"#696969","전답":"#C4A484","성토":"#8B7355","자갈":"#B8860B","모래":"#F4A460","실트":"#D3D3D3"};

function getSoilColor(name) {
  if (!name) return '#E0E0E0';
  for (const [key, color] of Object.entries(SOIL_COLORS)) {
    if (name.includes(key)) return color;
  }
  return '#E0E0E0';
}

function calcPile(p) {
  const isPHC = p.pileType === "PHC";
  const D = p.diameter_mm / 1000, t = p.thickness_mm / 1000;
  const tipEL = p.bearingEL - (p.embedDepth || 0);
  const pileLength = p.pileTopEL - tipEL;
  const cutFillDepth = p.pileTopEL - p.groundEL;
  const gwlEL = p.groundEL - p.gwlDepth;
  let Ap_tip, Ap_net, I, Zp, E, Qap, n_slender, W_unit, At_steel = 0, Ai_steel = 0, steelSpec = null;
  if (isPHC) {
    const row = PHC_SPECS.find(r => r.d === p.diameter_mm);
    Ap_tip = Math.PI / 4 * D * D;
    if (row) {
      Ap_net = row.Ac / 10000; I = row.Ic / 1e8;
      const td = row.types[p.phcGrade || "A"];
      Zp = td.Ze / 1e6; Qap = td.Qap_kN;
    } else {
      Ap_net = Math.PI / 4 * (D * D - Math.pow(D - 2 * t, 2));
      I = Math.PI / 64 * (Math.pow(D, 4) - Math.pow(D - 2 * t, 4));
      Zp = I / (D / 2); Qap = 1650;
    }
    E = 39200000; n_slender = 85; W_unit = Ap_net * 24;
  } else {
    const corr = (p.corrosionThickness_mm || 2) / 1000;
    const dRow = STEEL_SPECS.find(r => r.d === p.diameter_mm);
    steelSpec = dRow ? dRow.options.find(o => o.t === p.thickness_mm) : null;
    Ap_tip = Math.PI / 4 * D * D;
    At_steel = Math.PI / 4 * (D * D - Math.pow(D - 2 * (t - corr), 2));
    Ai_steel = Math.PI / 4 * Math.pow(D - 2 * t, 2);
    if (steelSpec) {
      Ap_net = steelSpec.Ap / 10000; I = steelSpec.I / 1e8;
      Zp = steelSpec.Z / 1e6; Qap = steelSpec.Qap;
      W_unit = steelSpec.W * 9.80665 / 1000;
    } else {
      Ap_net = Math.PI / 4 * (D * D - Math.pow(D - 2 * t, 2));
      I = Math.PI / 64 * (Math.pow(D, 4) - Math.pow(D - 2 * t, 4));
      Zp = I / (D / 2); Qap = Ap_net * 235000 / 3; W_unit = Ap_net * 78.5;
    }
    E = 200000000; n_slender = 100;
  }
  const U = Math.PI * D, EI = E * I;
  // 2.1.1 Material
  const L_over_d = pileLength / D;
  const mu1 = L_over_d > n_slender ? Math.min((L_over_d / n_slender - 1) * 100, 30) : 0;
  const jc = p.jointCount || 0;
  let mu2 = 0;
  if (jc > 0) {
    const jt = p.jointType || "welding";
    if (jt === "welding") mu2 = jc * 5;
    else if (jt === "bolt") mu2 = jc * 10;
    else mu2 = Math.min(jc, 2) * 20 + Math.max(jc - 2, 0) * 30;
  }
  const Qp_material = (1 - (mu1 + mu2) / 100) * Qap;
  // Fill layer + Cut handling + Layers
  const fillHeight = p.useFill && p.plannedEL ? Math.max(p.plannedEL - p.groundEL, 0) : 0;
  const cutDepth = p.useFill && p.plannedEL ? Math.max(p.groundEL - p.plannedEL, 0) : 0;
  const processedLayers = [];
  if (fillHeight > 0) {
    const fillAs = U * fillHeight;
    const fillcN = Math.min(p.fillN || 5, 30);
    processedLayers.push({ soilType: '성토층(계획)', thickness: fillHeight, avgN: p.fillN || 5,
      unitWeight: 18, depthFrom: -fillHeight, depthTo: 0, soilClass: 'sand', As: fillAs,
      skinFriction_sand: 2 * fillcN * fillAs, skinFriction_clay: 0, isFill: true });
  }
  // 주면마찰력: 선단(tipEL)까지만 산정 — 마지막 층 두께 보정
  // 절토 시: cutDepth까지의 지층을 삭제/절단 (설계지반면이 계획고로 내려감)
  const bearingDepthFromGL = p.groundEL - tipEL;
  let cumDepth = 0;
  if (p.layers) p.layers.forEach(layer => {
    const layerTop = layer.depthFrom != null ? layer.depthFrom : cumDepth;
    const layerBot = layer.depthFrom != null ? (layer.depthFrom + layer.thickness) : (cumDepth + layer.thickness);
    cumDepth = layerBot;
    // 지지층 깊이 초과 지층 건너뜀
    if (layerTop >= bearingDepthFromGL) return;
    // 절토 처리: cutDepth 이내의 지층은 삭제/절단
    let effTop = layerTop;
    let effBot = layerBot;
    if (cutDepth > 0) {
      if (layerBot <= cutDepth) return; // 전체가 절토 범위 내 → 삭제
      if (layerTop < cutDepth) effTop = cutDepth; // 상부 일부 절토 → 절단
    }
    // 마지막 층 두께 보정: 지지층 깊이에서 절단
    if (effBot > bearingDepthFromGL) effBot = bearingDepthFromGL;
    let effThickness = effBot - effTop;
    if (effThickness <= 0) return;
    const truncated = (effBot < layerBot) || (effTop > layerTop);
    const sc = SOIL_CLS[layer.soilType] || "sand";
    const As_i = U * effThickness;
    const cN = Math.min(layer.avgN, 30);
    processedLayers.push({ ...layer, thickness: parseFloat(effThickness.toFixed(3)), origThickness: layer.thickness, soilClass: sc, As: As_i,
      skinFriction_sand: sc === "sand" ? 2 * cN * As_i : 0,
      skinFriction_clay: sc === "clay" ? 6.25 * cN * As_i : 0,
      depthFrom: effTop, depthTo: parseFloat(effBot.toFixed(3)), truncated });
  });
  const sum_2NsAs = processedLayers.reduce((s, l) => s + l.skinFriction_sand, 0);
  const sum_625NcAc = processedLayers.reduce((s, l) => s + l.skinFriction_clay, 0);
  const tipSPT = p.sptData && p.sptData.length > 0 ? p.sptData[p.sptData.length - 1] : { N: 50 };
  const N_tip = Math.min(tipSPT.N, 50);
  let Pu_tip, Pu_goodman = null, Pu_canadian = null, Pu_selected, rockCalcDetails = null;
  const method = p.bearingMethod || (isPHC ? "meyerhof" : "rock");
  if (!isPHC && method === "rock") {
    const qu_eff = Math.min(p.qu_kPa || 10000, 10000);
    const qu_lab = p.qu_kPa || 32460;
    Pu_tip = 443 * Math.pow(qu_eff, 0.5) * Math.pow(At_steel, 2 / 5) * Math.pow(Ai_steel, 1 / 3);
    const phi_rock = p.rockPhi_deg || 35;
    const N_phi = Math.pow(Math.tan((45 + phi_rock / 2) * Math.PI / 180), 2);
    const Ap_full = Math.PI / 4 * D * D;
    Pu_goodman = qu_lab * (N_phi + 1) * Ap_full;
    const Sd = p.Sd_m || 0.15, td2 = p.td_m || 0.002;
    const Ksp = (3 + Sd / D) / (10 * Math.sqrt(1 + 300 * td2 / Sd));
    Pu_canadian = 3 * qu_lab * Ksp * 2 * Ap_full;
    Pu_selected = Math.min(Pu_tip, Pu_goodman, Pu_canadian);
    rockCalcDetails = { qu_eff, qu_lab, At_m2: At_steel, Ai_m2: Ai_steel, Pu_tip, phi_rock, N_phi, Ap_full, Pu_goodman, Sd, td: td2, Ksp, Pu_canadian, Pu_selected };
  } else {
    Pu_selected = 250 * N_tip * Ap_tip; Pu_tip = Pu_selected;
  }
  const Qu = Pu_selected + sum_2NsAs + sum_625NcAc;
  const Qu_tip = Pu_selected, Qu_skin = sum_2NsAs + sum_625NcAc;
  const FS = 3, Qa_ground = Qu / FS;
  const Qa_applied = Math.min(Qp_material, Qa_ground);
  // 2.2 Horizontal — 가이드 기준 수정
  // 강관: 부식두께 적용한 I_h, Zp_h 사용
  let I_h = I, Zp_h = Zp, EI_h = EI;
  if (!isPHC) {
    const corr_h = (p.corrosionThickness_mm || 2) / 1000;
    const D_corr = D - 2 * corr_h;
    I_h = Math.PI / 64 * (Math.pow(D, 4) - Math.pow(D_corr, 4));
    Zp_h = I_h / (D / 2);
    EI_h = E * I_h;
  } else {
    // PHC: Z = I/(D/2) per guide §6.4
    Zp_h = I / (D / 2);
  }
  // N_kh: 설계지반면~1/β 상부지반 대표N 반복계산 (가이드 §2.2)
  // 성토 적용 시: 설계지반면 = 계획고, SPT depth를 계획고 기준으로 환산
  // 절토 적용 시: 절토 깊이 이내 SPT 제거, 나머지 depth에서 cutDepth 차감
  const a = p.alpha_kh || 1;
  const sptValid = p.sptData && p.sptData.length > 0;
  const sptForKh = [];
  if (fillHeight > 0) {
    // 성토층: 1m 간격으로 fillN 가상 SPT 추가
    const fillN_val = p.fillN || 5;
    for (let d = 1; d <= fillHeight; d++) {
      sptForKh.push({ depth: d, N: fillN_val });
    }
    // 원지반 SPT: depth에 fillHeight를 더해서 설계지반면 기준으로 환산
    if (sptValid) {
      p.sptData.forEach(s => {
        sptForKh.push({ depth: s.depth + fillHeight, N: s.N });
      });
    }
  } else if (cutDepth > 0 && sptValid) {
    // 절토: cutDepth 이내 SPT 제거, 나머지는 depth - cutDepth로 환산 (설계지반면 기준)
    p.sptData.forEach(s => {
      if (s.depth > cutDepth) {
        sptForKh.push({ depth: s.depth - cutDepth, N: s.N });
      }
    });
  } else if (sptValid) {
    p.sptData.forEach(s => sptForKh.push({ depth: s.depth, N: s.N }));
  }
  function calcNkhForDepth(depthLimit) {
    if (sptForKh.length === 0) return 10;
    const inRange = sptForKh.filter(s => s.depth <= depthLimit && s.N < 50);
    if (inRange.length === 0) {
      const first = sptForKh.find(s => s.N < 50);
      return first ? first.N : 10;
    }
    return inRange.reduce((s, d) => s + d.N, 0) / inRange.length;
  }
  function calcKhBeta(nVal) {
    const eo2800 = 2800 * nVal, eo1000 = 1000 * nVal;
    const kh1 = 1.208 * Math.pow(a * eo2800, 1.1) * Math.pow(D, -0.31) * Math.pow(EI_h, -0.1);
    const kh2 = 6910 * Math.pow(nVal, 0.406);
    const kh3 = 2000 * nVal;
    const kh4 = 1.208 * Math.pow(a * eo1000, 1.1) * Math.pow(D, -0.31) * Math.pow(EI_h, -0.1);
    const khMin = Math.min(kh1, kh2, kh3, kh4);
    const b = Math.pow((khMin * D) / (4 * EI_h), 0.25);
    return { kh1, kh2, kh3, kh4, khMin, beta: b, invBeta: 1 / b };
  }
  // 반복: 초기 N_kh(전체 평균) → β → 1/β 범위 N → 재계산 → 수렴
  let N_kh = Math.max(calcNkhForDepth(9999), 1);
  let khResult = calcKhBeta(N_kh);
  for (let iter = 0; iter < 10; iter++) {
    const newN = Math.max(calcNkhForDepth(khResult.invBeta), 1);
    if (Math.abs(newN - N_kh) < 0.01) break;
    N_kh = newN;
    khResult = calcKhBeta(N_kh);
  }
  const Eo2800 = 2800 * N_kh, Eo1000 = 1000 * N_kh;
  const Kh1 = khResult.kh1, Kh2 = khResult.kh2, Kh3 = khResult.kh3, Kh4 = khResult.kh4;
  const Kh_min = khResult.khMin;
  const beta = khResult.beta;
  const nh = Kh_min * D / (1 / beta);
  const eta = Math.pow(nh / EI_h, 0.2);
  const etaL = eta * pileLength;
  const pileClass = etaL < 2 ? "짧은말뚝" : etaL <= 4 ? "중간말뚝" : "긴말뚝";
  const phi_deg = Math.sqrt(12 * N_kh) + 15;
  const phi_rad = phi_deg * Math.PI / 180;
  const Kp = (1 + Math.sin(phi_rad)) / (1 - Math.sin(phi_rad));
  const gamma_top = processedLayers.length > 0 ? processedLayers[0].unitWeight : (p.layers && p.layers.length > 0 ? p.layers[0].unitWeight : 18);
  const deltaM = (p.delta_cm || 1.5) / 100;
  const H_disp = 4 * Math.pow(beta, 3) * EI_h * deltaM;
  const My_case1 = H_disp / (2 * beta);
  let Hu_brom1;
  if (pileClass === "긴말뚝") { const term = My_case1 / (Kp * gamma_top * Math.pow(D, 4)); Hu_brom1 = 2.38 * Math.pow(term, 2 / 3) * Kp * gamma_top * Math.pow(D, 3); }
  else if (pileClass === "짧은말뚝") { Hu_brom1 = 1.5 * Kp * gamma_top * D * pileLength * pileLength; }
  else { const term = My_case1 / (Kp * Math.pow(D, 4) * gamma_top); Hu_brom1 = Kp * Math.pow(D, 3) * gamma_top * (term + 0.5 * Math.pow(pileLength / D, 3)) * (D / pileLength); }
  const Ha_brom1 = Hu_brom1 / 2.5;
  const sigma_max = p.sigmaMax_kN || (isPHC ? 20000 : 235000);
  const My_case2 = Zp_h * sigma_max;
  let Hu_brom2;
  if (pileClass === "긴말뚝") { const t2 = My_case2 / (Kp * gamma_top * Math.pow(D, 4)); Hu_brom2 = 2.38 * Math.pow(t2, 2 / 3) * Kp * gamma_top * Math.pow(D, 3); }
  else { Hu_brom2 = Hu_brom1; }
  const Ha_brom2 = Hu_brom2 / 2.5;
  const Ha_brom = Math.min(Ha_brom1, Ha_brom2);
  const Ha_chang = deltaM * Kh_min * D / beta;
  const Ha_applied = Math.min(Ha_brom, Ha_chang);
  // Pull-out
  const l1 = Math.max(p.pileTopEL - gwlEL, 0);
  const l2 = pileLength - l1;
  const Wp = W_unit * pileLength - (l2 > 0 ? Ap_tip * l2 * 10 : 0);
  const Qpull = Qu_skin / FS + Math.max(Wp, 0);
  // Settlement
  const ratio_tip = Qu_tip / Math.max(Qu, 1);
  const Qps = Qa_applied * ratio_tip, Qfs = Qa_applied * (1 - ratio_tip);
  const Ss = (Qps + 0.67 * Qfs) * (pileLength * 1000) / (Ap_net * E);
  const Cp = 0.09;
  const qp = Qu_tip / Math.max(Ap_tip, 0.001);
  const Sp = (Qps * Cp) / (D * Math.max(qp, 1)) * 1000;
  const Cs = (0.93 + 0.16 * Math.sqrt(pileLength / D)) * Cp;
  const Sps = (Qfs * Cs) / (pileLength * Math.max(qp, 1)) * 1000;
  const St = Ss + Sp + Sps;
  return { D, t, pileLength, cutFillDepth, fillHeight, cutDepth, gwlEL, U, Ap_tip, Ap_net, I, Zp, E, EI, W_unit,
    I_h, Zp_h, EI_h,
    L_over_d, mu1, mu2, Qap, Qp_material, n_slender,
    N_tip, Qu, Qu_tip, Qu_skin, Qa_ground, FS, sum_2NsAs, sum_625NcAc, processedLayers, Qa_applied, bearingDepthFromGL,
    groundEL: p.groundEL, bearingEL: p.bearingEL, tipEL, embedDepth: p.embedDepth || 0,
    At_steel, Ai_steel, steelSpec, rockCalcDetails, method, Pu_tip, Pu_goodman, Pu_canadian, Pu_selected,
    N_kh: Math.round(N_kh * 100) / 100, Eo2800, Eo1000, invBeta: 1 / beta,
    Kh1, Kh2, Kh3, Kh4, Kh_min,
    beta, betaL: beta * pileLength, eta, etaL, pileClass,
    phi_deg, Kp, gamma_top,
    H_disp, My_case1, Hu_brom1, Ha_brom1, My_case2, Hu_brom2, Ha_brom2, Ha_brom, Ha_chang, Ha_applied,
    l1, l2, Wp, Qpull, ratio_tip, Qps, Qfs, Ss, Sp, Sps, St, Cp, Cs, qp };
}

const fmt = (v, d = 2) => v != null && !isNaN(v) ? Number(v).toFixed(d) : "-";
const fmtE = v => v != null ? v.toExponential(3) : "-";

// ===== STATE MANAGEMENT =====
const STATE = {
  pileType: "PHC", diameter_mm: 500, thickness_mm: 80, phcGrade: "A",
  pileTopEL: 130, groundEL: 127.38, bearingEL: 119.98, embedDepth: 1, gwlDepth: 3.75,
  boreholeNo: "NBH-03", alpha_kh: 1, delta_cm: 1.5, sigmaMax: 20000,
  useFill: false, plannedEL: null, fillN: 5,
  bearingMethod: "meyerhof", corrosionThk: 2, qu_kPa: 32460,
  Sd_m: 0.15, td_m: 0.002, rockPhi: 35, jointCount: 1, jointType: "welding",
  sptData: [
    { depth: 1, N: 10, remark: "성토층" }, { depth: 2, N: 10, remark: "성토층" },
    { depth: 3.62, N: 19, remark: "퇴적층(SM)" }, { depth: 4.62, N: 7, remark: "퇴적층(SM)" },
    { depth: 5.62, N: 6, remark: "퇴적층(SM)" }, { depth: 6.62, N: 7, remark: "퇴적층(SM)" },
    { depth: 7.62, N: 43, remark: "풍화토(SM)" }, { depth: 8.62, N: 50, remark: "풍화토(SM)" },
    { depth: 9.62, N: 50, remark: "풍화암(WR)" },
  ],
  layers: [
    { soilType: "성토층", depthFrom: 0, depthTo: 2.62, thickness: 2.62, avgN: 10, unitWeight: 18 },
    { soilType: "전답토(CL)", depthFrom: 2.62, depthTo: 3.12, thickness: 0.5, avgN: 19, unitWeight: 16 },
    { soilType: "퇴적층(SM)", depthFrom: 3.12, depthTo: 7.12, thickness: 4, avgN: 9.75, unitWeight: 18 },
    { soilType: "풍화토(SM)", depthFrom: 7.12, depthTo: 9.02, thickness: 1.9, avgN: 30, unitWeight: 19 },
    { soilType: "풍화암(WR)", depthFrom: 9.02, depthTo: 10.02, thickness: 1, avgN: 30, unitWeight: 20 },
  ],
  uploadedData: null, // parsed JSON
  currentBhIdx: -1, // active borehole index in uploadedData
  result: null, // calcPile result
};

// Verification data (NBH-03 PHC, NBH-09 Steel)
const VERIFY_DATA = {
  phc: {
    label: "PHC D500x80t (NBH-03)", pileType: "PHC", diameter_mm: 500, thickness_mm: 80, phcGrade: "A",
    boreholeNo: "NBH-03", groundEL: 127.38, bearingEL: 119.98, pileTopEL: 130, gwlDepth: 3.75,
    bearingMethod: "meyerhof", sigmaMax: 20000, alpha_kh: 1, delta_cm: 1.5, jointCount: 1, jointType: "welding", embedDepth: 1,
    sptData: [{depth:1,N:10,remark:"성토층"},{depth:2,N:10,remark:"성토층"},{depth:3.62,N:19,remark:"퇴적층(SM)"},{depth:4.62,N:7,remark:"퇴적층(SM)"},{depth:5.62,N:6,remark:"퇴적층(SM)"},{depth:6.62,N:7,remark:"퇴적층(SM)"},{depth:7.62,N:43,remark:"풍화토(SM)"},{depth:8.62,N:50,remark:"풍화토(SM)"},{depth:9.62,N:50,remark:"풍화암(WR)"}],
    layers: [{soilType:"성토층",thickness:2.62,avgN:10,unitWeight:18},{soilType:"전답토(CL)",thickness:0.5,avgN:19,unitWeight:16},{soilType:"퇴적층(SM)",thickness:4,avgN:9.75,unitWeight:18},{soilType:"풍화토(SM)",thickness:1.9,avgN:30,unitWeight:19},{soilType:"풍화암(WR)",thickness:1,avgN:30,unitWeight:20}],
  },
  steel: {
    label: "Steel D609.6x12t (NBH-09)", pileType: "강관", diameter_mm: 609.6, thickness_mm: 12,
    boreholeNo: "NBH-09", groundEL: 125.19, bearingEL: 112.19, pileTopEL: 130, gwlDepth: 1.7,
    bearingMethod: "rock", sigmaMax: 235000, corrosionThk: 2, qu_kPa: 32460, Sd_m: 0.15, td_m: 0.002, rockPhi: 35,
    alpha_kh: 1, delta_cm: 1.5, jointCount: 1, jointType: "welding", embedDepth: 1,
    sptData: [{depth:1,N:10,remark:"성토층"},{depth:2,N:10,remark:"성토층"},{depth:3,N:10,remark:"성토층"},{depth:4,N:10,remark:"성토층"},{depth:5,N:6,remark:"퇴적층(SM)"},{depth:6,N:9,remark:"퇴적층(SM)"},{depth:7,N:22,remark:"퇴적층(SM)"},{depth:8,N:28,remark:"퇴적층(SM)"},{depth:9,N:50,remark:"풍화토(SM)"},{depth:10,N:50,remark:"풍화토(SM)"},{depth:11,N:50,remark:"풍화토(SM)"},{depth:12,N:50,remark:"풍화토(SM)"},{depth:13,N:50,remark:"풍화토(SM)"},{depth:14,N:50,remark:"풍화암(WR)"},{depth:15,N:50,remark:"풍화암(WR)"},{depth:16,N:50,remark:"연암(SR)"}],
    layers: [{soilType:"성토층",thickness:4.81,avgN:10,unitWeight:18},{soilType:"전답토(CL)",thickness:0.6,avgN:6,unitWeight:16},{soilType:"퇴적층(SM)",thickness:1.9,avgN:7.5,unitWeight:18},{soilType:"퇴적층(SP)",thickness:2,avgN:25,unitWeight:18},{soilType:"풍화토(SM)",thickness:5.5,avgN:50,unitWeight:19},{soilType:"풍화암(WR)",thickness:2,avgN:50,unitWeight:20},{soilType:"연암(SR)",thickness:1,avgN:50,unitWeight:23}],
  }
};

function recalculate() {
  invalidateAICache();
  try {
    STATE.result = calcPile({
      pileType: STATE.pileType, diameter_mm: STATE.diameter_mm, thickness_mm: STATE.thickness_mm,
      phcGrade: STATE.phcGrade, pileTopEL: STATE.pileTopEL, groundEL: STATE.groundEL,
      bearingEL: STATE.bearingEL, gwlDepth: STATE.gwlDepth, sptData: STATE.sptData,
      layers: STATE.layers, alpha_kh: STATE.alpha_kh, delta_cm: STATE.delta_cm,
      sigmaMax_kN: STATE.sigmaMax, corrosionThickness_mm: STATE.corrosionThk,
      qu_kPa: STATE.qu_kPa, Sd_m: STATE.Sd_m, td_m: STATE.td_m, rockPhi_deg: STATE.rockPhi,
      bearingMethod: STATE.bearingMethod, jointCount: STATE.jointCount, jointType: STATE.jointType,
      useFill: STATE.useFill, plannedEL: STATE.plannedEL, fillN: STATE.fillN,
      embedDepth: STATE.embedDepth
    });
  } catch (e) { console.error('Calc error:', e); STATE.result = null; }
  // Auto-save edits back to uploadedData
  saveCurrentToUploadedData();
  renderAllTabs();
}

// ===== JSON IMPORT ENGINE =====
function parseHits(hits) {
  if (hits == null || hits === '' || typeof hits !== 'string' || hits.trim() === '') return null;
  const h = hits.trim();
  const parts = h.split('/');
  if (parts.length < 2) { const v = parseInt(h); return isNaN(v) ? null : Math.min(v, 50); }
  const blows = parseInt(parts[0]);
  const pen = parseInt(parts[1]);
  if (isNaN(blows) || isNaN(pen)) return null;
  if (pen >= 30) return blows;
  if (blows >= 50) return 50;
  return Math.min(Math.round(blows * 30 / pen), 50);
}

function mapSoilName(name) {
  if (!name) return "퇴적층(SM)";
  const n = name.toLowerCase ? name : String(name);
  if (n.includes("매립") || n.includes("성토") || n.includes("붕적") || n.includes("봉적")) return "성토층";
  if (n.includes("전답") || n.includes("경작")) return "전답토(CL)";
  if (n.includes("풍화암")) return "풍화암(WR)";
  if (n.includes("연암")) return "연암(SR)";
  if (n.includes("경암")) return "경암(HR)";
  if (n.includes("풍화토") || n.includes("풍화잔류")) {
    if (n.includes("CL") || n.includes("점토")) return "풍화토(CL)";
    return "풍화토(SM)";
  }
  if (n.includes("퇴적") || n.includes("충적")) {
    if (n.includes("CL") || n.includes("점토")) return "퇴적층(CL)";
    if (n.includes("SP")) return "퇴적층(SP)";
    return "퇴적층(SM)";
  }
  if (n.includes("자갈")) return "자갈층(GP)";
  if (n.includes("모래")) return "모래층(SP)";
  if (n.includes("실트")) return "실트층(ML)";
  return "퇴적층(SM)";
}

function parseDepthRange(dr) {
  if (!dr) return [0, 0];
  const cleaned = dr.replace(/m/gi, '').replace(/\s/g, '');
  const parts = cleaned.split(/[~\-]/);
  return [parseFloat(parts[0]) || 0, parseFloat(parts[1]) || 0];
}

function parseElevation(el) {
  if (typeof el === 'number') return el;
  if (!el) return null;
  const m = String(el).match(/([\d.]+)/);
  return m ? parseFloat(m[1]) : null;
}

function parseWaterLevel(wl) {
  if (typeof wl === 'number') return wl;
  if (!wl) return null;
  const m = String(wl).match(/([\d.]+)/);
  return m ? parseFloat(m[1]) : null;
}

function importDrillLogJSON(json) {
  let boreholes = [];
  // Format A/B: { extracted_data: [...] }
  if (json.extracted_data && Array.isArray(json.extracted_data)) {
    boreholes = json.extracted_data.map(bh => {
      const meta = bh.metadata || {};
      const groundEL = parseElevation(meta.GROUND_SURFACE_LEVEL);
      const gwlDepth = parseWaterLevel(meta.GROUND_WATER_LEVEL);
      // Extract SPT from soil_data.samples
      const sptMap = new Map();
      const soilLayers = [];
      (bh.soil_data || []).forEach(sd => {
        const [dFrom, dTo] = parseDepthRange(sd.depth_range);
        const mappedSoil = mapSoilName(sd.soil_name);
        soilLayers.push({ soilName: sd.soil_name, soilType: mappedSoil, depthFrom: dFrom, depthTo: dTo, thickness: dTo - dFrom });
        (sd.samples || []).forEach(s => {
          const key = s.Depth || s.depth;
          const nVal = parseHits(s.Hits || s.hits);
          if (key != null && nVal !== null && !sptMap.has(key)) {
            sptMap.set(key, { depth: key, N: nVal, remark: mappedSoil });
          }
        });
      });
      const sptData = Array.from(sptMap.values()).sort((a, b) => a.depth - b.depth);
      // Build averaged layers
      const layers = soilLayers.filter(l => l.thickness > 0).map(l => {
        const layerSPTs = sptData.filter(s => s.depth >= l.depthFrom && s.depth <= l.depthTo);
        let avgN, sptNote;
        if (layerSPTs.length > 0) {
          avgN = layerSPTs.reduce((s, v) => s + v.N, 0) / layerSPTs.length;
          sptNote = layerSPTs.map(s => s.depth + 'm(N=' + s.N + ')').join(', ');
        } else {
          // 인접 SPT 탐색: 가장 가까운 SPT 사용
          let nearest = null, minDist = Infinity;
          const mid = (l.depthFrom + l.depthTo) / 2;
          sptData.forEach(s => { const d = Math.abs(s.depth - mid); if (d < minDist) { minDist = d; nearest = s; } });
          if (nearest && minDist <= 3) {
            avgN = nearest.N;
            sptNote = '(인접 SPT 적용: ' + nearest.depth + 'm, N=' + nearest.N + ')';
          } else {
            const st = l.soilType;
            avgN = (st.includes('연암') || st.includes('경암')) ? 50 : st.includes('풍화암') ? 50 : st.includes('풍화토') ? 30 : 10;
            sptNote = '(SPT없음, 지층 기본값)';
          }
        }
        return { soilType: l.soilType, depthFrom: parseFloat(l.depthFrom.toFixed(2)), depthTo: parseFloat(l.depthTo.toFixed(2)), thickness: parseFloat(l.thickness.toFixed(2)), avgN: parseFloat(avgN.toFixed(1)), unitWeight: UW_DEF[l.soilType] || 18, _sptDetail: layerSPTs.length > 0 ? sptNote : sptNote, _sptCount: layerSPTs.length };
      });
      return { holeNo: bh.hole_no || meta.HOLE_NO || 'Unknown', groundEL, gwlDepth, sptData, layers, soilLayers, meta };
    });
  }
  // Format C: { metadata, soil_layers, spt_data }
  else if (json.spt_data || json.soil_layers) {
    const meta = json.metadata || {};
    const groundEL = meta.elevation || parseElevation(meta.GROUND_SURFACE_LEVEL);
    const gwlDepth = meta.water_level || parseWaterLevel(meta.GROUND_WATER_LEVEL);
    const sptData = (json.spt_data || []).map(s => ({
      depth: s.depth, N: Math.min(s.n_value || s.N || 10, 50), remark: mapSoilName(s.soil_type || s.notes || "")
    }));
    const soilLayers = (json.soil_layers || []).map(l => ({
      soilName: l.soil_type || l.description, soilType: mapSoilName(l.soil_type),
      depthFrom: l.depth_from, depthTo: l.depth_to, thickness: l.depth_to - l.depth_from
    }));
    const layers = soilLayers.filter(l => l.thickness > 0).map(l => {
      const layerSPTs = sptData.filter(s => s.depth >= l.depthFrom && s.depth <= l.depthTo);
      let avgN, sptNote;
      if (layerSPTs.length > 0) {
        avgN = layerSPTs.reduce((s, v) => s + v.N, 0) / layerSPTs.length;
        sptNote = layerSPTs.map(s => s.depth + 'm(N=' + s.N + ')').join(', ');
      } else {
        let nearest = null, minDist = Infinity;
        const mid = (l.depthFrom + l.depthTo) / 2;
        sptData.forEach(s => { const d = Math.abs(s.depth - mid); if (d < minDist) { minDist = d; nearest = s; } });
        if (nearest && minDist <= 3) {
          avgN = nearest.N;
          sptNote = '(인접 SPT 적용: ' + nearest.depth + 'm, N=' + nearest.N + ')';
        } else {
          const st = l.soilType;
          avgN = (st.includes('연암') || st.includes('경암')) ? 50 : st.includes('풍화암') ? 50 : st.includes('풍화토') ? 30 : 10;
          sptNote = '(SPT없음, 지층 기본값)';
        }
      }
      return { soilType: l.soilType, depthFrom: parseFloat(l.depthFrom.toFixed(2)), depthTo: parseFloat(l.depthTo.toFixed(2)), thickness: parseFloat(l.thickness.toFixed(2)), avgN: parseFloat(avgN.toFixed(1)), unitWeight: UW_DEF[l.soilType] || 18, _sptDetail: layerSPTs.length > 0 ? sptNote : sptNote, _sptCount: layerSPTs.length };
    });
    boreholes.push({ holeNo: meta.hole_no || meta.HOLE_NO || 'BH-1', groundEL, gwlDepth, sptData, layers, soilLayers, meta });
  }
  return boreholes;
}

function saveCurrentToUploadedData() {
  if (!STATE.uploadedData || STATE.currentBhIdx < 0 || STATE.currentBhIdx >= STATE.uploadedData.length) return;
  const bh = STATE.uploadedData[STATE.currentBhIdx];
  bh.groundEL = STATE.groundEL;
  bh.gwlDepth = STATE.gwlDepth;
  bh.bearingEL = STATE.bearingEL;
  bh.sptData = JSON.parse(JSON.stringify(STATE.sptData));
  bh.layers = JSON.parse(JSON.stringify(STATE.layers));
}

function applyBoreholeData(bh, idx) {
  if (!bh) return;
  STATE.boreholeNo = bh.holeNo;
  if (idx != null) STATE.currentBhIdx = idx;
  if (bh.groundEL != null) STATE.groundEL = bh.groundEL;
  if (bh.gwlDepth != null) STATE.gwlDepth = bh.gwlDepth;
  if (bh.bearingEL != null) STATE.bearingEL = bh.bearingEL;
  if (bh.sptData && bh.sptData.length > 0) STATE.sptData = JSON.parse(JSON.stringify(bh.sptData));
  if (bh.layers && bh.layers.length > 0) STATE.layers = JSON.parse(JSON.stringify(bh.layers));
  // Assign remark from layers to spt if missing — depthFrom/depthTo 우선 사용
  STATE.sptData.forEach(s => {
    if (!s.remark || s.remark === "퇴적층(SM)") {
      let layer = null;
      // 1차: depthFrom/depthTo가 있는 경우
      layer = STATE.layers.find(l => l.depthFrom != null && l.depthTo != null && s.depth >= l.depthFrom && s.depth <= l.depthTo);
      // 2차: 누적 두께 기반
      if (!layer) {
        let cum = 0;
        layer = STATE.layers.find(l => { cum += l.thickness; return s.depth <= cum; });
      }
      if (layer) s.remark = layer.soilType;
    }
  });
  recalculate();
  showToast(`${bh.holeNo} 데이터 적용 완료`, 'success');
}

// Tab switching
document.querySelectorAll('.tab-btn').forEach(btn => {
  btn.addEventListener('click', () => {
    document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
    document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
    btn.classList.add('active');
    document.getElementById('tab-' + btn.dataset.tab).classList.add('active');
  });
});

// Toast system
function showToast(msg, type='info') {
  const c = document.getElementById('toastContainer');
  const t = document.createElement('div');
  t.className = 'toast ' + type;
  t.textContent = msg;
  c.appendChild(t);
  setTimeout(() => { t.style.opacity = '0'; t.style.transform = 'translateX(100%)'; t.style.transition = 'all .3s'; setTimeout(() => t.remove(), 300); }, 4000);
}

// Panel open/close
function openLogPanel() { document.getElementById('panelOverlay').classList.add('open'); setTimeout(() => document.getElementById('slidePanel').classList.add('open'), 10); }
function closeLogPanel() { document.getElementById('slidePanel').classList.remove('open'); setTimeout(() => document.getElementById('panelOverlay').classList.remove('open'), 300); }

// Modal open/close
function closeVerifyModal() { document.getElementById('verifyOverlay').classList.remove('open'); }

// Engineering Guide
const GUIDE_DATA = {
  alpha_kh: { title: 'alpha (Kh) - 수평지반반력계수 보정계수',
    def: '수평방향 지반반력계수 산정 시 적용하는 보정계수입니다. 지반조사 방법, 시험 조건, 현장 조건의 차이를 반영합니다.',
    range: '0.5 ~ 2.0 (일반적으로 1.0 적용)', sig: '값이 클수록 지반 수평 강성이 크다고 평가하며, 수평지지력이 증가합니다.',
    refs: ['도로교설계기준 (2008)', 'KDS 11 50 40 (2018)'] },
  delta_cm: { title: '허용변위 (cm) - 말뚝 두부 허용 수평변위',
    def: '말뚝 두부에 허용되는 최대 수평변위량입니다. Brom Case-1(변위 제어)에서 수평지지력을 결정하는 핵심 변수입니다.',
    range: '1.0 ~ 2.5 cm\n교량 기초: 1.0 ~ 1.5 cm\n건축 기초: 1.5 ~ 2.5 cm', sig: '허용변위가 작을수록 보수적인 설계이며, 수평지지력이 감소합니다.',
    refs: ['KDS 11 50 40 (2018)', '도로교설계기준 (2008)'] },
  sigmaMax: { title: '허용압축응력 / 항복응력 (kN/m²)',
    def: 'PHC 말뚝: 콘크리트 허용압축응력으로 Brom Case-2(항복 모멘트)에서 사용됩니다.\n강관 말뚝: 강재 항복응력으로 재료 허용지지력의 기반이 됩니다.',
    range: 'PHC A종: 20,000 kN/m² (fck=80MPa 기준)\nPHC B종: 40,000 kN/m²\nPHC C종: 50,000 kN/m²\n강관(SS400): 235,000 kN/m²',
    sig: 'Brom Case-2 수평지지력 및 재료 허용지지력 산정에 직접 영향합니다.', refs: ['KS F 4306 (PHC)', 'KS D 3515 (강관)', 'KDS 11 50 40'] },
  corrosion: { title: '부식두께 (mm) - 강관말뚝 부식 여유',
    def: '강관말뚝의 설계 수명(보통 50~100년) 동안 예상되는 부식 손실 두께입니다. 유효 단면적(At) 계산에 반영됩니다.',
    range: '일반 지반: 1 mm\n해수/간만대: 2 ~ 3 mm\n오염 지반: 2 ~ 4 mm', sig: '유효 단면적을 감소시켜 재료 허용지지력을 저하시킵니다.',
    refs: ['도로교설계기준 (2008)', 'KDS 11 50 40', 'AISC 360'] },
  qu_kPa: { title: 'qu (kPa) - 일축압축강도 (UCS)',
    def: '암반 코어 시편의 일축압축강도(Unconfined Compressive Strength)입니다. 암반근입 말뚝의 선단지지력을 산정하는 핵심 입력값입니다.',
    range: '풍화암: 1,000 ~ 10,000 kPa\n연암: 10,000 ~ 50,000 kPa\n경암: 50,000 ~ 200,000+ kPa',
    sig: '3가지 암반 선단지지력 공식(구조물기초설계기준, Goodman, Canadian FEM)에 모두 직접 사용됩니다.', refs: ['ASTM D2938', '도로교설계기준 (2008) p305, p862-863', 'ISRM (1979)'] },
  Sd_m: { title: 'Sd (m) - 불연속면 간격',
    def: '암반 내 불연속면(절리, 균열, 층리면 등)의 평균 간격입니다. Canadian FEM 공식의 Ksp 계수 산정에 사용됩니다.',
    range: '매우 조밀: < 0.06 m\n조밀: 0.06 ~ 0.2 m\n보통: 0.2 ~ 0.6 m\n넓음: 0.6 ~ 2.0 m',
    sig: 'Ksp = (3 + Sd/D) / (10√(1 + 300td/Sd))\n간격이 넓을수록 Ksp 증가 → 지지력 증가.', refs: ['ISRM (1978)', '도로교설계기준 (2008) p862'] },
  td_m: { title: 'td (m) - 불연속면 두께',
    def: '불연속면(절리면)의 평균 틈새 두께(aperture)입니다. 암반의 품질을 나타내는 지표로 Canadian FEM 공식에 사용됩니다.',
    range: '닫힘: < 0.001 m (1mm 미만)\n보통: 0.001 ~ 0.005 m\n열림: 0.005 ~ 0.01 m',
    sig: 'Ksp 계수에 영향: 두께가 클수록 Ksp 감소 → 지지력 감소.', refs: ['ISRM (1978)', '도로교설계기준 (2008) p862'] },
  rockPhi: { title: 'Rock Phi (deg) - 암반 내부마찰각',
    def: '암반의 내부마찰각(Rock Friction Angle)으로 Goodman 공식의 지지력 계수 Nphi를 결정합니다.\nNphi = tan²(45 + phi/2)',
    range: '풍화암: 25 ~ 35도\n연암: 30 ~ 40도\n경암: 35 ~ 45도', sig: 'Goodman 공식: Qu = qu x (Nphi + 1) x Ap. 마찰각 증가 → 지지력 크게 증가.',
    refs: ['Hoek & Brown (1997)', '도로교설계기준 (2008) p863', 'Goodman (1989)'] },
  gwlDepth: { title: '지하수위 (GL, m) - 지표면 기준 깊이',
    def: '지표면(GL)에서 지하수위면까지의 깊이입니다. 시추조사 시 측정됩니다.',
    range: '현장 측정값 적용\n일반적 범위: 1 ~ 10 m', sig: '인발 저항력의 말뚝 유효자중(Wp) 계산에 영향:\n수위 이하 구간은 부력 보정(γ\' = γ - γw).',
    refs: ['현장 지반조사 (시추 공내수위 측정)'] },
  fillN: { title: '성토재 N값 - 성토 재료의 SPT N값',
    def: '성토(Fill) 구간에 적용할 표준관입시험(SPT) N값입니다. 성토 다짐 상태와 재료 품질에 따라 결정합니다.',
    range: '느슨한 성토: 3 ~ 5\n보통 다짐 성토: 5 ~ 10\n양호한 다짐 성토: 10 ~ 15',
    sig: '성토 구간의 주면마찰력 산정에 직접 사용: fs = 2 x N x As (사질토 기준).', refs: ['도로설계편람 (2012)', 'KDS 11 50 40', '지반공학회 (1996)'] }
};
function showGuide(key) {
  const d = GUIDE_DATA[key]; if (!d) return;
  document.getElementById('guideTitle').textContent = d.title;
  document.getElementById('guideBody').innerHTML =
    '<div class="guide-def">' + d.def.replace(/\n/g, '<br>') + '</div>' +
    '<div class="guide-range"><strong>권장 범위:</strong><br><span style="font-family:var(--font-mono);font-size:11px;white-space:pre-line">' + d.range + '</span></div>' +
    (d.sig ? '<div class="guide-def"><strong>공학적 의미:</strong><br>' + d.sig.replace(/\n/g, '<br>') + '</div>' : '') +
    '<div class="guide-ref"><strong>참고문헌:</strong> ' + d.refs.join(' | ') + '</div>';
  document.getElementById('guideOverlay').classList.add('open');
}
function closeGuide() { document.getElementById('guideOverlay').classList.remove('open'); }

// ESC key handler
document.addEventListener('keydown', e => { if (e.key === 'Escape') { closeAIPanel(); closeChatPanel(); closeLogPanel(); closeVerifyModal(); closePasteModal(); closeGuide(); }});

// ===== AI INTEGRATION =====
let AI_API_KEY = localStorage.getItem('claude_api_key') || '';

// AI 결과 캐싱 시스템
const AI_CACHE = { review: null, borehole: null, report: null };
function aiCacheKey(data) {
  return JSON.stringify(data);
}
function invalidateAICache() {
  AI_CACHE.review = null;
  AI_CACHE.borehole = null;
  AI_CACHE.report = null;
}

function setAIApiKey(key) { AI_API_KEY = key; localStorage.setItem('claude_api_key', key); }
function ensureApiKey() {
  if (AI_API_KEY) return true;
  const key = prompt('Claude API Key를 입력하세요 (sk-ant-...):');
  if (key && key.startsWith('sk-ant-')) { setAIApiKey(key); return true; }
  showToast('유효한 API Key가 필요합니다', 'error'); return false;
}

async function callClaudeAPI({ systemPrompt, userMessage, onChunk, onComplete, onError, maxTokens=2048, temperature=0.3 }) {
  try {
    const resp = await fetch('https://api.anthropic.com/v1/messages', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'x-api-key': AI_API_KEY,
        'anthropic-version': '2023-06-01',
        'anthropic-dangerous-direct-browser-access': 'true'
      },
      body: JSON.stringify({
        model: 'claude-haiku-4-5-20251001',
        max_tokens: maxTokens,
        temperature: temperature,
        stream: true,
        system: systemPrompt,
        messages: [{ role: 'user', content: userMessage }]
      })
    });
    if (!resp.ok) {
      const errBody = await resp.text();
      const code = resp.status;
      if (code === 401) { onError({ message: 'API Key가 유효하지 않습니다', details: '설정에서 키를 확인하세요' }); return; }
      if (code === 429) { onError({ message: '요청 한도 초과 (Rate Limit)', details: '잠시 후 다시 시도하세요' }); return; }
      onError({ message: `API 오류 (${code})`, details: errBody.substring(0, 200) }); return;
    }
    const reader = resp.body.getReader();
    const decoder = new TextDecoder();
    let fullText = '', inputTokens = 0, outputTokens = 0, buffer = '';
    while (true) {
      const { done, value } = await reader.read();
      if (done) break;
      buffer += decoder.decode(value, { stream: true });
      const lines = buffer.split('\n');
      buffer = lines.pop() || '';
      for (const line of lines) {
        if (!line.startsWith('data: ')) continue;
        const data = line.slice(6).trim();
        if (data === '[DONE]') continue;
        try {
          const evt = JSON.parse(data);
          if (evt.type === 'message_start' && evt.message && evt.message.usage) {
            inputTokens = evt.message.usage.input_tokens || 0;
          }
          if (evt.type === 'content_block_delta' && evt.delta && evt.delta.text) {
            fullText += evt.delta.text;
            if (onChunk) onChunk(evt.delta.text);
          }
          if (evt.type === 'message_delta' && evt.usage) {
            outputTokens = evt.usage.output_tokens || 0;
          }
        } catch (pe) { /* skip parse error */ }
      }
    }
    if (onComplete) onComplete(fullText, { input_tokens: inputTokens, output_tokens: outputTokens });
  } catch (err) {
    if (onError) onError({ message: '네트워크 연결 실패', details: err.message });
  }
}

// AI Panel Management
function openAIPanel(title, meta) {
  document.getElementById('aiPanelTitle').textContent = title;
  document.getElementById('aiPanelMeta').innerHTML = meta || '';
  document.getElementById('aiContent').innerHTML = '';
  document.getElementById('aiTokenInfo').style.display = 'none';
  document.getElementById('aiPanelOverlay').classList.add('open');
  setTimeout(() => document.getElementById('aiSlidePanel').classList.add('open'), 10);
}
function closeAIPanel() {
  const p = document.getElementById('aiSlidePanel');
  if (p) p.classList.remove('open');
  setTimeout(() => { const o = document.getElementById('aiPanelOverlay'); if (o) o.classList.remove('open'); }, 300);
}
function showAILoading(msg) {
  document.getElementById('aiContent').innerHTML =
    `<div class="ai-loading"><div class="ai-spinner"></div>${msg || 'AI 분석 중...'}</div>`;
}
function showAITokenInfo(usage) {
  const el = document.getElementById('aiTokenInfo');
  const cost = ((usage.input_tokens / 1e6 * 3) + (usage.output_tokens / 1e6 * 15)).toFixed(4);
  el.innerHTML = `토큰: 입력 ${usage.input_tokens.toLocaleString()} · 출력 ${usage.output_tokens.toLocaleString()} · 비용 ~$${cost}`;
  el.style.display = 'block';
}
function renderAIMarkdown(text) {
  return text
    .replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;')
    .replace(/^#### (.+)$/gm, '<h4>$1</h4>')
    .replace(/^### (.+)$/gm, '<h3 style="font-size:13px">$1</h3>')
    .replace(/^## (.+)$/gm, '<h3>$1</h3>')
    .replace(/^# (.+)$/gm, '<h3 style="font-size:15px;border-bottom:2px solid var(--primary-navy)">$1</h3>')
    .replace(/^---+$/gm, '<hr style="border:none;border-top:1px solid #e2e8f0;margin:12px 0">')
    .replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>')
    .replace(/`([^`]+)`/g, '<code>$1</code>')
    .replace(/^> (.+)$/gm, '<blockquote>$1</blockquote>')
    .replace(/^(\d+)\. (.+)$/gm, '<div style="margin:2px 0;padding-left:16px"><strong>$1.</strong> $2</div>')
    .replace(/^- (.+)$/gm, '<div style="margin:2px 0;padding-left:16px">• $1</div>')
    .replace(/\n{2,}/g, '<br>')
    .replace(/\n/g, '<br>');
}

// ===== Feature B: AI 설계 검토 =====
function prepareReviewData() {
  const r = STATE.result; if (!r) return null;
  const isPHC = STATE.pileType === 'PHC';
  return {
    설계조건: {
      말뚝종류: isPHC ? `PHC ${STATE.phcGrade}종` : '강관',
      직경_mm: STATE.diameter_mm, 두께_mm: STATE.thickness_mm,
      말뚝길이_m: +r.pileLength.toFixed(2),
      지지방법: STATE.bearingMethod === 'rock' ? '암반지지' : '토사지지(Meyerhof)',
      시추공: STATE.boreholeNo,
      지반고_EL: STATE.groundEL, 지지층_EL: STATE.bearingEL,
      선단_EL: +r.tipEL.toFixed(2), 근입깊이_m: STATE.embedDepth,
      지하수위_GL: STATE.gwlDepth,
      성토적용: STATE.useFill, 계획고: STATE.plannedEL
    },
    계산결과: {
      허용수직지지력_kN: +r.Qa_applied.toFixed(1),
      재료지지력_kN: +r.Qp_material.toFixed(1),
      지반지지력_kN: +r.Qa_ground.toFixed(1),
      극한지지력_kN: +r.Qu.toFixed(1),
      선단지지력_kN: +r.Qu_tip.toFixed(1),
      주면마찰력_kN: +r.Qu_skin.toFixed(1),
      안전율: r.FS,
      허용수평지지력_kN: +r.Ha_applied.toFixed(1),
      인발저항력_kN: +r.Qpull.toFixed(1),
      침하량_mm: +r.St.toFixed(2),
      침하판정: r.St < 25 ? 'OK' : 'NG',
      세장비: +r.L_over_d.toFixed(1),
      말뚝분류: r.pileClass
    },
    지층현황: STATE.layers.map(l => ({
      지층: l.soilType, 두께_m: l.thickness, 평균N: l.avgN, 단위중량: l.unitWeight
    })),
    SPT요약: {
      데이터수: STATE.sptData.length,
      최소N: Math.min(...STATE.sptData.map(s => s.N)),
      최대N: Math.max(...STATE.sptData.map(s => s.N)),
      선단N: r.N_tip
    }
  };
}

async function runAIReview(forceRefresh) {
  if (!ensureApiKey()) return;
  if (!STATE.result) { showToast('계산 결과가 없습니다. 먼저 설계를 완료하세요.', 'warning'); return; }
  const data = prepareReviewData();
  const cacheKey = aiCacheKey(data);
  const meta = `<span class="pm-label">시추공: </span><span class="pm-value">${STATE.boreholeNo}</span>` +
    ` · <span class="pm-label">Qa=</span><span class="pm-value">${fmt(STATE.result.Qa_applied)}kN</span>`;
  // 캐시 히트: 이전 결과 즉시 표시
  if (!forceRefresh && AI_CACHE.review && AI_CACHE.review.key === cacheKey) {
    openAIPanel('AI 설계 검토', meta);
    document.getElementById('aiContent').innerHTML = renderAIMarkdown(AI_CACHE.review.text) +
      `<div style="margin-top:12px;padding-top:10px;border-top:1px solid #e2e8f0;display:flex;align-items:center;gap:8px">
        <span style="font-size:10px;color:#6b7280">&#128193; 캐시된 결과</span>
        <button class="btn btn-sm" onclick="runAIReview(true)" style="font-size:10px;padding:2px 8px">&#128260; 재분석</button>
      </div>`;
    showAITokenInfo(AI_CACHE.review.usage);
    return;
  }
  openAIPanel('AI 설계 검토', meta);
  showAILoading('설계 결과를 분석 중입니다...');
  let fullText = '';
  await callClaudeAPI({
    systemPrompt: `당신은 대한민국 지반공학 전문가입니다. 말뚝 기초 설계 결과를 검토합니다.
KDS 11 50 40 (2018), 도로교설계기준 (2008), 구조물기초설계기준해설을 적용합니다.
한국어로 답변하며, 마크다운 형식(###, **, -)을 사용합니다.
수치를 근거로 구체적이고 실무적인 검토 의견을 제시하세요.`,
    userMessage: `다음 말뚝 기초 설계 결과를 전문적으로 검토해주세요.

${JSON.stringify(data, null, 2)}

다음 항목을 각각 검토해주세요:
### 1. 안전율 적정성
수직/수평 지지력의 안전율, 지반 극한지지력 대비 허용지지력 비율

### 2. 말뚝 길이 적정성
지층 조건(N값 분포) 대비 말뚝 길이, 세장비, 근입깊이 적합성

### 3. 지지력 균형 분석
재료 지지력 vs 지반 지지력 비율, 선단 vs 주면마찰 분담 비율, 비효율 여부

### 4. 침하 검토
침하량 적정성, 각 성분(탄성침하/선단침하/주면침하) 비율

### 5. 설계 개선 제안
경제성/안전성 향상 방안 (규격 변경, 길이 조정, 등급 변경 등)

### 6. 위험 요소 및 주의사항
시공 시 유의사항, 잠재 위험, 추가 검토 필요 항목`,
    maxTokens: 2500,
    temperature: 0.3,
    onChunk: (text) => {
      fullText += text;
      document.getElementById('aiContent').innerHTML = renderAIMarkdown(fullText);
    },
    onComplete: (finalText, usage) => {
      AI_CACHE.review = { key: cacheKey, text: finalText, usage };
      document.getElementById('aiContent').innerHTML = renderAIMarkdown(finalText);
      showAITokenInfo(usage);
    },
    onError: (err) => {
      document.getElementById('aiContent').innerHTML =
        `<div style="color:var(--status-fail);font-weight:600;padding:20px">&#10060; ${err.message}</div>
         <div style="font-size:11px;color:var(--text-muted);padding:0 20px">${err.details || ''}</div>`;
    }
  });
}

// ===== Feature C: 자연어 입력 =====
let _lastNLParsed = null;

async function parseNLInput() {
  if (!ensureApiKey()) return;
  const inputEl = document.getElementById('nlInput');
  if (!inputEl) return;
  const input = inputEl.value.trim();
  if (!input) { showToast('입력이 비어있습니다', 'warning'); return; }
  const preview = document.getElementById('nlPreview');
  preview.style.display = 'block';
  preview.innerHTML = '<div class="ai-loading"><div class="ai-spinner"></div>파싱 중...</div>';
  let fullText = '';
  await callClaudeAPI({
    systemPrompt: `당신은 말뚝 기초 설계 입력 파서입니다. 사용자의 자연어 설명을 분석하여 설계 파라미터를 JSON으로 반환합니다.

현재 설계 상태:
- 말뚝: ${STATE.pileType} ${STATE.diameter_mm}mm ${STATE.pileType==='PHC'?STATE.phcGrade+'종':'t'+STATE.thickness_mm}
- 지지방법: ${STATE.bearingMethod==='rock'?'암반근입':'Meyerhof(토사)'}
- 말뚝두부 EL: ${STATE.pileTopEL} m
- 지반고 EL: ${STATE.groundEL} m
- 지지층 EL: ${STATE.bearingEL} m
- 근입깊이: ${STATE.embedDepth} m
- 지하수위: GL-${STATE.gwlDepth} m
- 성토/절토: ${STATE.useFill ? '적용 (계획고 EL '+STATE.plannedEL+' m)' : '미적용'}

반드시 다음 JSON 형식만 반환하세요 (설명 없이):
{
  "pileType": "PHC" 또는 "강관",
  "diameter_mm": 숫자,
  "thickness_mm": 숫자,
  "phcGrade": "A"/"B"/"C" (PHC인 경우만),
  "bearingMethod": "meyerhof" 또는 "rock",
  "pileTopEL": 숫자,
  "groundEL": 숫자,
  "bearingEL": 숫자,
  "gwlDepth": 숫자,
  "embedDepth": 숫자,
  "useFill": true/false,
  "plannedEL": 숫자,
  "fillN": 숫자,
  "actions": ["autoDetectBearing", "autoDetectBearingAll"]
}

규칙:
- 사용자가 언급하지 않은 필드는 포함하지 마세요
- 상대적 표현은 현재 상태 기반으로 계산하세요 (예: "지반고보다 5m 높게" → plannedEL = 현재 groundEL + 5)
- PHC 가용 직경: 350, 400, 450, 500, 600 mm (두께는 직경별 규격 참조)
- 강관 가용 직경: 406.4, 508.0, 609.6 mm
- "토사" = bearingMethod: "meyerhof", "암반/암지지" = bearingMethod: "rock"
- "계획고" 언급 = useFill: true + plannedEL 값
- "A종/B종/C종" → phcGrade에 반영
- "지지층 자동", "지지층 EL 자동", "자동 탐지", "자동 적용" → actions에 "autoDetectBearing" 추가
- "모든 시추공", "전체 시추공", "전부", "일괄" + 지지층 자동 → actions에 "autoDetectBearingAll" 추가
- actions 배열은 실행할 명령이 있을 때만 포함
- JSON만 반환. 다른 텍스트 없이.`,
    userMessage: input,
    maxTokens: 512,
    temperature: 0,
    onChunk: (text) => { fullText += text; },
    onComplete: (finalText) => {
      try {
        let jsonStr = finalText.trim();
        if (jsonStr.startsWith('```')) jsonStr = jsonStr.replace(/```json?\n?/g, '').replace(/```/g, '').trim();
        const parsed = JSON.parse(jsonStr);
        _lastNLParsed = parsed;
        showNLPreview(parsed, preview);
      } catch (e) {
        preview.innerHTML = '<div style="color:var(--status-fail);font-size:11px;padding:6px">파싱 실패: AI 응답을 해석할 수 없습니다. 더 구체적으로 입력해보세요.</div>';
      }
    },
    onError: (err) => {
      preview.innerHTML = `<div style="color:var(--status-fail);font-size:11px;padding:6px">오류: ${err.message}</div>`;
    }
  });
}

function showNLPreview(parsed, container) {
  const names = {
    pileType:'말뚝종류', diameter_mm:'직경(mm)', thickness_mm:'두께(mm)',
    phcGrade:'PHC등급', bearingMethod:'지지방법', pileTopEL:'말뚝두부EL',
    groundEL:'지반고EL', bearingEL:'지지층EL', gwlDepth:'지하수위(GL,m)',
    embedDepth:'근입깊이(m)', useFill:'성토적용', plannedEL:'계획고EL', fillN:'성토N값'
  };
  const actionNames = {
    autoDetectBearing: '지지층 EL 자동 탐지 (현재 시추공)',
    autoDetectBearingAll: '지지층 EL 자동 탐지 (모든 시추공)'
  };
  let html = '';
  // 설계 파라미터 표시
  const paramEntries = Object.entries(parsed).filter(([k]) => k !== 'actions');
  if (paramEntries.length > 0) {
    html += '<div style="font-size:11px;font-weight:600;color:#15803d;margin-bottom:6px">&#10003; 인식된 설계 조건:</div>';
    html += '<div style="display:flex;flex-wrap:wrap;gap:6px 14px;font-size:11px">';
    for (const [key, val] of paramEntries) {
      const label = names[key] || key;
      const cur = STATE[key];
      const changed = cur !== undefined && cur !== val;
      html += `<span style="${changed ? 'color:#dc2626;font-weight:600' : ''}">${label}: <strong>${val}</strong>${changed ? ' (\u2190'+cur+')' : ''}</span>`;
    }
    html += '</div>';
  }
  // 액션 표시
  if (parsed.actions && parsed.actions.length > 0) {
    html += '<div style="font-size:11px;font-weight:600;color:#7c3aed;margin:6px 0 4px">&#9889; 실행할 명령:</div>';
    html += '<div style="display:flex;flex-wrap:wrap;gap:4px;font-size:11px">';
    parsed.actions.forEach(a => {
      html += `<span style="background:#ede9fe;color:#6d28d9;padding:2px 8px;border-radius:10px;font-weight:600">${actionNames[a] || a}</span>`;
    });
    html += '</div>';
  }
  if (paramEntries.length === 0 && (!parsed.actions || parsed.actions.length === 0)) {
    html += '<div style="font-size:11px;color:var(--text-muted)">인식된 변경사항이 없습니다.</div>';
  }
  html += `<div style="margin-top:8px;display:flex;gap:6px">
    <button class="btn btn-sm" style="background:#4338ca;color:#fff" onclick="applyNLParsed()">적용</button>
    <button class="btn btn-sm" style="background:#e2e8f0" onclick="document.getElementById('nlPreview').style.display='none'">취소</button>
  </div>`;
  container.innerHTML = html;
}

function applyNLParsed() {
  if (!_lastNLParsed) return;
  const p = _lastNLParsed;
  // 1. 설계 파라미터 적용
  const map = ['pileType','diameter_mm','thickness_mm','phcGrade','bearingMethod',
    'pileTopEL','groundEL','bearingEL','gwlDepth','embedDepth','useFill','plannedEL','fillN'];
  map.forEach(k => { if (p[k] !== undefined) STATE[k] = p[k]; });
  if (p.pileType === 'PHC' && p.phcGrade) {
    STATE.sigmaMax = { A:20000, B:40000, C:50000 }[p.phcGrade] || 20000;
  } else if (p.pileType === '\uAC15\uAD00') { STATE.sigmaMax = 235000; }
  recalculate();
  // 2. 액션 실행
  if (p.actions && p.actions.length > 0) {
    p.actions.forEach(action => {
      if (action === 'autoDetectBearingAll') {
        autoDetectBearingAllBoreholes();
      } else if (action === 'autoDetectBearing') {
        autoDetectBearingLayer();
      }
    });
  }
  showToast('AI \uC790\uC5F0\uC5B4 \uC785\uB825\uC774 \uC801\uC6A9\uB418\uC5C8\uC2B5\uB2C8\uB2E4', 'success');
  document.getElementById('nlPreview').style.display = 'none';
}

function autoDetectBearingAllBoreholes() {
  if (!STATE.uploadedData || STATE.uploadedData.length === 0) {
    // 단일 시추공: 현재 시추공에만 적용
    autoDetectBearingLayer();
    return;
  }
  const method = STATE.bearingMethod || (STATE.pileType === 'PHC' ? 'meyerhof' : 'rock');
  let applied = 0, failed = 0;
  const origIdx = STATE.currentBhIdx;
  const origBhNo = STATE.boreholeNo;

  STATE.uploadedData.forEach((bh, idx) => {
    // 각 시추공의 데이터로 임시 전환
    const sptData = bh.sptData || [];
    const layers = bh.layers || [];
    const groundEL = bh.groundEL || STATE.groundEL;
    let detected = false;
    let bearingEL = null;

    if (method === 'rock') {
      // SPT remark에서 암반 탐색
      for (let i = 0; i < sptData.length; i++) {
        let remark = sptData[i].remark || '';
        // remark가 없으면 layers에서 매칭
        if (!remark || remark === '') {
          let cum = 0;
          const layer = layers.find(l => {
            const dFrom = l.depthFrom != null ? l.depthFrom : cum;
            cum = dFrom + l.thickness;
            return sptData[i].depth >= dFrom && sptData[i].depth <= cum;
          });
          if (layer) remark = layer.soilType || '';
        }
        if (remark.includes('\uD48D\uD654\uC554') || remark.includes('\uC5F0\uC554') || remark.includes('\uACBD\uC554') || remark.includes('WR') || remark.includes('SR') || remark.includes('HR')) {
          bearingEL = parseFloat((groundEL - sptData[i].depth + 1).toFixed(2));
          detected = true; break;
        }
      }
      // 지층에서 암반 탐색
      if (!detected && layers.length > 0) {
        let cumDepth = 0;
        for (let i = 0; i < layers.length; i++) {
          const lt = layers[i].soilType || '';
          const dFrom = layers[i].depthFrom != null ? layers[i].depthFrom : cumDepth;
          cumDepth = dFrom + layers[i].thickness;
          if (lt.includes('\uD48D\uD654\uC554') || lt.includes('\uC5F0\uC554') || lt.includes('\uACBD\uC554') || lt.includes('WR') || lt.includes('SR') || lt.includes('HR')) {
            bearingEL = parseFloat((groundEL - dFrom).toFixed(2));
            detected = true; break;
          }
        }
      }
    } else {
      // 토사: N≥50 연속 2개
      for (let i = 0; i < sptData.length - 1; i++) {
        if (sptData[i].N >= 50 && sptData[i + 1].N >= 50) {
          bearingEL = parseFloat((groundEL - sptData[i].depth + 1).toFixed(2));
          detected = true; break;
        }
      }
      // 지층 N≥50
      if (!detected && layers.length > 0) {
        let cumDepth = 0;
        for (let i = 0; i < layers.length; i++) {
          const dFrom = layers[i].depthFrom != null ? layers[i].depthFrom : cumDepth;
          cumDepth = dFrom + layers[i].thickness;
          if (layers[i].avgN >= 50) {
            bearingEL = parseFloat((groundEL - dFrom).toFixed(2));
            detected = true; break;
          }
        }
      }
    }

    if (detected && bearingEL != null) {
      // 유효성: bearingEL이 pileTopEL보다 낮아야 말뚝 길이가 양수
      const tipEL = bearingEL - (STATE.embedDepth || 1);
      if (tipEL < STATE.pileTopEL) {
        bh.bearingEL = bearingEL;
        applied++;
      } else {
        failed++; // 지지층이 말뚝두부보다 높음 → 무효
      }
    } else {
      failed++;
    }
  });

  // 현재 시추공의 bearingEL도 업데이트
  const curBh = STATE.uploadedData[origIdx];
  if (curBh && curBh.bearingEL != null) {
    STATE.bearingEL = curBh.bearingEL;
  }
  recalculate();

  if (applied > 0) {
    showToast('\uC9C0\uC9C0\uCE35 EL \uC790\uB3D9 \uD0D0\uC9C0: ' + applied + '\uAC1C \uC131\uACF5' + (failed > 0 ? ', ' + failed + '\uAC1C \uC2E4\uD328' : '') + ' (' + method + ')', 'success');
  } else {
    showToast('\uC9C0\uC9C0\uCE35\uC744 \uCC3E\uC744 \uC218 \uC5C6\uC2B5\uB2C8\uB2E4', 'warning');
  }
}

// ===== Feature A: 시추공 분석 =====
function prepareBoreholeData() {
  if (!STATE.uploadedData || STATE.uploadedData.length === 0) return null;
  calcAllBoreholes();
  return STATE.uploadedData.map(bh => {
    const r = BH_RESULTS[bh.holeNo];
    return {
      시추공: bh.holeNo,
      지반고: bh.groundEL, 지하수위_GL: bh.gwlDepth,
      지층: (bh.layers || []).map(l => ({
        지층: l.soilType, 두께: l.thickness, 심도: `${l.depthFrom}~${l.depthTo}m`, N: l.avgN
      })),
      SPT: (bh.sptData || []).slice(0, 12).map(s => ({ 심도: s.depth, N: s.N })),
      결과: r ? {
        Qa_kN: +r.Qa_applied.toFixed(0), Ha_kN: +r.Ha_applied.toFixed(0),
        침하_mm: +r.St.toFixed(1), 말뚝길이_m: +r.pileLength.toFixed(1),
        판정: r.St < 25 ? 'OK' : 'NG'
      } : null
    };
  });
}

async function runBoreholeAnalysis(forceRefresh) {
  if (!ensureApiKey()) return;
  if (!STATE.uploadedData || STATE.uploadedData.length === 0) {
    showToast('시추공 데이터를 먼저 업로드하세요 (JSON)', 'warning'); return;
  }
  const n = STATE.uploadedData.length;
  const data = prepareBoreholeData();
  const cacheKey = aiCacheKey({ boreholes: n, method: STATE.bearingMethod, pile: STATE.pileType, d: STATE.diameter_mm });
  // 캐시 히트
  if (!forceRefresh && AI_CACHE.borehole && AI_CACHE.borehole.key === cacheKey) {
    openAIPanel('AI 시추공 분석', `<span class="pm-label">시추공 수: </span><span class="pm-value">${n}개</span>`);
    document.getElementById('aiContent').innerHTML = renderAIMarkdown(AI_CACHE.borehole.text) +
      `<div style="margin-top:12px;padding-top:10px;border-top:1px solid #e2e8f0;display:flex;align-items:center;gap:8px">
        <span style="font-size:10px;color:#6b7280">&#128193; 캐시된 결과</span>
        <button class="btn btn-sm" onclick="runBoreholeAnalysis(true)" style="font-size:10px;padding:2px 8px">&#128260; 재분석</button>
      </div>`;
    showAITokenInfo(AI_CACHE.borehole.usage);
    return;
  }
  openAIPanel('AI 시추공 분석', `<span class="pm-label">시추공 수: </span><span class="pm-value">${n}개</span>`);
  showAILoading(`${n}개 시추공 데이터를 분석 중...`);
  let fullText = '';
  await callClaudeAPI({
    systemPrompt: `당신은 대한민국 지반조사 분석 전문가입니다.
다수의 시추공 SPT 데이터를 비교 분석하여 지반 특성을 평가합니다.
마크다운 형식(###, **, -)으로 한국어 기술 분석 결과를 작성합니다.
수치 데이터를 근거로 구체적인 분석을 제공하세요.`,
    userMessage: `다음 ${data.length}개 시추공 데이터를 종합 분석해주세요.

${JSON.stringify(data, null, 2)}

현재 설계 조건: ${STATE.pileType} ${STATE.diameter_mm}mm, ${STATE.bearingMethod === 'rock' ? '암반지지' : '토사지지'}

다음 항목을 분석해주세요:
### 1. SPT N값 경향 분석
각 시추공별 깊이에 따른 N값 변화 패턴, 전체적 경향

### 2. 취약 구간 식별
N값이 낮은 연약 지반 구간 (N<10), 급격한 N값 변화 구간

### 3. 지지층 분석
시추공별 지지층(N≥50) 심도 비교, 적정 지지층 EL 제안

### 4. 지하수위 영향
지하수위가 설계에 미치는 영향, 부력/유효응력 고려사항

### 5. 시추공 간 비교
지반 조건의 공간적 변동성, 최약/최강 시추공 식별, 허용지지력 분포

### 6. 최적 설계 제안
시추공별 최적 말뚝 길이/규격, 경제성 고려한 추천

### 7. 위험 요소 및 시공 주의사항`,
    maxTokens: 3000,
    temperature: 0.3,
    onChunk: (text) => {
      fullText += text;
      document.getElementById('aiContent').innerHTML = renderAIMarkdown(fullText);
      document.getElementById('aiPanelBody').scrollTop = document.getElementById('aiPanelBody').scrollHeight;
    },
    onComplete: (finalText, usage) => {
      AI_CACHE.borehole = { key: cacheKey, text: finalText, usage };
      document.getElementById('aiContent').innerHTML = renderAIMarkdown(finalText);
      showAITokenInfo(usage);
    },
    onError: (err) => {
      document.getElementById('aiContent').innerHTML =
        `<div style="color:var(--status-fail);font-weight:600;padding:20px">&#10060; ${err.message}</div>`;
    }
  });
}

// ===== Feature D: 보고서 생성 =====
let _lastAIReport = '';

function prepareReportData() {
  const r = STATE.result; if (!r) return null;
  const base = prepareReviewData();
  base.주면마찰상세 = r.processedLayers.map(pl => ({
    지층: pl.soilType, 두께: +pl.thickness.toFixed(2), 분류: pl.soilClass,
    마찰력_kN: +((pl.skinFriction_sand||0)+(pl.skinFriction_clay||0)).toFixed(1)
  }));
  base.수평지지력 = {
    N_kh: r.N_kh, Kh_min: +r.Kh_min.toFixed(1),
    beta: +r.beta.toFixed(6), 말뚝분류: r.pileClass,
    Ha_brom: +r.Ha_brom.toFixed(1), Ha_chang: +r.Ha_chang.toFixed(1),
    Ha_적용: +r.Ha_applied.toFixed(1)
  };
  base.침하상세 = {
    탄성침하_mm: +r.Ss.toFixed(3), 선단침하_mm: +r.Sp.toFixed(3),
    주면침하_mm: +r.Sps.toFixed(3), 총침하_mm: +r.St.toFixed(2)
  };
  if (r.rockCalcDetails) {
    base.암반상세 = {
      일축압축강도_kPa: r.rockCalcDetails.qu_lab,
      선단극한_kN: +r.rockCalcDetails.Pu_tip.toFixed(1),
      Goodman_kN: +r.rockCalcDetails.Pu_goodman.toFixed(1),
      Canadian_kN: +r.rockCalcDetails.Pu_canadian.toFixed(1)
    };
  }
  return base;
}

async function generateAIReport(forceRefresh) {
  if (!ensureApiKey()) return;
  if (!STATE.result) { showToast('계산 결과가 없습니다', 'warning'); return; }
  const data = prepareReportData();
  const cacheKey = aiCacheKey(data);
  // 캐시 히트
  if (!forceRefresh && AI_CACHE.report && AI_CACHE.report.key === cacheKey) {
    openAIPanel('AI 보고서 생성', `<span class="pm-label">시추공: </span><span class="pm-value">${STATE.boreholeNo}</span>`);
    _lastAIReport = AI_CACHE.report.text;
    document.getElementById('aiContent').innerHTML = renderAIMarkdown(AI_CACHE.report.text) +
      `<div style="margin-top:16px;padding-top:12px;border-top:1px solid #e2e8f0;display:flex;align-items:center;gap:8px">
        <button class="btn btn-sm" onclick="copyAIReport()" style="background:#4338ca;color:#fff">&#128203; 클립보드 복사</button>
        <span style="font-size:10px;color:#6b7280">&#128193; 캐시된 결과</span>
        <button class="btn btn-sm" onclick="generateAIReport(true)" style="font-size:10px;padding:2px 8px">&#128260; 재생성</button>
      </div>`;
    showAITokenInfo(AI_CACHE.report.usage);
    return;
  }
  openAIPanel('AI 보고서 생성', `<span class="pm-label">시추공: </span><span class="pm-value">${STATE.boreholeNo}</span>`);
  showAILoading('기술 보고서를 생성 중...');
  let fullText = '';
  await callClaudeAPI({
    systemPrompt: `당신은 대한민국 지반공학 기술보고서 작성 전문가입니다.
말뚝 기초 설계 결과를 바탕으로 전문적인 기술 보고서를 작성합니다.
KDS 11 50 40, 구조물기초설계기준해설, 도로교설계기준 등 한국 기준을 인용합니다.
마크다운 형식(###, **, -)으로 격식있는 기술 문서를 작성합니다.
계산 수치를 근거로 구체적인 내용을 작성하세요.`,
    userMessage: `다음 설계 데이터를 바탕으로 말뚝 기초 설계 기술 보고서를 작성해주세요.

${JSON.stringify(data, null, 2)}

보고서 구성:
### 1. 개요
프로젝트 개요, 적용 기준 및 참고 문헌

### 2. 지반 조건
시추조사 결과 요약, 지층 구성 및 특성, 지하수위

### 3. 설계 조건
말뚝 제원 및 재료 특성, 안전율 기준

### 4. 수직 지지력 검토
재료 허용지지력, 지반 허용지지력(선단+주면), 최종 허용지지력 결정

### 5. 수평 지지력 검토
지반반력계수, Brom/Chang 방법 비교, 허용수평지지력

### 6. 인발 저항력 및 침하량 검토

### 7. 종합 평가 및 결론
설계 적정성 종합 판단, 시공 시 유의사항, 추가 검토 권고사항

전문적이고 격식있는 한국어 기술보고서 스타일로 작성하세요.`,
    maxTokens: 4096,
    temperature: 0.4,
    onChunk: (text) => {
      fullText += text;
      document.getElementById('aiContent').innerHTML = renderAIMarkdown(fullText);
      document.getElementById('aiPanelBody').scrollTop = document.getElementById('aiPanelBody').scrollHeight;
    },
    onComplete: (finalText, usage) => {
      AI_CACHE.report = { key: cacheKey, text: finalText, usage };
      _lastAIReport = finalText;
      document.getElementById('aiContent').innerHTML = renderAIMarkdown(finalText) +
        `<div style="margin-top:16px;padding-top:12px;border-top:1px solid #e2e8f0;display:flex;gap:8px">
          <button class="btn btn-sm" onclick="copyAIReport()" style="background:#4338ca;color:#fff">&#128203; 클립보드 복사</button>
        </div>`;
      showAITokenInfo(usage);
    },
    onError: (err) => {
      document.getElementById('aiContent').innerHTML =
        `<div style="color:var(--status-fail);font-weight:600;padding:20px">&#10060; ${err.message}</div>`;
    }
  });
}
function copyAIReport() {
  if (_lastAIReport) navigator.clipboard.writeText(_lastAIReport).then(() => showToast('보고서가 클립보드에 복사되었습니다', 'success'));
}

// ===== AI CHAT =====
let CHAT_HISTORY = []; // {role:'user'|'assistant', content:string}
let CHAT_STREAMING = false;
let CHAT_ABORT = null; // AbortController

const CHAT_SYSTEM_PROMPT = `당신은 전세계 최고 수준의 지반공학 및 기초공학 전문가(Geotechnical & Foundation Engineering Expert)입니다.

## 전문 분야
- 말뚝 기초 설계 (PHC, 강관, 현장타설말뚝)
- 지반조사 해석 (SPT, CPT, 시추조사)
- 지지력 산정 (Meyerhof, Terzaghi, 암반 지지)
- 수평지지력 (Chang, Broms)
- 침하 해석 (탄성침하, 압밀침하)
- 인발 저항력 및 부마찰력
- 한국 설계기준: KDS 11 50 40, 도로교설계기준(한계상태설계법), 구조물기초설계기준
- 국제 기준: AASHTO, Eurocode 7, API RP 2GEO, FHWA

## 답변 원칙
1. **구체적 근거**: 모든 판단에 설계기준 조항, 이론적 배경, 경험적 공식을 명시합니다.
2. **사례 기반**: 유사 현장 사례, 실무 경험, 문헌 자료를 활용하여 설명합니다.
3. **정량적 분석**: 가능한 한 수치적 검토와 계산식을 포함합니다.
4. **위험 요소 경고**: 설계/시공상 주의사항과 잠재적 문제를 사전에 경고합니다.
5. **실무 관점**: 이론뿐 아니라 시공성, 경제성, 품질관리 측면도 함께 고려합니다.
6. **한국어로 답변**: 전문 용어는 한국어(영어 병기) 형태로 작성합니다.

## 주어진 데이터
사용자의 시추공 데이터와 말뚝 기초 설계 계산 결과가 컨텍스트로 제공됩니다.
이 데이터를 기반으로 구체적이고 전문적인 답변을 제공하세요.
추가 데이터나 가정이 필요한 경우 명확히 언급하세요.`;

let CHAT_SCOPE = 'current'; // 'current' | 'all'

function toggleChatScope() {
  CHAT_SCOPE = CHAT_SCOPE === 'current' ? 'all' : 'current';
  const btn = document.getElementById('chatScopeBtn');
  if (btn) {
    btn.textContent = CHAT_SCOPE === 'current' ? '현재 시추공' : '전체 시추공';
    btn.style.background = CHAT_SCOPE === 'all' ? '#dbeafe' : '#eef2ff';
    btn.style.borderColor = CHAT_SCOPE === 'all' ? '#93c5fd' : '#c7d2fe';
  }
  updateChatContextBadge();
}

function prepareChatContext() {
  let ctx = '';
  const isAll = CHAT_SCOPE === 'all' && STATE.uploadedData && STATE.uploadedData.length > 1;

  // 설계 조건 (공통)
  ctx += '## 설계 조건\\n';
  ctx += '말뚝종류: ' + (STATE.pileType === 'PHC' ? 'PHC ' + STATE.phcGrade + '종' : '강관') + '\\n';
  ctx += '직경: ' + STATE.diameter_mm + 'mm, 두께: ' + STATE.thickness_mm + 'mm\\n';
  ctx += '지지방법: ' + (STATE.bearingMethod === 'rock' ? '암반지지' : '토사지지(Meyerhof)') + '\\n';
  ctx += '근입깊이: ' + STATE.embedDepth + 'm\\n';
  if (STATE.useFill && STATE.plannedEL) {
    const diff = STATE.plannedEL - STATE.groundEL;
    ctx += '계획고 EL: ' + STATE.plannedEL + 'm (' + (diff > 0 ? '성토 ' + diff.toFixed(2) + 'm' : '절토 ' + Math.abs(diff).toFixed(2) + 'm') + ')\\n';
  }

  if (isAll) {
    // 전체 시추공 모드
    calcAllBoreholes();
    ctx += '\\n## 전체 시추공 데이터 (' + STATE.uploadedData.length + '공)\\n';
    STATE.uploadedData.forEach(bh => {
      const br = BH_RESULTS[bh.holeNo];
      ctx += '### ' + bh.holeNo + ' (지반고 EL ' + (bh.groundEL||'-') + 'm)\\n';
      if (bh.layers && bh.layers.length > 0) {
        bh.layers.forEach(l => { ctx += '  ' + l.soilType + ' ' + l.thickness + 'm (N=' + l.avgN + ')\\n'; });
      }
      if (br) {
        ctx += '  → Qa=' + br.Qa_applied.toFixed(0) + 'kN, Ha=' + br.Ha_applied.toFixed(0) + 'kN, 침하=' + br.St.toFixed(1) + 'mm, 길이=' + br.pileLength.toFixed(1) + 'm\\n';
      }
    });
  } else {
    // 현재 시추공 모드
    if (STATE.layers && STATE.layers.length > 0) {
      ctx += '\\n## 현재 시추공: ' + STATE.boreholeNo + '\\n';
      ctx += '지반고 EL: ' + STATE.groundEL + 'm, 지하수위: GL-' + STATE.gwlDepth + 'm, 지지층 EL: ' + STATE.bearingEL + 'm\\n';
      ctx += '### 지층 현황\\n';
      STATE.layers.forEach((l, i) => {
        ctx += (i+1) + '. ' + l.soilType + ' (두께 ' + l.thickness + 'm, 평균N=' + l.avgN + ', γ=' + l.unitWeight + 'kN/m³)\\n';
      });
      if (STATE.sptData && STATE.sptData.length > 0) {
        ctx += '### SPT 프로파일\\n';
        STATE.sptData.forEach(s => { ctx += '  GL-' + s.depth + 'm: N=' + s.N + '\\n'; });
      }
    }
    if (STATE.result) {
      const r = STATE.result;
      ctx += '\\n## 계산 결과\\n';
      ctx += '말뚝길이: ' + r.pileLength.toFixed(2) + 'm\\n';
      ctx += '허용 수직지지력 Qa: ' + r.Qa_applied.toFixed(1) + ' kN\\n';
      ctx += '  - 극한지지력 Qu: ' + r.Qu.toFixed(1) + ' kN (선단 ' + r.Qu_tip.toFixed(1) + ' + 주면 ' + r.Qu_skin.toFixed(1) + ')\\n';
      ctx += '  - 재료지지력: ' + r.Qp_material.toFixed(1) + ' kN\\n';
      ctx += '  - 안전율 FS: ' + r.FS + '\\n';
      ctx += '허용 수평지지력 Ha: ' + r.Ha_applied.toFixed(1) + ' kN\\n';
      ctx += '인발저항력: ' + r.Qpull.toFixed(1) + ' kN\\n';
      ctx += '침하량: ' + r.St.toFixed(2) + ' mm (' + (r.St < 25 ? 'OK' : 'NG') + ')\\n';
      ctx += '세장비 L/D: ' + r.L_over_d.toFixed(1) + ' (' + r.pileClass + ')\\n';
    }
    // 다수 시추공 요약 (현재 모드에서도 간단 요약)
    if (STATE.uploadedData && STATE.uploadedData.length > 1 && typeof BH_RESULTS !== 'undefined') {
      ctx += '\\n## 전체 시추공 요약 (' + STATE.uploadedData.length + '공)\\n';
      STATE.uploadedData.forEach(bh => {
        const br = BH_RESULTS[bh.holeNo];
        if (br) ctx += bh.holeNo + ': Qa=' + br.Qa_applied.toFixed(0) + 'kN, 침하=' + br.St.toFixed(1) + 'mm, 길이=' + br.pileLength.toFixed(1) + 'm\\n';
      });
    }
  }
  return ctx;
}

function openChatPanel() {
  const overlay = document.getElementById('chatOverlay');
  const panel = document.getElementById('chatPanel');
  overlay.classList.add('open');
  setTimeout(() => panel.classList.add('open'), 10);
  // 컨텍스트 뱃지 업데이트
  updateChatContextBadge();
  // 첫 대화인 경우 초기 메시지
  if (CHAT_HISTORY.length === 0) {
    renderChatMessages();
  }
  setTimeout(() => document.getElementById('chatInput').focus(), 300);
}
function closeChatPanel() {
  const panel = document.getElementById('chatPanel');
  if (panel) panel.classList.remove('open');
  setTimeout(() => {
    const overlay = document.getElementById('chatOverlay');
    if (overlay) overlay.classList.remove('open');
  }, 300);
}
function updateChatContextBadge() {
  const badge = document.getElementById('chatBadge');
  const info = document.getElementById('chatContextInfo');
  const hasLayers = STATE.layers && STATE.layers.length > 0;
  const hasResult = !!STATE.result;
  const bhCount = STATE.uploadedData ? STATE.uploadedData.length : (hasLayers ? 1 : 0);
  const isAll = CHAT_SCOPE === 'all' && bhCount > 1;
  if (hasLayers || hasResult) {
    const parts = [];
    if (isAll) {
      parts.push('<span style="background:#dbeafe;color:#1d4ed8">전체 ' + bhCount + '공</span>');
    } else {
      parts.push('<span>' + STATE.boreholeNo + '</span>');
      if (hasResult) parts.push('<span>Qa=' + STATE.result.Qa_applied.toFixed(0) + 'kN</span>');
    }
    badge.innerHTML = '컨텍스트: ' + parts.join(' ');
    info.textContent = isAll ? '전체 ' + bhCount + '개 시추공' : STATE.boreholeNo + ' · ' + (hasResult ? '계산완료' : '데이터로드');
  } else {
    badge.innerHTML = '컨텍스트: <span style="background:#fee2e2;color:#dc2626">데이터 없음</span>';
    info.textContent = '컨텍스트 없음';
  }
}

function renderChatMessages() {
  const container = document.getElementById('chatMessages');
  let html = '<div class="chat-msg system">AI 지반공학 전문가와 대화를 시작하세요. 시추공 데이터와 계산 결과가 자동으로 제공됩니다.</div>';
  CHAT_HISTORY.forEach(msg => {
    if (msg.role === 'user') {
      html += '<div class="chat-msg user">' + escapeHtml(msg.content) + '</div>';
    } else {
      html += '<div class="chat-msg assistant">' + renderAIMarkdown(msg.content) + '</div>';
    }
  });
  container.innerHTML = html;
  container.scrollTop = container.scrollHeight;
}
function escapeHtml(t) {
  return t.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/\n/g,'<br>');
}

function clearChatHistory() {
  if (CHAT_STREAMING) { showToast('응답 생성 중에는 초기화할 수 없습니다', 'warning'); return; }
  CHAT_HISTORY = [];
  renderChatMessages();
  showToast('대화가 초기화되었습니다', 'info');
}

function handleChatKeydown(e) {
  if (e.key === 'Enter' && !e.shiftKey) {
    e.preventDefault();
    sendChatMessage();
  }
}
function autoResizeChatInput(el) {
  el.style.height = 'auto';
  el.style.height = Math.min(el.scrollHeight, 120) + 'px';
}

async function sendChatMessage() {
  if (CHAT_STREAMING) return;
  const input = document.getElementById('chatInput');
  const text = input.value.trim();
  if (!text) return;
  if (!ensureApiKey()) return;

  // 사용자 메시지 추가
  CHAT_HISTORY.push({ role: 'user', content: text });
  input.value = '';
  input.style.height = 'auto';
  renderChatMessages();

  // 타이핑 인디케이터
  const container = document.getElementById('chatMessages');
  const typing = document.createElement('div');
  typing.className = 'chat-typing';
  typing.id = 'chatTyping';
  typing.innerHTML = '<span></span><span></span><span></span>';
  container.appendChild(typing);
  container.scrollTop = container.scrollHeight;

  // 전송 버튼 비활성화
  CHAT_STREAMING = true;
  document.getElementById('chatSendBtn').disabled = true;

  // 컨텍스트 포함 시스템 프롬프트 구성
  const context = prepareChatContext();
  const fullSystem = CHAT_SYSTEM_PROMPT + (context ? '\\n\\n---\\n# 현재 프로젝트 데이터\\n' + context : '');

  // API 메시지 배열 구성 (전체 대화 히스토리)
  const apiMessages = CHAT_HISTORY.map(m => ({ role: m.role, content: m.content }));

  let fullText = '';
  try {
    const resp = await fetch('https://api.anthropic.com/v1/messages', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'x-api-key': AI_API_KEY,
        'anthropic-version': '2023-06-01',
        'anthropic-dangerous-direct-browser-access': 'true'
      },
      body: JSON.stringify({
        model: 'claude-haiku-4-5-20251001',
        max_tokens: 2048,
        temperature: 0.4,
        stream: true,
        system: fullSystem,
        messages: apiMessages
      })
    });
    if (!resp.ok) {
      const code = resp.status;
      const errBody = await resp.text();
      let errMsg = 'API 오류 (' + code + ')';
      if (code === 401) errMsg = 'API Key가 유효하지 않습니다';
      if (code === 429) errMsg = '요청 한도 초과. 잠시 후 다시 시도하세요';
      throw new Error(errMsg);
    }
    // 타이핑 제거, 어시스턴트 메시지 박스 추가
    const typingEl = document.getElementById('chatTyping');
    if (typingEl) typingEl.remove();
    const assistantDiv = document.createElement('div');
    assistantDiv.className = 'chat-msg assistant';
    container.appendChild(assistantDiv);

    const reader = resp.body.getReader();
    const decoder = new TextDecoder();
    let buffer = '';
    while (true) {
      const { done, value } = await reader.read();
      if (done) break;
      buffer += decoder.decode(value, { stream: true });
      const lines = buffer.split('\n');
      buffer = lines.pop() || '';
      for (const line of lines) {
        if (!line.startsWith('data: ')) continue;
        const data = line.slice(6).trim();
        if (data === '[DONE]') continue;
        try {
          const evt = JSON.parse(data);
          if (evt.type === 'content_block_delta' && evt.delta && evt.delta.text) {
            fullText += evt.delta.text;
            assistantDiv.innerHTML = renderAIMarkdown(fullText);
            container.scrollTop = container.scrollHeight;
          }
        } catch (pe) {}
      }
    }
    // 히스토리에 추가
    CHAT_HISTORY.push({ role: 'assistant', content: fullText });
  } catch (err) {
    const typingEl = document.getElementById('chatTyping');
    if (typingEl) typingEl.remove();
    // 에러 메시지 표시
    const errDiv = document.createElement('div');
    errDiv.className = 'chat-msg system';
    errDiv.style.background = '#fef2f2';
    errDiv.style.color = '#dc2626';
    errDiv.textContent = err.message;
    container.appendChild(errDiv);
    // 실패한 사용자 메시지 제거
    CHAT_HISTORY.pop();
  } finally {
    CHAT_STREAMING = false;
    document.getElementById('chatSendBtn').disabled = false;
    container.scrollTop = container.scrollHeight;
  }
}

// ===== SIDEBAR =====
function toggleSidebar() {
  const sb = document.getElementById('sidebar');
  const tog = document.getElementById('sidebarToggle');
  sb.classList.toggle('collapsed');
  tog.innerHTML = sb.classList.contains('collapsed') ? '&#9654;' : '&#9654;';
}

// ===== 시추공 정렬 =====
STATE.bhSortOrder = 'asc'; // 'asc' | 'desc' | 'original'

function naturalCompare(a, b) {
  const re = /(\d+)/g;
  const aParts = a.replace(re, m => m.padStart(20, '0'));
  const bParts = b.replace(re, m => m.padStart(20, '0'));
  return aParts.localeCompare(bParts);
}

function sortBoreholes(order) {
  if (!STATE.uploadedData || STATE.uploadedData.length <= 1) return;
  STATE.bhSortOrder = order;
  const curHole = STATE.boreholeNo;
  if (order === 'asc') {
    STATE.uploadedData.sort((a, b) => naturalCompare(a.holeNo, b.holeNo));
  } else if (order === 'desc') {
    STATE.uploadedData.sort((a, b) => naturalCompare(b.holeNo, a.holeNo));
  }
  // 현재 선택된 시추공의 인덱스 재설정
  STATE.currentBhIdx = STATE.uploadedData.findIndex(bh => bh.holeNo === curHole);
  if (STATE.currentBhIdx < 0) STATE.currentBhIdx = 0;
  renderSidebar();
  renderInputTab();
}

function toggleBhSort() {
  const next = STATE.bhSortOrder === 'asc' ? 'desc' : 'asc';
  sortBoreholes(next);
  const btn = document.getElementById('bhSortBtn');
  if (btn) btn.textContent = next === 'asc' ? 'A↓' : 'Z↓';
  showToast('시추공 정렬: ' + (next === 'asc' ? '오름차순 ↑' : '내림차순 ↓'), 'success');
}

function renderSidebar() {
  const list = document.getElementById('sidebarList');
  if (!list) return;
  if (!STATE.uploadedData || STATE.uploadedData.length === 0) {
    const r = STATE.result;
    const ok = r && r.St < 25;
    list.innerHTML = `<div class="bh-list-item active">
      <div><div class="bh-name">${STATE.boreholeNo}</div>
      <div class="bh-qa">${r ? 'Qa=' + fmt(r.Qa_applied) + ' kN' : '-'}</div></div>
      ${r ? '<span class="bh-status ' + (ok?'ok':'ng') + '">' + (ok?'OK':'NG') + '</span>' : ''}
    </div>`;
    return;
  }
  calcAllBoreholes();
  let html = '';
  STATE.uploadedData.forEach((bh, i) => {
    const r = BH_RESULTS[bh.holeNo];
    const ok = r && r.St < 25;
    const isActive = bh.holeNo === STATE.boreholeNo;
    html += `<div class="bh-list-item ${isActive ? 'active' : ''}" onclick="selectBoreholeFromSidebar(${i})">
      <div><div class="bh-name">${bh.holeNo}</div>
      <div class="bh-qa">${r ? 'Qa=' + fmt(r.Qa_applied) : '-'}</div></div>
      ${r ? '<span class="bh-status ' + (ok?'ok':'ng') + '">' + (ok?'OK':'NG') + '</span>' : ''}
    </div>`;
  });
  list.innerHTML = html;
}

function selectBoreholeFromSidebar(idx) {
  if (STATE.uploadedData && STATE.uploadedData[idx]) {
    saveCurrentToUploadedData(); // Save edits before switching
    applyBoreholeData(STATE.uploadedData[idx], idx);
    // Keep current tab (don't force switch to input tab)
  }
}

// ===== RENDER FUNCTIONS =====
function soilOptions(selected) {
  return SOIL_OPTS.map(o => `<option value="${o}" ${o === selected ? 'selected' : ''}>${o}</option>`).join('');
}

function getSpecInfo() {
  const isPHC = STATE.pileType === "PHC";
  if (isPHC) {
    const row = PHC_SPECS.find(r => r.d === STATE.diameter_mm);
    if (!row) return null;
    const t = row.types[STATE.phcGrade || "A"];
    return { isPHC: true, Ac: row.Ac, Ic: row.Ic, wt: row.wt, Qap_kN: t.Qap_kN, Ze: t.Ze };
  }
  const dr = STEEL_SPECS.find(r => r.d === STATE.diameter_mm);
  if (!dr) return null;
  const opt = dr.options.find(o => o.t === STATE.thickness_mm);
  return opt ? { isPHC: false, ...opt } : null;
}

function getDiamOptions() {
  const isPHC = STATE.pileType === "PHC";
  const specs = isPHC ? PHC_SPECS : STEEL_SPECS;
  return specs.map(r => `<option value="${r.d}" ${r.d === STATE.diameter_mm ? 'selected' : ''}>${r.d} mm</option>`).join('');
}

function getThkOptions() {
  const isPHC = STATE.pileType === "PHC";
  if (isPHC) {
    const row = PHC_SPECS.find(r => r.d === STATE.diameter_mm);
    return row ? `<option value="${row.t}" selected>${row.t} mm</option>` : `<option value="${STATE.thickness_mm}">${STATE.thickness_mm} mm</option>`;
  }
  const dr = STEEL_SPECS.find(r => r.d === STATE.diameter_mm);
  if (!dr) return `<option value="${STATE.thickness_mm}">${STATE.thickness_mm} mm</option>`;
  return dr.options.map(o => `<option value="${o.t}" ${o.t === STATE.thickness_mm ? 'selected' : ''}>${o.t} mm</option>`).join('');
}

function renderInputTab() {
  const isPHC = STATE.pileType === "PHC";
  const r = STATE.result;
  const spec = getSpecInfo();
  let html = '';

  // AI Natural Language Input
  html += `<div class="ai-nl-box">
    <div style="display:flex;align-items:center;gap:8px;margin-bottom:6px">
      <span style="font-size:14px">&#9889;</span>
      <span style="font-size:11px;font-weight:700;color:#4338ca">AI 자연어 입력</span>
      <span style="font-size:10px;color:var(--text-muted)">— 설계 조건을 자연어로 입력하면 자동 적용됩니다</span>
    </div>
    <div style="display:flex;gap:6px;align-items:center">
      <input type="file" id="fileInput" accept=".json" style="display:none" onchange="handleFileUpload(event)">
      <button onclick="document.getElementById('fileInput').click()" title="JSON 시추공 데이터 업로드" style="flex-shrink:0;padding:7px 10px;border:1px solid #cbd5e1;border-radius:6px;background:${STATE.uploadedData ? '#dcfce7' : '#f8fafc'};cursor:pointer;font-size:11px;color:${STATE.uploadedData ? '#16a34a' : '#64748b'};white-space:nowrap">${STATE.uploadedData ? '&#10003; ' + STATE.uploadedData.length + '공' : '&#128194; JSON'}</button>
      <input type="text" id="nlInput" placeholder="예: PHC 500mm B종, 토사 지지, 계획고 135m, 근입깊이 2m"
        onkeydown="if(event.key==='Enter')parseNLInput()">
      <button class="ai-btn" onclick="parseNLInput()">AI 적용</button>
    </div>
    <div id="nlPreview" style="display:none;margin-top:8px;padding:8px;background:#fff;border-radius:6px;border:1px solid #e2e8f0"></div>
  </div>`;

  // Borehole selector (if uploaded)
  if (STATE.uploadedData && STATE.uploadedData.length > 0) {
    html += `<div class="bh-selector">
      <label>시추공 선택:</label>
      <select onchange="selectBorehole(this.value)">
        ${STATE.uploadedData.map((bh, i) => `<option value="${i}" ${bh.holeNo === STATE.boreholeNo ? 'selected' : ''}>${bh.holeNo}</option>`).join('')}
      </select>
      <button class="btn btn-sm" onclick="openLogPanel(); renderLogPanel()">&#128200; 로그 보기</button>
    </div>`;
  }

  // Section 1: Design Specs
  html += `<h3 class="sec-title">1. 설계제원</h3>
  <div class="form-grid cols-4">
    <div class="field"><label>시추공 번호</label><input type="text" value="${STATE.boreholeNo}" onchange="STATE.boreholeNo=this.value; updateHeader()"></div>
    <div class="field"><label>말뚝 종류</label><select onchange="handlePileTypeChange(this.value)"><option value="PHC" ${isPHC?'selected':''}>PHC</option><option value="강관" ${!isPHC?'selected':''}>강관</option></select></div>
    <div class="field"><label>직경</label><select onchange="handleDiamChange(this.value)">${getDiamOptions()}</select></div>
    <div class="field"><label>두께</label><select onchange="STATE.thickness_mm=parseFloat(this.value); recalculate()">${getThkOptions()}</select></div>
  </div>`;

  if (isPHC) {
    html += `<div class="form-grid cols-4" style="margin-top:8px"><div class="field"><label>PHC 등급</label><select onchange="handlePhcGradeChange(this.value)"><option value="A" ${STATE.phcGrade==='A'?'selected':''}>A종</option><option value="B" ${STATE.phcGrade==='B'?'selected':''}>B종</option><option value="C" ${STATE.phcGrade==='C'?'selected':''}>C종</option></select></div><div class="field"><label>지지방법</label><select onchange="STATE.bearingMethod=this.value; recalculate()"><option value="meyerhof" ${STATE.bearingMethod==='meyerhof'?'selected':''}>Meyerhof (토사)</option><option value="rock" ${STATE.bearingMethod==='rock'?'selected':''}>암반근입</option></select></div><div class="field"><label>근입 깊이 (m)</label><input type="number" value="${STATE.embedDepth}" step="0.5" min="0" onchange="STATE.embedDepth=parseFloat(this.value)||0; recalculate()"></div></div>`;
  } else {
    html += `<div class="form-grid cols-4" style="margin-top:8px">
      <div class="field"><label>부식두께 (mm) <button class="info-btn" onclick="event.stopPropagation();showGuide('corrosion')">?</button></label><input type="number" value="${STATE.corrosionThk}" onchange="STATE.corrosionThk=parseFloat(this.value)||2; recalculate()"></div>
      <div class="field"><label>이음부 수</label><input type="number" value="${STATE.jointCount}" onchange="STATE.jointCount=parseInt(this.value)||0; recalculate()"></div>
      <div class="field"><label>이음 방법</label><select onchange="STATE.jointType=this.value; recalculate()"><option value="welding" ${STATE.jointType==='welding'?'selected':''}>용접</option><option value="bolt" ${STATE.jointType==='bolt'?'selected':''}>볼트</option><option value="fill" ${STATE.jointType==='fill'?'selected':''}>충전</option></select></div>
      <div class="field"><label>지지방법</label><select onchange="STATE.bearingMethod=this.value; recalculate()"><option value="rock" ${STATE.bearingMethod==='rock'?'selected':''}>암반근입</option><option value="meyerhof" ${STATE.bearingMethod==='meyerhof'?'selected':''}>Meyerhof (토사)</option></select></div>
    </div>
    <div class="form-grid cols-4" style="margin-top:8px"><div class="field"><label>근입 깊이 (m)</label><input type="number" value="${STATE.embedDepth}" step="0.5" min="0" onchange="STATE.embedDepth=parseFloat(this.value)||0; recalculate()"></div></div>`;
    if (STATE.bearingMethod === "rock") {
      html += `<div class="rock-params"><div class="form-grid cols-4">
        <div class="field"><label>qu (kPa) <button class="info-btn" onclick="event.stopPropagation();showGuide('qu_kPa')">?</button></label><input type="number" value="${STATE.qu_kPa}" onchange="STATE.qu_kPa=parseFloat(this.value)||10000; recalculate()"></div>
        <div class="field"><label>Sd (m) <button class="info-btn" onclick="event.stopPropagation();showGuide('Sd_m')">?</button></label><input type="number" value="${STATE.Sd_m}" step="0.01" onchange="STATE.Sd_m=parseFloat(this.value)||0.15; recalculate()"></div>
        <div class="field"><label>td (m) <button class="info-btn" onclick="event.stopPropagation();showGuide('td_m')">?</button></label><input type="number" value="${STATE.td_m}" step="0.001" onchange="STATE.td_m=parseFloat(this.value)||0.002; recalculate()"></div>
        <div class="field"><label>Rock Phi (deg) <button class="info-btn" onclick="event.stopPropagation();showGuide('rockPhi')">?</button></label><input type="number" value="${STATE.rockPhi}" onchange="STATE.rockPhi=parseFloat(this.value)||35; recalculate()"></div>
      </div></div>`;
    }
  }

  html += `<div class="form-grid cols-4" style="margin-top:8px">
    <div class="field"><label>말뚝두부 EL (m)</label><input type="number" value="${STATE.pileTopEL}" step="0.1" ${STATE.useFill?'disabled style="background:#f0f0f0"':''} onchange="STATE.pileTopEL=parseFloat(this.value)||130; recalculate()"></div>
    <div class="field"><label>지반고 EL (m)</label><input type="number" value="${STATE.groundEL}" step="0.01" onchange="STATE.groundEL=parseFloat(this.value)||127; recalculate()"></div>
    <div class="field"><label>지지층 EL (m)</label>
      <div style="display:flex;gap:4px"><input type="number" value="${STATE.bearingEL}" step="0.01" style="flex:1" onchange="STATE.bearingEL=parseFloat(this.value)||120; recalculate()">
      <button class="btn btn-sm" onclick="autoDetectBearingLayer()" title="SPT 데이터 기반 자동 탐지" style="font-size:9px;padding:3px 6px">자동</button></div>
    </div>
    <div class="field"><label>지하수위 (GL,m) <button class="info-btn" onclick="event.stopPropagation();showGuide('gwlDepth')">?</button></label><input type="number" value="${STATE.gwlDepth}" step="0.1" onchange="STATE.gwlDepth=parseFloat(this.value)||3; recalculate()"></div>
  </div>
  <div class="form-grid cols-4" style="margin-top:4px">
    <div class="field"></div><div class="field"></div>
    <div class="field"><label>선단 지지층 EL (m)</label><input type="number" value="${fmt(STATE.bearingEL - STATE.embedDepth, 2)}" disabled style="background:#f0f0f0;font-weight:600;color:#1565c0"></div>
    <div class="field"></div>
  </div>`;
  // Fill/Cut scenario
  const fillHeight_ui = STATE.useFill && STATE.plannedEL != null ? Math.max(STATE.plannedEL - STATE.groundEL, 0) : 0;
  const cutDepth_ui = STATE.useFill && STATE.plannedEL != null ? Math.max(STATE.groundEL - STATE.plannedEL, 0) : 0;
  const isCut = cutDepth_ui > 0;
  const isFill = fillHeight_ui > 0;
  const scenarioColor = isCut ? '#1e40af' : (isFill ? '#92400e' : 'var(--text-secondary)');
  const scenarioBg = isCut ? '#eff6ff' : (isFill ? '#fffbeb' : '#f8fafc');
  const scenarioBorder = isCut ? '#bfdbfe' : (isFill ? '#fde68a' : '#e2e8f0');
  html += `<div style="margin-top:8px;padding:8px 12px;background:${STATE.useFill?scenarioBg:'#f8fafc'};border:1px solid ${STATE.useFill?scenarioBorder:'#e2e8f0'};border-radius:6px">
    <label style="display:flex;align-items:center;gap:6px;cursor:pointer;font-size:11px;font-weight:600;color:${STATE.useFill?scenarioColor:'var(--text-secondary)'}">
      <input type="checkbox" ${STATE.useFill?'checked':''} onchange="toggleFill(this.checked)"> 계획고 적용 (성토/절토)
    </label>`;
  if (STATE.useFill) {
    html += `<div class="form-grid cols-4" style="margin-top:8px">
      <div class="field"><label>계획고 EL (m)</label><input type="number" value="${STATE.plannedEL!=null?STATE.plannedEL:''}" step="0.1" onchange="STATE.plannedEL=parseFloat(this.value); applyFillScenario()"></div>`;
    if (isFill) {
      html += `<div class="field"><label>성토재 N값 <button class="info-btn" onclick="event.stopPropagation();showGuide('fillN')">?</button></label><input type="number" value="${STATE.fillN}" min="1" max="30" onchange="STATE.fillN=parseFloat(this.value)||5; recalculate()"></div>
      <div class="field"><label>성토고 (m)</label><input type="number" value="${fmt(fillHeight_ui)}" disabled style="background:#fef3c7;color:#92400e;font-weight:600"></div>`;
    } else if (isCut) {
      html += `<div class="field"><label style="color:#1e40af">절토 깊이 (m)</label><input type="number" value="${fmt(cutDepth_ui)}" disabled style="background:#dbeafe;color:#1e40af;font-weight:600"></div>
      <div class="field"><label style="color:#1e40af">설계지반면 EL</label><input type="number" value="${fmt(STATE.plannedEL)}" disabled style="background:#dbeafe;color:#1e40af;font-weight:600"></div>`;
    } else {
      html += `<div class="field"></div><div class="field"><label>성토/절토 없음</label><input type="text" value="계획고 = 지반고" disabled style="background:#f0f0f0;font-size:10px"></div>`;
    }
    html += `<div class="field"><label>말뚝두부 EL (자동)</label><input type="number" value="${STATE.plannedEL!=null?fmt(STATE.plannedEL):''}" disabled style="background:#f0f0f0"></div>
    </div>`;
  }
  html += `</div>
  <div class="form-grid cols-3" style="margin-top:8px">
    <div class="field"><label>alpha (Kh) <button class="info-btn" onclick="event.stopPropagation();showGuide('alpha_kh')">?</button></label><input type="number" value="${STATE.alpha_kh}" step="0.1" onchange="STATE.alpha_kh=parseFloat(this.value)||1; recalculate()"></div>
    <div class="field"><label>허용변위 (cm) <button class="info-btn" onclick="event.stopPropagation();showGuide('delta_cm')">?</button></label><input type="number" value="${STATE.delta_cm}" step="0.1" onchange="STATE.delta_cm=parseFloat(this.value)||1.5; recalculate()"></div>
    <div class="field"><label>${isPHC?'허용압축응력':'항복응력'} (kN/m²) <button class="info-btn" onclick="event.stopPropagation();showGuide('sigmaMax')">?</button></label><input type="number" value="${STATE.sigmaMax}" onchange="STATE.sigmaMax=parseFloat(this.value)||20000; recalculate()"></div>
  </div>`;

  // Spec card
  if (spec) {
    html += `<div class="spec-card ${isPHC?'phc':'steel'}">
      <div class="spec-title">${isPHC ? `PHC ${STATE.phcGrade}종 D${STATE.diameter_mm}x${STATE.thickness_mm}t 제원` : `강관 D${STATE.diameter_mm}x${STATE.thickness_mm}t 제원`}</div>
      <div class="form-grid ${isPHC?'cols-4':'cols-4'}" style="font-size:10.5px">
        ${isPHC ? `<div>Ac: <strong>${spec.Ac} cm2</strong></div><div>Ic: <strong>${spec.Ic} cm4</strong></div><div>Qap: <strong>${spec.Qap_kN} kN</strong></div><div>Wt: <strong>${spec.wt} kg/m</strong></div>` :
        `<div>Ap: <strong>${spec.Ap} cm2</strong></div><div>I: <strong>${spec.I} cm4</strong></div><div>Z: <strong>${spec.Z} cm3</strong></div><div>Qap: <strong style="color:#1d4ed8">${spec.Qap} kN</strong></div>`}
      </div>
    </div>`;
  }

  // Derived (with calc-tip tooltips)
  if (r) {
    const D_m = STATE.diameter_mm / 1000;
    const t_m = STATE.thickness_mm / 1000;
    const corr_m = isPHC ? 0 : (STATE.corrosionThk || 2) / 1000;
    const tipPileLen = `L = 말뚝두부EL − 선단EL\n  = ${fmt(STATE.pileTopEL)} − ${fmt(r.tipEL)}\n  = ${fmt(r.pileLength)} m`;
    const tipApTip = `Ap = π/4 × D²\n  = π/4 × ${D_m}²\n  = ${fmt(r.Ap_tip,4)} m²`;
    const tipE = isPHC
      ? `PHC 콘크리트 탄성계수\nE = 4700 × √fck\n  = 4700 × √(80)\n  ≈ 39,200 MPa = 39.2 GPa`
      : `강관 탄성계수 (KS D 3515)\nE = 210,000 MPa = 210.0 GPa`;
    const tipI = isPHC
      ? (PHC_SPECS.find(s=>s.d===STATE.diameter_mm) ? `PHC 규격 단면2차모멘트\nIc = ${PHC_SPECS.find(s=>s.d===STATE.diameter_mm).Ic} cm⁴\n  = ${fmtE(r.I)} m⁴` : `I = π/64 × (D⁴ − d⁴)\n  = ${fmtE(r.I)} m⁴`)
      : (STEEL_SPECS.find(s=>s.d===STATE.diameter_mm) ? `강관 규격 단면2차모멘트\nI = ${STEEL_SPECS.find(s=>s.d===STATE.diameter_mm).options.find(o=>o.t===STATE.thickness_mm)?.I || '—'} cm⁴\n  = ${fmtE(r.I)} m⁴` : `I = π/64 × (D⁴ − d⁴)\n  = π/64 × (${D_m}⁴ − ${fmt(D_m-2*t_m,4)}⁴)\n  = ${fmtE(r.I)} m⁴`);
    const tipEI = `EI = E × I\n  = ${(r.E/1e6).toFixed(1)} GPa × ${fmtE(r.I)} m⁴\n  = ${(r.E/1e6).toFixed(1)} × 10⁶ × ${fmtE(r.I)}\n  = ${fmt(r.EI,1)} kN·m²`;
    const tipU = `U = π × D\n  = π × ${D_m}\n  = ${fmt(r.U,4)} m`;
    html += `<div class="derived-grid">
      <div class="dg-item"><span class="calc-tip">말뚝길이: <strong>${fmt(r.pileLength)} m</strong><span class="tip-content">${tipPileLen}</span></span></div>
      <div class="dg-item"><span class="calc-tip">선단면적: <strong>${fmt(r.Ap_tip,4)} m²</strong><span class="tip-content">${tipApTip}</span></span></div>
      <div class="dg-item"><span class="calc-tip">EI: <strong>${fmt(r.EI,1)} kN·m²</strong><span class="tip-content">${tipEI}</span></span></div>
      <div class="dg-item"><span class="calc-tip">E: <strong>${(r.E/1e6).toFixed(1)} GPa</strong><span class="tip-content">${tipE}</span></span></div>
      <div class="dg-item"><span class="calc-tip">I: <strong>${fmtE(r.I)} m⁴</strong><span class="tip-content">${tipI}</span></span></div>
      <div class="dg-item"><span class="calc-tip">둘레: <strong>${fmt(r.U,4)} m</strong><span class="tip-content">${tipU}</span></span></div>
      ${!isPHC && r.At_steel > 0 ? `<div class="dg-item"><span class="calc-tip">At: <strong style="color:var(--accent-blue)">${fmt(r.At_steel,6)} m²</strong><span class="tip-content">At = π/4 × [D² − (D−2(t−corr))²]\n  = π/4 × [${D_m}² − (${D_m}−2×(${t_m}−${corr_m}))²]\n  = ${fmt(r.At_steel,6)} m²</span></span></div><div class="dg-item"><span class="calc-tip">Ai: <strong style="color:var(--accent-blue)">${fmt(r.Ai_steel,6)} m²</strong><span class="tip-content">Ai = π/4 × (D−2t)²\n  = π/4 × (${D_m}−2×${t_m})²\n  = π/4 × ${fmt(D_m-2*t_m,4)}²\n  = ${fmt(r.Ai_steel,6)} m²</span></span></div>` : ''}
    </div>`;
  }

  // SPT Data
  html += `<h3 class="sec-title">2. SPT N값</h3>
  <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:5px">
    <span style="font-size:11px; font-weight:600; color:var(--text-secondary)">SPT 데이터</span>
    <div style="display:flex;gap:4px">
      ${STATE.sptData.length > 0 ? '<button class="btn btn-sm btn-outline" onclick="openLogPanel(); renderLogPanel()">&#128200; 로그 보기</button>' : ''}
      <button class="btn btn-sm btn-outline" onclick="openPasteModal()">붙여넣기</button>
      <button class="btn btn-sm" onclick="addSPT()">+ 추가</button>
    </div>
  </div>
  <div style="overflow-x:auto"><table>
    <thead><tr><th>No.</th><th>EL.+</th><th>깊이</th><th>N값</th><th>비고</th><th></th></tr></thead>
    <tbody>${STATE.sptData.map((s, i) => `<tr>
      <td>${i+1}</td>
      <td>${fmt(STATE.groundEL - s.depth + 1)}</td>
      <td><input type="number" value="${s.depth}" step="0.1" onchange="STATE.sptData[${i}].depth=parseFloat(this.value)||0; recalculate()"></td>
      <td><input type="number" value="${s.N}" onchange="STATE.sptData[${i}].N=parseInt(this.value)||0; recalculate()"></td>
      <td><select onchange="STATE.sptData[${i}].remark=this.value">${soilOptions(s.remark)}</select></td>
      <td><button class="btn btn-sm btn-danger" onclick="STATE.sptData.splice(${i},1); recalculate()">삭제</button></td>
    </tr>`).join('')}</tbody>
  </table></div>`;

  // Layers
  html += `<h3 class="sec-title">3. 지층 평균</h3>
  <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:5px">
    <span style="font-size:11px; font-weight:600; color:var(--text-secondary)">지층 정보</span>
    <button class="btn btn-sm" onclick="addLayer()">+ 추가</button>
  </div>
  <table>
    <thead><tr><th>지층</th><th>깊이</th><th>두께(m)</th><th>평균N</th><th>단위중량</th><th>분류</th><th></th></tr></thead>
    <tbody>`;
  // Fill layer row (if active) or Cut indicator
  const cutD_ui = STATE.useFill && STATE.plannedEL != null ? Math.max(STATE.groundEL - STATE.plannedEL, 0) : 0;
  const fillH_ui = STATE.useFill && STATE.plannedEL != null ? Math.max(STATE.plannedEL - STATE.groundEL, 0) : 0;
  if (fillH_ui > 0) {
    const fElFrom = fmt(STATE.plannedEL);
    const fElTo = fmt(STATE.groundEL);
    html += `<tr style="background:#fffbeb">
      <td style="font-weight:600;color:#92400e">성토층(계획)</td>
      <td style="font-size:10.5px;color:#92400e;white-space:nowrap">EL.${fElFrom} ~ ${fElTo}</td>
      <td><input type="number" value="${fmt(fillH_ui)}" disabled style="background:#fef3c7"></td>
      <td><input type="number" value="${STATE.fillN}" style="background:#fef3c7" onchange="STATE.fillN=parseFloat(this.value)||5; recalculate()"></td>
      <td><input type="number" value="18" disabled style="background:#fef3c7"></td>
      <td><span class="soil-badge sand">sand</span></td>
      <td></td>
    </tr>`;
  }
  html += `${STATE.layers.map((l, i) => {
      const detail = l._sptDetail || '';
      const cnt = l._sptCount || 0;
      const tipText = cnt > 0 ? '산정근거: ' + cnt + '개 SPT\\n' + detail + '\\n평균 = ' + l.avgN : '해당 구간 SPT 없음\\n인접 SPT 또는 지층 기본값 적용: N=' + l.avgN;
      let depthRange = '-';
      if (l.depthFrom != null && l.depthTo != null) {
        const elFrom = fmt(STATE.groundEL - l.depthFrom);
        const elTo = fmt(STATE.groundEL - l.depthTo);
        depthRange = 'EL.' + elFrom + ' ~ ' + elTo;
      }
      // 절토 처리: 지층별 절토 상태 판정
      const layerTop = l.depthFrom || 0;
      const layerBot = layerTop + l.thickness;
      const isFullyCut = cutD_ui > 0 && layerBot <= cutD_ui;
      const isPartiallyCut = cutD_ui > 0 && layerTop < cutD_ui && layerBot > cutD_ui;
      const cutThickness = isPartiallyCut ? (cutD_ui - layerTop) : 0;
      const remainThickness = isPartiallyCut ? (layerBot - cutD_ui) : l.thickness;
      const rowStyle = isFullyCut ? 'background:#fee2e2;opacity:0.5;text-decoration:line-through' : (isPartiallyCut ? 'background:#fef3c7' : '');
      const cutNote = isFullyCut ? '<div style="font-size:9px;color:#dc2626;font-weight:600">절토 삭제</div>' : (isPartiallyCut ? '<div style="font-size:9px;color:#1e40af;font-weight:600">절토: ' + fmt(cutThickness) + 'm 삭제 → 잔여 ' + fmt(remainThickness) + 'm</div>' : '');
      return `<tr style="${rowStyle}">
      <td><select onchange="STATE.layers[${i}].soilType=this.value; STATE.layers[${i}].unitWeight=UW_DEF[this.value]||18; recalculate()">${soilOptions(l.soilType)}</select>${cutNote}</td>
      <td style="font-size:10.5px;color:var(--text-secondary);white-space:nowrap">${depthRange}</td>
      <td><input type="number" value="${l.thickness}" step="0.1" onchange="STATE.layers[${i}].thickness=parseFloat(this.value)||0; recalculate()"></td>
      <td><span class="calc-tip" style="display:inline-block;width:100%"><input type="number" value="${l.avgN}" step="0.1" style="width:100%" onchange="STATE.layers[${i}].avgN=parseFloat(this.value)||0; recalculate()"><span class="tip-content">${tipText}</span></span></td>
      <td><input type="number" value="${l.unitWeight}" step="0.5" onchange="STATE.layers[${i}].unitWeight=parseFloat(this.value)||18; recalculate()"></td>
      <td><span class="soil-badge ${SOIL_CLS[l.soilType]||'sand'}">${SOIL_CLS[l.soilType]||'sand'}</span></td>
      <td><button class="btn btn-sm btn-danger" onclick="STATE.layers.splice(${i},1); recalculate()">삭제</button></td>
    </tr>`;
    }).join('')}</tbody>
  </table>`;

  document.getElementById('tab-input').innerHTML = html;
}

function addSPT() {
  const lastD = STATE.sptData.length > 0 ? STATE.sptData[STATE.sptData.length-1].depth : 0;
  STATE.sptData.push({ depth: lastD + 1, N: 10, remark: "퇴적층(SM)" });
  recalculate();
}
function addLayer() {
  STATE.layers.push({ soilType: "퇴적층(SM)", thickness: 2, avgN: 10, unitWeight: 18 });
  recalculate();
}

function handlePileTypeChange(v) {
  STATE.pileType = v;
  if (v === "PHC") { STATE.diameter_mm = 500; STATE.thickness_mm = 80; STATE.bearingMethod = "meyerhof"; STATE.sigmaMax = 20000; }
  else { STATE.diameter_mm = 609.6; STATE.thickness_mm = 12; STATE.bearingMethod = "rock"; STATE.sigmaMax = 235000; }
  recalculate();
}
function handleDiamChange(v) {
  const d = parseFloat(v); STATE.diameter_mm = d;
  const isPHC = STATE.pileType === "PHC";
  if (isPHC) { const row = PHC_SPECS.find(r => r.d === d); if (row) STATE.thickness_mm = row.t; }
  else { const row = STEEL_SPECS.find(r => r.d === d); if (row && row.options.length) STATE.thickness_mm = row.options[row.options.length - 1].t; }
  recalculate();
}

function handlePhcGradeChange(v) {
  STATE.phcGrade = v;
  // PHC 등급별 허용압축응력 (KS F 4306)
  const PHC_SIGMA = { A: 20000, B: 40000, C: 50000 };
  STATE.sigmaMax = PHC_SIGMA[v] || 20000;
  recalculate();
}

function autoDetectBearingLayer() {
  if ((!STATE.sptData || STATE.sptData.length === 0) && (!STATE.layers || STATE.layers.length === 0)) {
    showToast('SPT 데이터 및 지층 정보가 없습니다', 'warning'); return;
  }
  const method = STATE.bearingMethod || (STATE.pileType === 'PHC' ? 'meyerhof' : 'rock');
  if (method === 'rock') {
    // 1차: SPT remark에서 암반 탐색
    for (let i = 0; i < (STATE.sptData || []).length; i++) {
      const remark = STATE.sptData[i].remark || '';
      if (remark.includes('풍화암') || remark.includes('연암') || remark.includes('경암') || remark.includes('WR') || remark.includes('SR') || remark.includes('HR')) {
        const bd = STATE.sptData[i].depth;
        STATE.bearingEL = parseFloat((STATE.groundEL - bd + 1).toFixed(2));
        showToast('지지층 자동 탐지 (SPT): ' + remark + ' (GL-' + bd + 'm) → EL.' + fmt(STATE.bearingEL), 'success');
        recalculate(); return;
      }
    }
    // 2차: 지층 정보(layers)에서 암반 탐색 — SPT 없는 암반층 대응
    if (STATE.layers && STATE.layers.length > 0) {
      let cumDepth = 0;
      for (let i = 0; i < STATE.layers.length; i++) {
        const lt = STATE.layers[i].soilType || '';
        const dFrom = STATE.layers[i].depthFrom != null ? STATE.layers[i].depthFrom : cumDepth;
        cumDepth = dFrom + STATE.layers[i].thickness;
        if (lt.includes('풍화암') || lt.includes('연암') || lt.includes('경암') || lt.includes('WR') || lt.includes('SR') || lt.includes('HR')) {
          STATE.bearingEL = parseFloat((STATE.groundEL - dFrom).toFixed(2));
          showToast('지지층 자동 탐지 (지층): ' + lt + ' (GL-' + fmt(dFrom) + 'm) → EL.' + fmt(STATE.bearingEL), 'success');
          recalculate(); return;
        }
      }
    }
    showToast('암반층(풍화암/연암/경암)을 찾을 수 없습니다', 'warning');
  } else {
    // 1차: SPT에서 N≥50 연속 2개
    for (let i = 0; i < (STATE.sptData || []).length - 1; i++) {
      if (STATE.sptData[i].N >= 50 && STATE.sptData[i + 1].N >= 50) {
        const bd = STATE.sptData[i].depth;
        STATE.bearingEL = parseFloat((STATE.groundEL - bd + 1).toFixed(2));
        showToast('지지층 자동 탐지: N≥50 연속 (GL-' + bd + 'm) → EL.' + fmt(STATE.bearingEL), 'success');
        recalculate(); return;
      }
    }
    // 2차: 지층에서 N≥50인 첫 번째 층 탐색
    if (STATE.layers && STATE.layers.length > 0) {
      let cumDepth = 0;
      for (let i = 0; i < STATE.layers.length; i++) {
        const dFrom = STATE.layers[i].depthFrom != null ? STATE.layers[i].depthFrom : cumDepth;
        cumDepth = dFrom + STATE.layers[i].thickness;
        if (STATE.layers[i].avgN >= 50) {
          STATE.bearingEL = parseFloat((STATE.groundEL - dFrom).toFixed(2));
          showToast('지지층 자동 탐지 (지층 N≥50): ' + STATE.layers[i].soilType + ' (GL-' + fmt(dFrom) + 'm) → EL.' + fmt(STATE.bearingEL), 'success');
          recalculate(); return;
        }
      }
    }
    showToast('N≥50 연속 2개 이상 구간을 찾을 수 없습니다', 'warning');
  }
}

function toggleFill(checked) {
  STATE.useFill = checked;
  if (checked && STATE.plannedEL == null) STATE.plannedEL = Math.round((STATE.groundEL + 2) * 100) / 100;
  applyFillScenario();
}
function applyFillScenario() {
  if (STATE.useFill && STATE.plannedEL != null) {
    STATE.pileTopEL = STATE.plannedEL;
  }
  recalculate();
}

function updateHeader() {
  document.getElementById('headerBH').textContent = STATE.boreholeNo;
  const tag = document.getElementById('pileTag');
  tag.textContent = STATE.pileType === "PHC" ? "PHC" : "강관";
  tag.className = 'pile-tag ' + (STATE.pileType === "PHC" ? 'phc' : 'steel');
}

// File upload handlers
function handleFileUpload(e) {
  const file = e.target.files[0];
  if (!file) return;
  const reader = new FileReader();
  reader.onload = function(ev) { processJSON(ev.target.result, file.name); };
  reader.readAsText(file, 'UTF-8');
}
function handleDrop(e) {
  e.preventDefault();
  e.currentTarget.classList.remove('dragover');
  const file = e.dataTransfer.files[0];
  if (!file || !file.name.endsWith('.json')) { showToast('JSON 파일만 업로드 가능합니다', 'error'); return; }
  const reader = new FileReader();
  reader.onload = function(ev) { processJSON(ev.target.result, file.name); };
  reader.readAsText(file, 'UTF-8');
}
function processJSON(text, filename) {
  try {
    const json = JSON.parse(text);
    const boreholes = importDrillLogJSON(json);
    if (boreholes.length === 0) { showToast('시추공 데이터를 찾을 수 없습니다', 'error'); return; }
    STATE.uploadedData = boreholes;
    STATE.bhSortOrder = 'asc';
    boreholes.sort((a, b) => naturalCompare(a.holeNo, b.holeNo));
    applyBoreholeData(boreholes[0], 0);
    showToast(`${filename}: ${boreholes.length}개 시추공 로드 완료 (번호순 정렬)`, 'success');
  } catch (e) { showToast('JSON 파싱 오류: ' + e.message, 'error'); }
}
function selectBorehole(idx) {
  if (STATE.uploadedData && STATE.uploadedData[idx]) {
    saveCurrentToUploadedData();
    applyBoreholeData(STATE.uploadedData[idx], idx);
  }
}

// ===== VERTICAL TAB =====
function renderVerticalTab() {
  const el = document.getElementById('tab-vertical');
  const r = STATE.result;
  if (!r) { el.innerHTML = '<p style="color:var(--text-muted)">계산 결과가 없습니다.</p>'; return; }
  const isPHC = STATE.pileType === "PHC";
  let html = `<h3 class="sec-title">수직 허용지지력 산정 (KDS 11 50 40)</h3>`;

  // ── 1. 설계 조건 요약 ──
  html += `<div class="report-section"><div class="report-title">설계 조건 요약</div>
  <table><thead><tr><th>항목</th><th>값</th><th>항목</th><th>값</th></tr></thead><tbody>
  <tr><td class="left">말뚝 종류</td><td>${isPHC?'PHC '+STATE.phcGrade+'종':'강관말뚝'}</td><td class="left">직경 D</td><td>${STATE.diameter_mm} mm = ${fmt(r.D,4)} m</td></tr>
  <tr><td class="left">두께 t</td><td>${STATE.thickness_mm} mm</td><td class="left">말뚝 길이 L</td><td>$${fmt(STATE.pileTopEL,2)} - ${fmt(r.tipEL,2)} = ${fmt(r.pileLength)}$ m</td></tr>
  <tr><td class="left">둘레 U</td><td>$\\pi D = \\pi \\times ${fmt(r.D,4)} = ${fmt(r.U,4)}$ m</td><td class="left">선단면적 Ap</td><td>$\\frac{\\pi}{4}D^2 = \\frac{\\pi}{4}\\times${fmt(r.D,4)}^2 = ${fmt(r.Ap_tip,4)}$ m²</td></tr>
  <tr><td class="left">순단면적 An</td><td>${fmt(r.Ap_net,4)} m²</td><td class="left">탄성계수 E</td><td>${(r.E/1e6).toFixed(1)} GPa</td></tr>
  </tbody></table></div>`;

  // ── 2. 재료 허용연직지지력 ──
  html += `<div class="report-section"><div class="report-title">Step 1. 재료 허용연직지지력 (Qp)</div>
  <div style="margin:10px 0">$$Q_p = \\left(1 - \\frac{\\mu_1 + \\mu_2}{100}\\right) \\times Q_{ap}$$</div>

  <div style="padding:10px;background:#f8f9fa;border-radius:6px;margin-bottom:8px">
  <div style="font-size:11px;font-weight:700;color:var(--primary-navy);margin-bottom:6px">▸ 세장비 감소율 (μ₁)</div>
  <div style="font-size:11px">세장비: $L/d = \\frac{${fmt(r.pileLength)}}{${fmt(r.D,4)}} = ${fmt(r.L_over_d,1)}$</div>
  <div style="font-size:11px">세장비 한계값: $n = ${r.n_slender}$ ${isPHC?'(PHC말뚝: KDS 11 50 40)':'(강관말뚝: KDS 11 50 40)'}</div>
  <div style="font-size:11px;margin-top:4px">${r.L_over_d > r.n_slender ?
    `$L/d = ${fmt(r.L_over_d,1)} > n = ${r.n_slender}$ → 세장비 감소 적용<br>$\\mu_1 = \\min\\left(\\left(\\frac{${fmt(r.L_over_d,1)}}{${r.n_slender}} - 1\\right) \\times 100,\\; 30\\right) = \\min(${fmt((r.L_over_d/r.n_slender-1)*100,1)},\\; 30)$` :
    `$L/d = ${fmt(r.L_over_d,1)} \\leq n = ${r.n_slender}$ → 세장비 감소 없음`}</div>
  <div style="font-size:12px;font-weight:700;margin-top:4px">$\\therefore \\mu_1 = ${fmt(r.mu1)}\\%$</div>
  </div>

  <div style="padding:10px;background:#f8f9fa;border-radius:6px;margin-bottom:8px">
  <div style="font-size:11px;font-weight:700;color:var(--primary-navy);margin-bottom:6px">▸ 이음부 감소율 (μ₂)</div>
  <div style="font-size:11px">이음방법: <strong>${STATE.jointType==='welding'?'용접이음':STATE.jointType==='bolt'?'볼트이음':'충전이음'}</strong>, 이음수: <strong>${STATE.jointCount}개소</strong></div>
  <div style="font-size:11px;margin-top:4px">${STATE.jointCount === 0 ? '이음부 없음 → μ₂ = 0%' :
    STATE.jointType==='welding' ? `용접이음 1개소당 5%: $\\mu_2 = ${STATE.jointCount} \\times 5 = ${fmt(r.mu2)}\\%$` :
    STATE.jointType==='bolt' ? `볼트이음 1개소당 10%: $\\mu_2 = ${STATE.jointCount} \\times 10 = ${fmt(r.mu2)}\\%$` :
    `충전이음: $\\mu_2 = \\min(${STATE.jointCount},2)\\times 20 + \\max(${STATE.jointCount}-2,0)\\times 30 = ${fmt(r.mu2)}\\%$`}</div>
  <div style="font-size:12px;font-weight:700;margin-top:4px">$\\therefore \\mu_2 = ${fmt(r.mu2)}\\%$</div>
  </div>

  <div style="padding:10px;background:#f8f9fa;border-radius:6px;margin-bottom:8px">
  <div style="font-size:11px;font-weight:700;color:var(--primary-navy);margin-bottom:6px">▸ 허용축하중 (Qap)</div>
  <div style="font-size:11px">${isPHC ? `PHC ${STATE.phcGrade}종 D${STATE.diameter_mm}×${STATE.thickness_mm}t 규격값 (KS F 4306)` : `강관 D${STATE.diameter_mm}×${STATE.thickness_mm}t 규격값`}</div>
  <div style="font-size:12px;font-weight:700">$Q_{ap} = ${fmt(r.Qap)}$ kN</div>
  </div>

  <div style="padding:12px;background:#e8f5e9;border-radius:6px;border:1px solid #a5d6a7">
  <div style="font-size:11px">$Q_p = \\left(1 - \\frac{${fmt(r.mu1)} + ${fmt(r.mu2)}}{100}\\right) \\times ${fmt(r.Qap)}$</div>
  <div style="font-size:11px;margin-top:2px">$= \\left(1 - \\frac{${fmt(r.mu1+r.mu2)}}{100}\\right) \\times ${fmt(r.Qap)} = ${fmt(1-(r.mu1+r.mu2)/100,4)} \\times ${fmt(r.Qap)}$</div>
  <div style="font-size:13px;font-weight:800;color:var(--status-pass);margin-top:4px">$$\\therefore Q_p = ${fmt(r.Qp_material)} \\text{ kN}$$</div>
  </div></div>`;

  // ── 3. 암반 선단지지력 (강관+rock) ──
  if (!isPHC && r.rockCalcDetails) {
    const rc = r.rockCalcDetails;
    html += `<div class="report-section"><div class="report-title">Step 2. 암반 선단지지력</div>

    <div style="padding:10px;background:#fff3e0;border-radius:6px;margin-bottom:10px">
    <div style="font-size:11px;font-weight:700;color:#e65100;margin-bottom:6px">방법 ① 구조물기초설계기준 (p305)</div>
    <div style="margin:6px 0">$$P_u = 443 \\times q_u^{1/2} \\times A_t^{2/5} \\times A_i^{1/3}$$</div>
    <div style="font-size:11px">일축압축강도: $q_u = \\min(${fmt(rc.qu_lab)},\\; 10000) = ${fmt(rc.qu_eff)}$ kPa</div>
    <div style="font-size:11px">강관 순단면적: $A_t = ${fmt(rc.At_m2,6)}$ m²</div>
    <div style="font-size:11px">강관 내부면적: $A_i = ${fmt(rc.Ai_m2,6)}$ m²</div>
    <div style="font-size:11px;margin-top:6px">$P_u = 443 \\times ${fmt(rc.qu_eff)}^{0.5} \\times ${fmt(rc.At_m2,6)}^{0.4} \\times ${fmt(rc.Ai_m2,6)}^{0.333}$</div>
    <div style="font-size:11px">$= 443 \\times ${fmt(Math.pow(rc.qu_eff,0.5),2)} \\times ${fmt(Math.pow(rc.At_m2,0.4),4)} \\times ${fmt(Math.pow(rc.Ai_m2,1/3),4)}$</div>
    <div style="font-size:12px;font-weight:800">$= ${fmt(rc.Pu_tip)}$ kN</div>
    </div>

    <div style="padding:10px;background:#fff3e0;border-radius:6px;margin-bottom:10px">
    <div style="font-size:11px;font-weight:700;color:#e65100;margin-bottom:6px">방법 ② Goodman (도로교설계기준 2008, p863)</div>
    <div style="margin:6px 0">$$Q_u = q_u \\times (N_\\phi + 1) \\times A_p$$</div>
    <div style="font-size:11px">암반 내부마찰각: $\\phi = ${rc.phi_rock}°$</div>
    <div style="font-size:11px">$N_\\phi = \\tan^2\\left(45° + \\frac{${rc.phi_rock}°}{2}\\right) = \\tan^2(${45+rc.phi_rock/2}°) = ${fmt(rc.N_phi,3)}$</div>
    <div style="font-size:11px">선단 전체면적: $A_p = \\frac{\\pi}{4}\\times${fmt(r.D,4)}^2 = ${fmt(rc.Ap_full,4)}$ m²</div>
    <div style="font-size:11px;margin-top:6px">$Q_u = ${fmt(rc.qu_lab)} \\times (${fmt(rc.N_phi,3)} + 1) \\times ${fmt(rc.Ap_full,4)}$</div>
    <div style="font-size:11px">$= ${fmt(rc.qu_lab)} \\times ${fmt(rc.N_phi+1,3)} \\times ${fmt(rc.Ap_full,4)}$</div>
    <div style="font-size:12px;font-weight:800">$= ${fmt(rc.Pu_goodman)}$ kN</div>
    </div>

    <div style="padding:10px;background:#fff3e0;border-radius:6px;margin-bottom:10px">
    <div style="font-size:11px;font-weight:700;color:#e65100;margin-bottom:6px">방법 ③ Canadian FEM (도로교설계기준 2008, p862)</div>
    <div style="margin:6px 0">$$Q_u = 3 \\times q_u \\times K_{sp} \\times d \\times A_p$$</div>
    <div style="font-size:11px">불연속면 간격: $S_d = ${rc.Sd}$ m, 두께: $t_d = ${rc.td}$ m</div>
    <div style="font-size:11px;margin-top:4px">$$K_{sp} = \\frac{3 + S_d/D}{10\\sqrt{1 + 300 t_d / S_d}} = \\frac{3 + ${rc.Sd}/${fmt(r.D,4)}}{10\\sqrt{1 + 300 \\times ${rc.td}/${rc.Sd}}} = \\frac{${fmt(3+rc.Sd/r.D,3)}}{10 \\times ${fmt(Math.sqrt(1+300*rc.td/rc.Sd),3)}} = ${fmt(rc.Ksp,4)}$$</div>
    <div style="font-size:11px;margin-top:6px">$Q_u = 3 \\times ${fmt(rc.qu_lab)} \\times ${fmt(rc.Ksp,4)} \\times 2 \\times ${fmt(rc.Ap_full,4)}$</div>
    <div style="font-size:12px;font-weight:800">$= ${fmt(rc.Pu_canadian)}$ kN</div>
    </div>

    <div style="padding:10px;background:#e3f2fd;border-radius:6px">
    <div style="font-size:11px;font-weight:700;color:var(--primary-navy);margin-bottom:6px">선단지지력 비교·선정</div>
    <table style="margin-top:4px"><thead><tr><th>방법</th><th>Pu (kN)</th><th>비고</th></tr></thead><tbody>
    <tr><td class="left">구조물기초설계기준</td><td style="font-weight:700">${fmt(rc.Pu_tip)}</td><td>${rc.Pu_tip===rc.Pu_selected?'← 최솟값':''}</td></tr>
    <tr><td class="left">Goodman</td><td style="font-weight:700">${fmt(rc.Pu_goodman)}</td><td>${rc.Pu_goodman===rc.Pu_selected?'← 최솟값':''}</td></tr>
    <tr><td class="left">Canadian FEM</td><td style="font-weight:700">${fmt(rc.Pu_canadian)}</td><td>${rc.Pu_canadian===rc.Pu_selected?'← 최솟값':''}</td></tr>
    </tbody></table>
    <div style="font-size:13px;font-weight:800;color:var(--status-pass);margin-top:8px">$$P_u = \\min(${fmt(rc.Pu_tip)},\\; ${fmt(rc.Pu_goodman)},\\; ${fmt(rc.Pu_canadian)}) = ${fmt(rc.Pu_selected)} \\text{ kN}$$</div>
    </div></div>`;
  }

  // ── 4. 지반 허용연직지지력 ──
  const stepNo = (!isPHC && r.rockCalcDetails) ? 3 : 2;
  html += `<div class="report-section"><div class="report-title">Step ${stepNo}. 지반 허용연직지지력</div>
  <div style="font-size:11px;color:var(--text-secondary);margin-bottom:6px">기준: Meyerhof 공식 (사질토), KDS 11 50 40</div>
  <div style="margin:8px 0">$$Q_u = ${r.rockCalcDetails?'P_u':'250 N_{tip} A_p'} + \\sum 2 N_s A_s + \\sum 6.25 N_c A_c$$</div>`;

  // Tip resistance
  if (!r.rockCalcDetails) {
    const tipN = r.N_tip;
    const lastSPT = STATE.sptData.length > 0 ? STATE.sptData[STATE.sptData.length-1].N : 50;
    html += `<div style="padding:10px;background:#f8f9fa;border-radius:6px;margin-bottom:8px">
    <div style="font-size:11px;font-weight:700;color:var(--primary-navy);margin-bottom:4px">▸ 선단지지력 (Meyerhof)</div>
    <div style="font-size:11px">선단부 N값: $N_{tip} = \\min(N_{최하단},\\;50) = \\min(${lastSPT},\\;50) = ${tipN}$</div>
    <div style="font-size:11px">선단면적: $A_p = \\frac{\\pi}{4}D^2 = \\frac{\\pi}{4}\\times${fmt(r.D,4)}^2 = ${fmt(r.Ap_tip,4)}$ m²</div>
    <div style="font-size:12px;font-weight:700;margin-top:6px">$P_u = 250 \\times N_{tip} \\times A_p = 250 \\times ${tipN} \\times ${fmt(r.Ap_tip,4)} = ${fmt(r.Qu_tip)}$ kN</div>
    </div>`;
  } else {
    html += `<div style="padding:10px;background:#f8f9fa;border-radius:6px;margin-bottom:8px">
    <div style="font-size:11px;font-weight:700;color:var(--primary-navy);margin-bottom:4px">▸ 선단지지력 (암반근입)</div>
    <div style="font-size:11px">위 Step 2에서 산정: $P_u = ${fmt(r.rockCalcDetails.Pu_selected)}$ kN</div>
    </div>`;
  }

  // Skin friction detail table
  html += `<div style="padding:10px;background:#f8f9fa;border-radius:6px;margin-bottom:8px">
  <div style="font-size:11px;font-weight:700;color:var(--primary-navy);margin-bottom:6px">▸ 주면마찰력 상세</div>
  <div style="font-size:11px;margin-bottom:4px">둘레: $U = \\pi D = \\pi \\times ${fmt(r.D,4)} = ${fmt(r.U,4)}$ m</div>
  <div style="font-size:10px;color:var(--text-secondary);margin-bottom:4px">주면마찰력 산정 범위: ${r.cutDepth > 0 ? '설계지반면 (EL.'+fmt(STATE.plannedEL,2)+', 절토 GL-'+fmt(r.cutDepth,2)+'m)' : '지표면 (EL.'+fmt(r.groundEL,2)+')'} ~ 선단 (EL.${fmt(r.tipEL,2)}), GL-${fmt(r.bearingDepthFromGL,2)}m</div>
  <table style="margin-top:6px"><thead><tr><th>지층</th><th>분류</th><th>두께 L(m)</th><th>평균 N</th><th>$A_s = U \\times L$</th><th>사질토: $2N_sA_s$</th><th>점성토: $6.25N_cA_c$</th></tr></thead><tbody>`;
  r.processedLayers.forEach(function(l) {
    const cN = Math.min(l.avgN, 30);
    const elTop = r.groundEL != null ? fmt(r.groundEL - l.depthFrom, 2) : '-';
    const elBot = r.groundEL != null ? fmt(r.groundEL - l.depthTo, 2) : '-';
    const truncNote = l.truncated ? ' <span style="color:#c62828;font-size:9px">(선단 절단)</span>' : '';
    const thkCalc = `<span style="font-size:10px;color:#495057">EL.${elTop} ~ EL.${elBot}</span><br><strong>${fmt(l.thickness)}</strong>${truncNote}`;
    html += `<tr${l.truncated ? ' style="background:#fff8e1"' : ''}>
    <td class="left">${l.soilType}</td>
    <td><span class="soil-badge ${l.soilClass}">${l.soilClass}</span></td>
    <td style="white-space:nowrap">${thkCalc}</td>
    <td>${fmt(l.avgN,1)} ${l.avgN>30?'→ cap 30':''}</td>
    <td>$${fmt(r.U,4)} \\times ${fmt(l.thickness)} = ${fmt(l.As,3)}$</td>
    <td>${l.soilClass==='sand' ? `$2 \\times ${fmt(cN,1)} \\times ${fmt(l.As,3)} = ${fmt(l.skinFriction_sand)}$` : '-'}</td>
    <td>${l.soilClass==='clay' ? `$6.25 \\times ${fmt(cN,1)} \\times ${fmt(l.As,3)} = ${fmt(l.skinFriction_clay)}$` : '-'}</td>
    </tr>`;
  });
  html += `<tr style="background:#e8eaf6;font-weight:700"><td class="left" colspan="4">합계</td><td></td><td>${fmt(r.sum_2NsAs)} kN</td><td>${fmt(r.sum_625NcAc)} kN</td></tr>`;
  html += `</tbody></table></div>`;

  // Qu, Qa
  html += `<div style="padding:12px;background:#e8f5e9;border-radius:6px;border:1px solid #a5d6a7;margin-bottom:8px">
  <div style="font-size:11px;font-weight:700">극한 지지력:</div>
  <div style="font-size:11px">$Q_u = P_u + \\Sigma 2N_sA_s + \\Sigma 6.25N_cA_c$</div>
  <div style="font-size:11px;margin-top:2px">$= ${fmt(r.Qu_tip)} + ${fmt(r.sum_2NsAs)} + ${fmt(r.sum_625NcAc)} = ${fmt(r.Qu)}$ kN</div>
  <div style="font-size:11px;font-weight:700;margin-top:6px">허용 지지력 (FS=${r.FS}):</div>
  <div style="font-size:12px;font-weight:800;color:var(--status-pass)">$$Q_a = \\frac{Q_u}{FS} = \\frac{${fmt(r.Qu)}}{${r.FS}} = ${fmt(r.Qa_ground)} \\text{ kN}$$</div>
  </div></div>`;

  // ── 5. 종합 비교 ──
  const finalStep = stepNo + 1;
  html += `<div class="report-section"><div class="report-title">Step ${finalStep}. 수직지지력 종합 비교</div>
  <table><thead><tr><th>구분</th><th>지지력 (kN)</th><th>산정 근거</th></tr></thead><tbody>
  <tr><td class="left">재료 허용지지력 (Qp)</td><td style="font-weight:700">${fmt(r.Qp_material)}</td><td class="left">${isPHC?'PHC '+STATE.phcGrade+'종':'강관'} 규격기반, μ₁=${fmt(r.mu1)}%, μ₂=${fmt(r.mu2)}%</td></tr>
  <tr><td class="left">지반 허용지지력 (Qa)</td><td style="font-weight:700">${fmt(r.Qa_ground)}</td><td class="left">Qu=${fmt(r.Qu)} kN / FS=${r.FS}</td></tr>
  </tbody></table>
  <div style="margin-top:10px;padding:12px;background:#e3f2fd;border-radius:6px;text-align:center">
  <div style="font-size:14px;font-weight:800;color:var(--primary-navy)">$$Q_{a,적용} = \\min(Q_p,\\; Q_a) = \\min(${fmt(r.Qp_material)},\\; ${fmt(r.Qa_ground)}) = ${fmt(r.Qa_applied)} \\text{ kN}$$</div>
  <div style="font-size:11px;color:var(--text-secondary);margin-top:4px">${r.Qa_applied === r.Qp_material ? '→ 재료 허용지지력이 지배 (Qp < Qa)' : '→ 지반 허용지지력이 지배 (Qa < Qp)'}</div>
  </div></div>`;

  el.innerHTML = html;
  if (window.MathJax && MathJax.typesetPromise) MathJax.typesetPromise([el]).catch(function(e){});
}

// ===== HORIZONTAL TAB =====
function renderHorizontalTab() {
  const el = document.getElementById('tab-horizontal');
  const r = STATE.result;
  if (!r) { el.innerHTML = '<p style="color:var(--text-muted)">계산 결과가 없습니다.</p>'; return; }
  const isPHC = STATE.pileType === "PHC";
  let html = `<h3 class="sec-title">수평 허용지지력 산정</h3>`;

  // ── Step 1: Kh ──
  html += `<div class="report-section"><div class="report-title">Step 1. 수평 지반반력계수 (Kh) 산정</div>
  <div style="padding:10px;background:#f8f9fa;border-radius:6px;margin-bottom:10px">
  <div style="font-size:11px;font-weight:700;color:var(--primary-navy);margin-bottom:6px">▸ 기본 물성</div>
  <div style="font-size:11px">N값 평균 (GL~1/β=${fmt(r.invBeta,2)}m, N<50): $N_{avg} = ${r.N_kh}$</div>
  <div style="font-size:11px">보정계수: $\\alpha = ${STATE.alpha_kh}$</div>
  <div style="font-size:11px">탄성계수: $E = ${(r.E/1e6).toFixed(1)}$ GPa</div>
  <div style="font-size:11px">단면2차모멘트${isPHC?'':'(부식적용)'}: $I = ${fmtE(r.I_h)}$ m⁴</div>
  <div style="font-size:11px">휨강성: $EI = E \\times I = ${(r.E/1e3).toFixed(0)} \\times ${fmtE(r.I_h)} = ${fmt(r.EI_h,1)}$ kN·m²</div>
  <div style="font-size:11px;margin-top:4px">$E_0 = 2800N = 2800 \\times ${r.N_kh} = ${r.Eo2800}$ kN/m²</div>
  <div style="font-size:11px">$E_0' = 1000N = 1000 \\times ${r.N_kh} = ${r.Eo1000}$ kN/m²</div>
  </div>

  <table><thead><tr><th>산정 방법</th><th>산정식 및 대입</th><th>Kh (kN/m³)</th></tr></thead><tbody>
  <tr style="background:${r.Kh_min===r.Kh1?'#fef9c3':'inherit'}"><td class="left">도로교 설계기준<br>(2008)</td>
  <td class="left" style="font-size:10px">$K_h = 1.208 (\\alpha E_0)^{1.1} D^{-0.31} (EI)^{-0.1}$<br>$= 1.208 \\times (${STATE.alpha_kh} \\times ${r.Eo2800})^{1.1} \\times ${fmt(r.D,4)}^{-0.31} \\times ${fmt(r.EI_h,1)}^{-0.1}$</td>
  <td style="font-weight:700">${fmt(r.Kh1,1)}</td></tr>
  <tr style="background:${r.Kh_min===r.Kh2?'#fef9c3':'inherit'}"><td class="left">福岡 (Fukuoka)</td>
  <td class="left" style="font-size:10px">$K_h = 6910 N^{0.406} = 6910 \\times ${r.N_kh}^{0.406}$</td>
  <td style="font-weight:700">${fmt(r.Kh2,1)}</td></tr>
  <tr style="background:${r.Kh_min===r.Kh3?'#fef9c3':'inherit'}"><td class="left">横山 (Yokoyama)</td>
  <td class="left" style="font-size:10px">$K_h = 2000N = 2000 \\times ${r.N_kh}$</td>
  <td style="font-weight:700">${fmt(r.Kh3,1)}</td></tr>
  <tr style="background:${r.Kh_min===r.Kh4?'#fef9c3':'inherit'}"><td class="left">지반공학회<br>(1996)</td>
  <td class="left" style="font-size:10px">$K_h = 1.208 (\\alpha \\cdot 1000N)^{1.1} D^{-0.31} (EI)^{-0.1}$<br>$= 1.208 \\times (${STATE.alpha_kh} \\times ${r.Eo1000})^{1.1} \\times ${fmt(r.D,4)}^{-0.31} \\times ${fmt(r.EI_h,1)}^{-0.1}$</td>
  <td style="font-weight:700">${fmt(r.Kh4,1)}</td></tr>
  </tbody></table>
  <div style="padding:10px;background:#e8f5e9;border-radius:6px;border:1px solid #a5d6a7;margin-top:8px">
  <div style="font-size:13px;font-weight:800;color:var(--status-pass)">$$K_h = \\min(${fmt(r.Kh1,1)},\\; ${fmt(r.Kh2,1)},\\; ${fmt(r.Kh3,1)},\\; ${fmt(r.Kh4,1)}) = ${fmt(r.Kh_min,1)} \\text{ kN/m³}$$</div>
  <div style="font-size:10px;color:var(--text-secondary)">← 최솟값 채택 (안전측)</div>
  </div></div>`;

  // ── Step 2: β, η, pile classification ──
  const nh_val = r.Kh_min * r.D * r.beta;
  html += `<div class="report-section"><div class="report-title">Step 2. 말뚝 특성치 및 분류</div>
  <div style="padding:10px;background:#f8f9fa;border-radius:6px;margin-bottom:10px">
  <div style="font-size:11px;font-weight:700;color:var(--primary-navy);margin-bottom:6px">▸ 특성치 산정</div>
  <div style="font-size:11px">$$\\beta = \\left(\\frac{K_h \\cdot D}{4 \\cdot EI}\\right)^{0.25} = \\left(\\frac{${fmt(r.Kh_min,1)} \\times ${fmt(r.D,4)}}{4 \\times ${fmt(r.EI_h,1)}}\\right)^{0.25} = ${fmt(r.beta,6)} \\text{ m}^{-1}$$</div>
  <div style="font-size:11px">$1/\\beta = ${fmt(r.invBeta,2)}$ m (수평저항 관여 깊이)</div>
  <div style="font-size:11px">$n_h = K_h \\cdot D \\cdot \\beta^{-1}$... $\\eta = (n_h / EI)^{0.2} = ${fmt(r.eta,6)}$ m⁻¹</div>
  <div style="font-size:12px;font-weight:700;margin-top:6px">$\\eta L = ${fmt(r.eta,6)} \\times ${fmt(r.pileLength)} = ${fmt(r.etaL,2)}$</div>
  </div>
  <div style="padding:8px 12px;background:#e0f2fe;border-radius:6px;margin-bottom:8px">
  <div style="font-size:11px">${r.etaL < 2 ? `$\\eta L = ${fmt(r.etaL,2)} < 2$ → <strong>짧은말뚝 (Short Pile)</strong>` : r.etaL <= 4 ? `$2 \\leq \\eta L = ${fmt(r.etaL,2)} \\leq 4$ → <strong>중간말뚝 (Intermediate)</strong>` : `$\\eta L = ${fmt(r.etaL,2)} > 4$ → <strong>긴말뚝 (Long Pile)</strong>`}</div>
  </div></div>`;

  // ── Step 3: Brom Case-1 ──
  html += `<div class="report-section"><div class="report-title">Step 3. Brom 방법 — Case-1 (변위 제한)</div>
  <div style="font-size:11px;color:var(--text-secondary);margin-bottom:6px">허용수평변위: $\\delta = ${STATE.delta_cm}$ cm = ${fmt(STATE.delta_cm/100,4)} m</div>

  <div style="padding:10px;background:#f8f9fa;border-radius:6px;margin-bottom:8px">
  <div style="font-size:11px;font-weight:700;color:var(--primary-navy);margin-bottom:4px">▸ 내부마찰각 · 수동토압계수</div>
  <div style="font-size:11px">$\\phi = \\sqrt{12N} + 15 = \\sqrt{12 \\times ${r.N_kh}} + 15 = ${fmt(Math.sqrt(12*r.N_kh),2)} + 15 = ${fmt(r.phi_deg,1)}°$</div>
  <div style="font-size:11px">$K_p = \\frac{1+\\sin\\phi}{1-\\sin\\phi} = \\frac{1+\\sin${fmt(r.phi_deg,1)}°}{1-\\sin${fmt(r.phi_deg,1)}°} = ${fmt(r.Kp,3)}$</div>
  <div style="font-size:11px">$\\gamma = ${r.gamma_top}$ kN/m³ (최상위 지층 단위중량)</div>
  </div>

  <div style="padding:10px;background:#f8f9fa;border-radius:6px;margin-bottom:8px">
  <div style="font-size:11px;font-weight:700;color:var(--primary-navy);margin-bottom:4px">▸ 변위에 의한 수평하중 (H)</div>
  <div style="font-size:11px">$$H = 4\\beta^3 \\cdot EI \\cdot \\delta = 4 \\times ${fmt(r.beta,6)}^3 \\times ${fmt(r.EI_h,1)} \\times ${fmt(STATE.delta_cm/100,4)}$$</div>
  <div style="font-size:11px">$= 4 \\times ${fmtE(Math.pow(r.beta,3))} \\times ${fmt(r.EI_h,1)} \\times ${fmt(STATE.delta_cm/100,4)} = ${fmt(r.H_disp)}$ kN</div>
  </div>

  <div style="padding:10px;background:#f8f9fa;border-radius:6px;margin-bottom:8px">
  <div style="font-size:11px;font-weight:700;color:var(--primary-navy);margin-bottom:4px">▸ 모멘트 · 극한하중 · 허용하중</div>
  <div style="font-size:11px">$M_y = \\frac{H}{2\\beta} = \\frac{${fmt(r.H_disp)}}{2 \\times ${fmt(r.beta,6)}} = ${fmt(r.My_case1)}$ kN·m</div>
  <div style="font-size:11px;margin-top:6px">${r.pileClass === '긴말뚝' ?
    `긴말뚝 공식: $H_u = 2.38 \\left(\\frac{M_y}{K_p \\gamma D^4}\\right)^{2/3} K_p \\gamma D^3$<br>
    $= 2.38 \\left(\\frac{${fmt(r.My_case1)}}{${fmt(r.Kp,3)} \\times ${r.gamma_top} \\times ${fmt(r.D,4)}^4}\\right)^{2/3} \\times ${fmt(r.Kp,3)} \\times ${r.gamma_top} \\times ${fmt(r.D,4)}^3 = ${fmt(r.Hu_brom1)}$ kN` :
    r.pileClass === '짧은말뚝' ?
    `짧은말뚝 공식: $H_u = 1.5 K_p \\gamma D L^2 = 1.5 \\times ${fmt(r.Kp,3)} \\times ${r.gamma_top} \\times ${fmt(r.D,4)} \\times ${fmt(r.pileLength)}^2 = ${fmt(r.Hu_brom1)}$ kN` :
    `중간말뚝 보간법 적용: $H_u = ${fmt(r.Hu_brom1)}$ kN`}</div>
  <div style="font-size:12px;font-weight:700;margin-top:6px;color:var(--status-pass)">$H_a = \\frac{H_u}{2.5} = \\frac{${fmt(r.Hu_brom1)}}{2.5} = ${fmt(r.Ha_brom1)}$ kN</div>
  </div></div>`;

  // ── Step 4: Brom Case-2 ──
  html += `<div class="report-section"><div class="report-title">Step 4. Brom 방법 — Case-2 (항복 응력)</div>
  <div style="padding:10px;background:#f8f9fa;border-radius:6px;margin-bottom:8px">
  <div style="font-size:11px">$\\sigma_{max} = ${STATE.sigmaMax}$ kN/m² ${isPHC?'(PHC 허용압축응력)':'(강관 항복응력)'}</div>
  <div style="font-size:11px;margin-top:4px">$Z_p = I / (D/2) = ${fmtE(r.I_h)} / ${fmt(r.D/2,4)} = ${fmtE(r.Zp_h)}$ m³</div>
  <div style="font-size:11px;margin-top:4px">$M_y = Z_p \\times \\sigma_{max} = ${fmtE(r.Zp_h)} \\times ${STATE.sigmaMax} = ${fmt(r.My_case2)}$ kN·m</div>
  <div style="font-size:11px;margin-top:6px">${r.pileClass === '긴말뚝' ?
    `긴말뚝: $H_u = 2.38 \\left(\\frac{M_y}{K_p \\gamma D^4}\\right)^{2/3} K_p \\gamma D^3$<br>
    $= 2.38 \\left(\\frac{${fmt(r.My_case2)}}{${fmt(r.Kp,3)} \\times ${r.gamma_top} \\times ${fmt(r.D,4)}^4}\\right)^{2/3} \\times ${fmt(r.Kp,3)} \\times ${r.gamma_top} \\times ${fmt(r.D,4)}^3 = ${fmt(r.Hu_brom2)}$ kN` :
    `$H_u = ${fmt(r.Hu_brom2)}$ kN (Case-1 동일 적용)`}</div>
  <div style="font-size:12px;font-weight:700;margin-top:6px;color:var(--status-pass)">$H_a = \\frac{H_u}{2.5} = \\frac{${fmt(r.Hu_brom2)}}{2.5} = ${fmt(r.Ha_brom2)}$ kN</div>
  </div>
  <div style="padding:8px 12px;background:#e3f2fd;border-radius:6px">
  <div style="font-size:11px;font-weight:700">Brom 최종: $H_a = \\min(${fmt(r.Ha_brom1)},\\; ${fmt(r.Ha_brom2)}) = ${fmt(r.Ha_brom)}$ kN</div>
  </div></div>`;

  // ── Step 5: Chang ──
  html += `<div class="report-section"><div class="report-title">Step 5. Chang 방법</div>
  <div style="padding:10px;background:#f8f9fa;border-radius:6px;margin-bottom:8px">
  <div style="margin:6px 0">$$H_a = \\frac{\\delta \\cdot K_h \\cdot D}{\\beta} = \\frac{${fmt(STATE.delta_cm/100,4)} \\times ${fmt(r.Kh_min,1)} \\times ${fmt(r.D,4)}}{${fmt(r.beta,6)}}$$</div>
  <div style="font-size:12px;font-weight:800;color:var(--status-pass)">$$= ${fmt(r.Ha_chang)} \\text{ kN}$$</div>
  </div></div>`;

  // ── Step 6: 종합 ──
  html += `<div class="report-section"><div class="report-title">Step 6. 수평지지력 종합 비교</div>
  <table><thead><tr><th>방법</th><th>Ha (kN)</th><th>비고</th></tr></thead><tbody>
  <tr><td class="left">Brom Case-1 (변위 제한)</td><td style="font-weight:700">${fmt(r.Ha_brom1)}</td><td class="left">δ=${STATE.delta_cm}cm 기반</td></tr>
  <tr><td class="left">Brom Case-2 (항복 응력)</td><td style="font-weight:700">${fmt(r.Ha_brom2)}</td><td class="left">σmax=${STATE.sigmaMax} kN/m²</td></tr>
  <tr><td class="left">Brom (최솟값)</td><td style="font-weight:800">${fmt(r.Ha_brom)}</td><td class="left">min(Case-1, Case-2)</td></tr>
  <tr><td class="left">Chang</td><td style="font-weight:700">${fmt(r.Ha_chang)}</td><td></td></tr>
  </tbody></table>
  <div style="margin-top:10px;padding:12px;background:#e3f2fd;border-radius:6px;text-align:center">
  <div style="font-size:14px;font-weight:800;color:var(--primary-navy)">$$H_{a,적용} = \\min(${fmt(r.Ha_brom)},\\; ${fmt(r.Ha_chang)}) = ${fmt(r.Ha_applied)} \\text{ kN}$$</div>
  <div style="font-size:11px;color:var(--text-secondary);margin-top:4px">${r.Ha_applied === r.Ha_brom ? '→ Brom 방법이 지배' : '→ Chang 방법이 지배'}</div>
  </div></div>`;

  el.innerHTML = html;
  if (window.MathJax && MathJax.typesetPromise) MathJax.typesetPromise([el]).catch(function(e){});
}

// ===== PULL-OUT TAB =====
function renderPulloutTab() {
  const el = document.getElementById('tab-pullout');
  const r = STATE.result;
  if (!r) { el.innerHTML = '<p style="color:var(--text-muted)">계산 결과가 없습니다.</p>'; return; }
  const isPHC = STATE.pileType === "PHC";
  let html = `<h3 class="sec-title">인발 저항력 산정</h3>`;

  // ── 공식 ──
  html += `<div class="report-section"><div class="report-title">Step 1. 인발 저항력 산정</div>
  <div style="margin:10px 0">$$Q_{pull} = \\frac{Q_{u,skin}}{FS} + W_p$$</div>

  <div style="padding:10px;background:#f8f9fa;border-radius:6px;margin-bottom:10px">
  <div style="font-size:11px;font-weight:700;color:var(--primary-navy);margin-bottom:6px">▸ 주면마찰력 (Qu,skin)</div>
  <div style="font-size:11px">수직지지력 산정에서 구한 주면마찰력 합계를 사용합니다.</div>
  <table style="margin-top:6px"><thead><tr><th>지층</th><th>분류</th><th>두께(m)</th><th>N</th><th>As(m²)</th><th>사질토: 2NAs</th><th>점성토: 6.25NAc</th></tr></thead><tbody>`;
  r.processedLayers.forEach(function(l) {
    const cN = Math.min(l.avgN, 30);
    const elT = r.groundEL != null ? fmt(r.groundEL - l.depthFrom, 2) : '-';
    const elB = r.groundEL != null ? fmt(r.groundEL - l.depthTo, 2) : '-';
    html += `<tr${l.truncated ? ' style="background:#fff8e1"' : ''}>
    <td class="left">${l.soilType}</td>
    <td><span class="soil-badge ${l.soilClass}">${l.soilClass}</span></td>
    <td style="white-space:nowrap"><span style="font-size:10px;color:#495057">EL.${elT}~${elB}</span><br><strong>${fmt(l.thickness)}</strong>${l.truncated?'<span style="color:#c62828;font-size:9px">(절단)</span>':''}</td><td>${fmt(l.avgN,1)}</td>
    <td>$${fmt(r.U,4)} \\times ${fmt(l.thickness)} = ${fmt(l.As,3)}$</td>
    <td>${l.soilClass==='sand'?`$2 \\times ${fmt(cN,1)} \\times ${fmt(l.As,3)} = ${fmt(l.skinFriction_sand)}$`:'-'}</td>
    <td>${l.soilClass==='clay'?`$6.25 \\times ${fmt(cN,1)} \\times ${fmt(l.As,3)} = ${fmt(l.skinFriction_clay)}$`:'-'}</td>
    </tr>`;
  });
  html += `<tr style="background:#e8eaf6;font-weight:700"><td class="left" colspan="4">합계</td><td></td><td>${fmt(r.sum_2NsAs)} kN</td><td>${fmt(r.sum_625NcAc)} kN</td></tr>`;
  html += `</tbody></table>
  <div style="font-size:12px;font-weight:700;margin-top:8px">$Q_{u,skin} = \\Sigma 2N_sA_s + \\Sigma 6.25N_cA_c = ${fmt(r.sum_2NsAs)} + ${fmt(r.sum_625NcAc)} = ${fmt(r.Qu_skin)}$ kN</div>
  </div>

  <div style="padding:10px;background:#f8f9fa;border-radius:6px;margin-bottom:10px">
  <div style="font-size:11px;font-weight:700;color:var(--primary-navy);margin-bottom:6px">▸ 말뚝 유효자중 (Wp)</div>
  <div style="font-size:11px">단위중량: $W_{unit} = ${fmt(r.W_unit,2)}$ kN/m</div>
  <div style="font-size:11px;margin-top:4px">지하수위 EL: $GWL = GL - ${fmt(STATE.gwlDepth,2)} = ${fmt(STATE.groundEL,2)} - ${fmt(STATE.gwlDepth,2)} = EL.${fmt(r.gwlEL,2)}$ m</div>
  <div style="font-size:11px;margin-top:4px">지하수위 위 길이: $l_1 = \\max(EL_{top} - EL_{GWL},\\; 0) = \\max(${fmt(STATE.pileTopEL,2)} - ${fmt(r.gwlEL,2)},\\; 0) = ${fmt(r.l1)}$ m</div>
  <div style="font-size:11px">지하수위 아래 길이: $l_2 = L - l_1 = ${fmt(r.pileLength)} - ${fmt(r.l1)} = ${fmt(r.l2)}$ m</div>
  <div style="font-size:11px;margin-top:6px">$W_p = W_{unit} \\times L - A_p \\times l_2 \\times \\gamma_w$</div>
  <div style="font-size:11px">$= ${fmt(r.W_unit,2)} \\times ${fmt(r.pileLength)} - ${fmt(r.Ap_tip,4)} \\times ${fmt(r.l2)} \\times 10$</div>
  <div style="font-size:11px">$= ${fmt(r.W_unit*r.pileLength,2)} - ${fmt(r.Ap_tip*r.l2*10,2)}$</div>
  <div style="font-size:12px;font-weight:700;margin-top:4px">$W_p = ${fmt(r.Wp)}$ kN ${r.Wp<0?'→ max(Wp, 0) = 0 kN 적용':''}</div>
  </div>

  <div style="padding:12px;background:#e8f5e9;border-radius:6px;border:1px solid #a5d6a7">
  <div style="font-size:11px;font-weight:700">최종 인발 저항력:</div>
  <div style="font-size:11px;margin-top:4px">$Q_{pull} = \\frac{Q_{u,skin}}{FS} + W_p = \\frac{${fmt(r.Qu_skin)}}{${r.FS}} + ${fmt(Math.max(r.Wp,0))}$</div>
  <div style="font-size:11px">$= ${fmt(r.Qu_skin/r.FS)} + ${fmt(Math.max(r.Wp,0))}$</div>
  <div style="font-size:14px;font-weight:800;color:var(--status-pass);margin-top:6px">$$\\therefore Q_{pull} = ${fmt(r.Qpull)} \\text{ kN}$$</div>
  </div></div>`;

  el.innerHTML = html;
  if (window.MathJax && MathJax.typesetPromise) MathJax.typesetPromise([el]).catch(function(e){});
}

// ===== SETTLEMENT TAB =====
function renderSettlementTab() {
  const el = document.getElementById('tab-settlement');
  const r = STATE.result;
  if (!r) { el.innerHTML = '<p style="color:var(--text-muted)">계산 결과가 없습니다.</p>'; return; }
  const ok = r.St < 25;
  let html = `<h3 class="sec-title">침하량 검토 (Vesic, 1977)</h3>`;

  // ── 공식 ──
  html += `<div class="report-section"><div class="report-title">Step 1. 침하량 산정</div>
  <div style="margin:10px 0">$$S_t = S_s + S_p + S_{ps}$$</div>
  <div style="font-size:11px;color:var(--text-secondary);margin-bottom:10px">$S_s$: 축방향 압축침하 | $S_p$: 선단부 하중침하 | $S_{ps}$: 주면부 하중침하</div>

  <div style="padding:10px;background:#f8f9fa;border-radius:6px;margin-bottom:10px">
  <div style="font-size:11px;font-weight:700;color:var(--primary-navy);margin-bottom:6px">▸ 하중 분배</div>
  <div style="font-size:11px">극한지지력: $Q_u = ${fmt(r.Qu)}$ kN</div>
  <div style="font-size:11px">선단 극한: $Q_{u,tip} = ${fmt(r.Qu_tip)}$ kN</div>
  <div style="font-size:11px;margin-top:4px">선단 분담비: $\\alpha_{tip} = Q_{u,tip}/Q_u = ${fmt(r.Qu_tip)}/${fmt(r.Qu)} = ${fmt(r.ratio_tip,3)}$</div>
  <div style="font-size:11px;margin-top:4px">허용지지력: $Q_a = ${fmt(r.Qa_applied)}$ kN</div>
  <div style="font-size:11px">선단 분담하중: $Q_{ps} = Q_a \\times \\alpha_{tip} = ${fmt(r.Qa_applied)} \\times ${fmt(r.ratio_tip,3)} = ${fmt(r.Qps)}$ kN</div>
  <div style="font-size:11px">주면 분담하중: $Q_{fs} = Q_a \\times (1 - \\alpha_{tip}) = ${fmt(r.Qa_applied)} \\times ${fmt(1-r.ratio_tip,3)} = ${fmt(r.Qfs)}$ kN</div>
  </div>

  <div style="padding:10px;background:#f8f9fa;border-radius:6px;margin-bottom:10px">
  <div style="font-size:11px;font-weight:700;color:var(--primary-navy);margin-bottom:6px">▸ 축방향 압축침하 (Ss)</div>
  <div style="font-size:11px">$$S_s = \\frac{(Q_{ps} + 0.67 Q_{fs}) \\times L}{A_n \\times E} \\times 1000$$</div>
  <div style="font-size:11px;margin-top:4px">$= \\frac{(${fmt(r.Qps)} + 0.67 \\times ${fmt(r.Qfs)}) \\times ${fmt(r.pileLength)}}{${fmt(r.Ap_net,4)} \\times ${(r.E).toFixed(0)}} \\times 1000$</div>
  <div style="font-size:11px">$= \\frac{(${fmt(r.Qps)} + ${fmt(0.67*r.Qfs)}) \\times ${fmt(r.pileLength)}}{${fmt(r.Ap_net,4)} \\times ${(r.E).toFixed(0)}} \\times 1000$</div>
  <div style="font-size:11px">$= \\frac{${fmt(r.Qps+0.67*r.Qfs)} \\times ${fmt(r.pileLength)}}{${fmt(r.Ap_net*r.E,0)}} \\times 1000$</div>
  <div style="font-size:12px;font-weight:700;margin-top:4px">$S_s = ${fmt(r.Ss)}$ mm</div>
  </div>

  <div style="padding:10px;background:#f8f9fa;border-radius:6px;margin-bottom:10px">
  <div style="font-size:11px;font-weight:700;color:var(--primary-navy);margin-bottom:6px">▸ 선단부 하중에 의한 침하 (Sp)</div>
  <div style="font-size:11px">$$S_p = \\frac{Q_{ps} \\times C_p}{D \\times q_p} \\times 1000$$</div>
  <div style="font-size:11px;margin-top:4px">경험상수: $C_p = ${r.Cp}$</div>
  <div style="font-size:11px">선단 극한응력: $q_p = Q_{u,tip}/A_p = ${fmt(r.Qu_tip)}/${fmt(r.Ap_tip,4)} = ${fmt(r.qp,1)}$ kN/m²</div>
  <div style="font-size:11px;margin-top:4px">$S_p = \\frac{${fmt(r.Qps)} \\times ${r.Cp}}{${fmt(r.D,4)} \\times ${fmt(r.qp,1)}} \\times 1000$</div>
  <div style="font-size:11px">$= \\frac{${fmt(r.Qps*r.Cp,4)}}{${fmt(r.D*r.qp,2)}} \\times 1000$</div>
  <div style="font-size:12px;font-weight:700;margin-top:4px">$S_p = ${fmt(r.Sp)}$ mm</div>
  </div>

  <div style="padding:10px;background:#f8f9fa;border-radius:6px;margin-bottom:10px">
  <div style="font-size:11px;font-weight:700;color:var(--primary-navy);margin-bottom:6px">▸ 주면부 하중에 의한 침하 (Sps)</div>
  <div style="font-size:11px">$$S_{ps} = \\frac{Q_{fs} \\times C_s}{L \\times q_p} \\times 1000$$</div>
  <div style="font-size:11px;margin-top:4px">$C_s = (0.93 + 0.16\\sqrt{L/D}) \\times C_p$</div>
  <div style="font-size:11px">$= (0.93 + 0.16\\sqrt{${fmt(r.pileLength)}/${fmt(r.D,4)}}) \\times ${r.Cp}$</div>
  <div style="font-size:11px">$= (0.93 + 0.16 \\times ${fmt(Math.sqrt(r.pileLength/r.D),2)}) \\times ${r.Cp}$</div>
  <div style="font-size:11px">$= ${fmt(0.93+0.16*Math.sqrt(r.pileLength/r.D),4)} \\times ${r.Cp} = ${fmt(r.Cs,4)}$</div>
  <div style="font-size:11px;margin-top:4px">$S_{ps} = \\frac{${fmt(r.Qfs)} \\times ${fmt(r.Cs,4)}}{${fmt(r.pileLength)} \\times ${fmt(r.qp,1)}} \\times 1000$</div>
  <div style="font-size:11px">$= \\frac{${fmt(r.Qfs*r.Cs,4)}}{${fmt(r.pileLength*r.qp,2)}} \\times 1000$</div>
  <div style="font-size:12px;font-weight:700;margin-top:4px">$S_{ps} = ${fmt(r.Sps,3)}$ mm</div>
  </div></div>`;

  // ── 최종 판정 ──
  html += `<div class="report-section"><div class="report-title">Step 2. 침하량 판정</div>
  <div style="padding:12px;background:${ok?'#e8f5e9':'#ffebee'};border-radius:6px;border:1px solid ${ok?'#a5d6a7':'#ef9a9a'}">
  <div style="font-size:11px;margin-bottom:4px">$S_t = S_s + S_p + S_{ps}$</div>
  <div style="font-size:11px">$= ${fmt(r.Ss)} + ${fmt(r.Sp)} + ${fmt(r.Sps,3)}$</div>
  <div style="font-size:14px;font-weight:800;color:${ok?'var(--status-pass)':'var(--status-fail)'};margin-top:6px">$$S_t = ${fmt(r.St)} \\text{ mm}$$</div>
  <div style="font-size:12px;font-weight:700;color:${ok?'var(--status-pass)':'var(--status-fail)'};margin-top:4px">판정: ${fmt(r.St)} mm ${ok ? '< 25 mm → OK ✓' : '≥ 25 mm → NG ✗'}</div>
  <div style="font-size:10px;color:var(--text-secondary);margin-top:4px">허용 침하량 기준: 25 mm (KDS 11 50 40)</div>
  </div></div>`;

  el.innerHTML = html;
  if (window.MathJax && MathJax.typesetPromise) MathJax.typesetPromise([el]).catch(function(e){});
}

// ===== SUMMARY TAB =====
function renderSummaryTab() {
  const r = STATE.result;
  if (!r) { document.getElementById('tab-summary').innerHTML = '<p style="color:var(--text-muted)">계산 결과가 없습니다.</p>'; return; }
  const isPHC = STATE.pileType === "PHC";
  const ok = r.St < 25;
  let html = `<h3 class="sec-title">지지력 종합</h3>
  <div class="spec-card ${isPHC?'phc':'steel'}" style="margin-bottom:14px">
    <div class="form-grid cols-3" style="font-size:11px">
      <div>Pile: <strong>${isPHC?`PHC ${STATE.phcGrade}`:'Steel'} D${STATE.diameter_mm}x${STATE.thickness_mm}t</strong></div>
      <div>BH: <strong>${STATE.boreholeNo}</strong></div>
      <div>L: <strong>${fmt(r.pileLength)} m</strong></div>
    </div>
    ${!isPHC && r.rockCalcDetails ? `<div style="margin-top:6px;font-size:10px;color:var(--text-secondary)">Rock: qu=${fmt(r.rockCalcDetails.qu_lab)}kPa | Corr=${STATE.corrosionThk}mm | Pu(min)=${fmt(r.rockCalcDetails.Pu_selected)}kN</div>` : ''}
  </div>
  <div class="summary-cards">
    <div class="summary-card" style="border-color:var(--primary-navy)"><div class="sc-label">수직지지력</div><div class="sc-value" style="color:var(--primary-navy)">${fmt(r.Qa_applied)}</div><div class="sc-unit">kN/본</div></div>
    <div class="summary-card" style="border-color:var(--accent-coral)"><div class="sc-label">수평지지력</div><div class="sc-value" style="color:var(--accent-coral)">${fmt(r.Ha_applied)}</div><div class="sc-unit">kN/본</div></div>
    <div class="summary-card" style="border-color:var(--accent-green)"><div class="sc-label">인발 저항력</div><div class="sc-value" style="color:var(--accent-green)">${fmt(r.Qpull)}</div><div class="sc-unit">kN/본</div></div>
  </div>
  <table><thead><tr><th>구분</th><th>수직(kN)</th><th>수평(kN)</th><th>인발(kN)</th><th>침하(mm)</th></tr></thead><tbody>
  <tr><td class="left" style="font-weight:600">${isPHC?`PHC ${STATE.phcGrade}`:'Steel'} D${STATE.diameter_mm}x${STATE.thickness_mm}t</td>
  <td style="font-weight:700;color:var(--primary-navy)">${fmt(r.Qa_applied)}</td>
  <td style="font-weight:700;color:var(--accent-coral)">${fmt(r.Ha_applied)}</td>
  <td style="font-weight:700;color:var(--accent-green)">${fmt(r.Qpull)}</td>
  <td style="font-weight:700;color:${ok?'var(--status-pass)':'var(--status-fail)'}">${fmt(r.St)} ${ok?'OK':'NG'}</td></tr>
  </tbody></table>
  <div class="result-bar ${ok?'ok':'ng'}"><span class="rb-label">Settlement: ${fmt(r.Ss)}+${fmt(r.Sp)}+${fmt(r.Sps,3)}</span><span class="rb-val">${fmt(r.St)} mm ${ok?'OK':'NG'}</span></div>
  <div id="svgArea" style="margin-top:16px"></div>
  <div style="margin-top:16px;padding:8px 12px;background:#f1f5f9;border-radius:5px;font-size:10px;color:#64748b;line-height:1.4">
    <strong>Ref:</strong> KDS 11 50 40 (2018) | Road Bridge (2008) | Geotechnical Society (1996)${!isPHC?' | Goodman (1980) | Canadian FEM':''}
  </div>
  <div style="margin-top:14px;display:flex;gap:8px">
    <button class="ai-btn" onclick="runAIReview()" style="padding:8px 18px;font-size:11px">&#9889; AI 설계 검토</button>
    <button class="ai-btn" onclick="generateAIReport()" style="padding:8px 18px;font-size:11px;background:linear-gradient(135deg,#059669,#10b981)">&#128203; AI 보고서 생성</button>
    <button class="ai-btn" onclick="openChatPanel()" style="padding:8px 18px;font-size:11px;background:linear-gradient(135deg,#4f46e5,#7c3aed)">&#128172; AI 채팅</button>
  </div>`;
  document.getElementById('tab-summary').innerHTML = html;
  drawSVGDesign();
}

// ===== SVG Design Drawing =====
function drawSVGDesign() {
  const r = STATE.result;
  if (!r) return;
  const container = document.getElementById('svgArea');
  if (!container) return;
  const maxDepth = STATE.sptData.length > 0 ? Math.max(...STATE.sptData.map(s => s.depth)) + 2 : 15;
  const W = 900, margin = { top: 80, left: 60, bottom: 40 };
  const H = Math.max(500, maxDepth * 28 + margin.top + margin.bottom);
  const scale = (H - margin.top - margin.bottom) / maxDepth;
  const colX = { depth: 0, strat: 70, nval: 230, cap: 410, info: 580 };
  const colW = { depth: 60, strat: 150, nval: 170, cap: 160, info: 200 };

  let svg = `<svg xmlns="http://www.w3.org/2000/svg" width="${W}" height="${H}" viewBox="0 0 ${W} ${H}" style="font-family:'Noto Sans KR',sans-serif">`;
  // Header
  svg += `<defs><linearGradient id="hg" x1="0" y1="0" x2="1" y2="0"><stop offset="0%" stop-color="#1e3a5f"/><stop offset="100%" stop-color="#2c5282"/></linearGradient></defs>`;
  svg += `<rect x="0" y="0" width="${W}" height="60" fill="url(#hg)"/>`;
  svg += `<text x="20" y="28" fill="#fff" font-size="15" font-weight="700">시추주상도 및 말뚝 설계 현황</text>`;
  svg += `<text x="20" y="48" fill="#90caf9" font-size="13" font-weight="600">${STATE.boreholeNo}</text>`;
  svg += `<text x="${W-20}" y="28" fill="#b0bec5" font-size="10" text-anchor="end">GL: EL.${fmt(STATE.groundEL,1)}m | Pile: ${STATE.pileType==='PHC'?`PHC ${STATE.phcGrade}`:'Steel'} D${STATE.diameter_mm}</text>`;
  // Column headers
  const chy = 68;
  svg += `<rect x="0" y="60" width="${W}" height="20" fill="#f8f9fa" stroke="#ddd"/>`;
  svg += `<text x="${margin.left + colX.depth + colW.depth/2}" y="${chy}" font-size="9" font-weight="600" text-anchor="middle" fill="#455A64">깊이/표고</text>`;
  svg += `<text x="${margin.left + colX.strat + colW.strat/2}" y="${chy}" font-size="9" font-weight="600" text-anchor="middle" fill="#455A64">시추주상도</text>`;
  svg += `<text x="${margin.left + colX.nval + colW.nval/2}" y="${chy}" font-size="9" font-weight="600" text-anchor="middle" fill="#455A64">N값 (0~50)</text>`;
  svg += `<text x="${margin.left + colX.cap + colW.cap/2}" y="${chy}" font-size="9" font-weight="600" text-anchor="middle" fill="#455A64">누적 지지력</text>`;
  svg += `<text x="${margin.left + colX.info + colW.info/2}" y="${chy}" font-size="9" font-weight="600" text-anchor="middle" fill="#455A64">설계 정보</text>`;

  // Depth marks
  const interval = maxDepth > 20 ? 5 : maxDepth > 10 ? 2 : 1;
  for (let d = 0; d <= maxDepth; d += interval) {
    const y = margin.top + d * scale;
    svg += `<line x1="${margin.left}" y1="${y}" x2="${W-20}" y2="${y}" stroke="#ddd" stroke-width="0.5"/>`;
    svg += `<text x="${margin.left + 5}" y="${y+4}" font-size="9" fill="#455A64" font-weight="600">GL-${d}m</text>`;
    svg += `<text x="${margin.left + 5}" y="${y+14}" font-size="8" fill="#888">EL.${fmt(STATE.groundEL - d, 1)}</text>`;
  }

  // Stratigraphy
  let cumD = 0;
  STATE.layers.forEach(l => {
    const y1 = margin.top + cumD * scale;
    const h = l.thickness * scale;
    const color = getSoilColor(l.soilType);
    svg += `<rect x="${margin.left + colX.strat}" y="${y1}" width="${colW.strat}" height="${h}" fill="${color}" stroke="#888" rx="2"/>`;
    if (h > 14) svg += `<text x="${margin.left + colX.strat + 5}" y="${y1 + h/2 + 4}" font-size="9" font-weight="600" fill="rgba(0,0,0,0.7)">${l.soilType}</text>`;
    cumD += l.thickness;
  });

  // N-value bars
  STATE.sptData.forEach(s => {
    const y = margin.top + s.depth * scale;
    const nCapped = Math.min(s.N, 50);
    const barW = (nCapped / 50) * colW.nval * 0.85;
    const isRefusal = s.N >= 50;
    svg += `<rect x="${margin.left + colX.nval + 5}" y="${y - 5}" width="${Math.max(barW, 3)}" height="10" fill="${isRefusal ? '#2E7D32' : '#1976d2'}" rx="1"/>`;
    svg += `<text x="${margin.left + colX.nval + barW + 10}" y="${y + 3}" font-size="8" font-weight="700" fill="${isRefusal ? '#2E7D32' : '#1976d2'}">${s.N}</text>`;
  });

  // Cumulative capacity line
  let cumCap = 0;
  const maxCap = r.Qu || 1;
  const capPoints = [];
  r.processedLayers.forEach((l, i) => {
    const startD = l.depthFrom != null ? l.depthFrom : 0;
    cumCap += l.skinFriction_sand + l.skinFriction_clay;
    capPoints.push({ d: l.depthTo != null ? l.depthTo : (startD + l.thickness), cap: cumCap });
  });
  capPoints.unshift({ d: 0, cap: 0 });
  if (capPoints.length > 1) {
    const pts = capPoints.map(p => `${margin.left + colX.cap + 10 + (p.cap / maxCap) * (colW.cap - 20)},${margin.top + p.d * scale}`).join(' ');
    svg += `<polyline points="${pts}" fill="none" stroke="#e94560" stroke-width="2"/>`;
    capPoints.forEach(p => {
      if (p.cap > 0) svg += `<circle cx="${margin.left + colX.cap + 10 + (p.cap / maxCap) * (colW.cap - 20)}" cy="${margin.top + p.d * scale}" r="3" fill="#e94560"/>`;
    });
  }

  // Design info
  const infoX = margin.left + colX.info + 5;
  let infoY = margin.top + 15;
  const infoLines = [
    `Qa(V): ${fmt(r.Qa_applied)} kN`, `Ha(H): ${fmt(r.Ha_applied)} kN`, `Qpull: ${fmt(r.Qpull)} kN`,
    `St: ${fmt(r.St)} mm ${r.St<25?'OK':'NG'}`, `L: ${fmt(r.pileLength)} m`, `FS: ${r.FS}`
  ];
  infoLines.forEach(line => {
    svg += `<text x="${infoX}" y="${infoY}" font-size="9" fill="#455A64">${line}</text>`;
    infoY += 16;
  });

  svg += `</svg>`;
  container.innerHTML = `<div class="svg-container">${svg}</div>`;
}

// ===== LOG PANEL RENDERING =====
function renderLogPanel() {
  const maxDepth = STATE.sptData.length > 0 ? Math.max(...STATE.sptData.map(s => s.depth)) + 1 : 10;
  const availH = window.innerHeight - 280;
  const pxPerM = Math.max(25, Math.min(40, availH / maxDepth));
  const totalH = maxDepth * pxPerM;

  // Header
  document.getElementById('panelTitle').textContent = STATE.boreholeNo;
  const gwlEL = STATE.groundEL - STATE.gwlDepth;
  document.getElementById('panelMeta').innerHTML = `
    <div><span class="pm-label">지반고: </span><span class="pm-value">EL.${fmt(STATE.groundEL,1)}m</span></div>
    <div><span class="pm-label">시추깊이: </span><span class="pm-value">${STATE.sptData.length > 0 ? fmt(Math.max(...STATE.sptData.map(s=>s.depth)),1) : '-'}m</span></div>
    <div><span class="pm-label">지하수위: </span><span class="pm-value">GL-${fmt(STATE.gwlDepth,1)}m</span></div>
    <div><span class="pm-label">지지층 EL: </span><span class="pm-value" style="color:#FFCC80">EL.${fmt(STATE.bearingEL,1)}m</span></div>
    <div><span class="pm-label">선단 EL: </span><span class="pm-value" style="color:#FF8A65">EL.${fmt(STATE.bearingEL - STATE.embedDepth,1)}m</span></div>`;

  // Legend
  const legendSoils = [...new Set(STATE.layers.map(l => l.soilType))];
  document.getElementById('panelLegend').innerHTML = legendSoils.map(s => `<div class="pl-item"><div class="pl-swatch" style="background:${getSoilColor(s)}"></div>${s}</div>`).join('');

  // Body: 3 columns
  let bodyHTML = `<div class="panel-columns">`;
  // Col headers
  bodyHTML += `<div class="panel-col-header">깊이</div><div class="panel-col-header">지층</div><div class="panel-col-header">N값</div>`;

  // Depth column
  bodyHTML += `<div style="position:relative;height:${totalH}px">`;
  const dInterval = maxDepth > 20 ? 5 : maxDepth > 10 ? 2 : 1;
  for (let d = 0; d <= maxDepth; d += dInterval) {
    const y = d * pxPerM;
    bodyHTML += `<div class="depth-mark ${d % (dInterval*2) === 0 ? 'major' : ''}" style="top:${y}px">GL-${d}m<br><span style="font-size:8px;color:#888">EL.${fmt(STATE.groundEL-d,1)}</span></div>`;
  }
  bodyHTML += `</div>`;

  // Strat column
  bodyHTML += `<div style="position:relative;height:${totalH}px">`;
  let cumDepth = 0;
  STATE.layers.forEach(l => {
    const y = cumDepth * pxPerM;
    const h = Math.max(l.thickness * pxPerM, 20);
    const color = getSoilColor(l.soilType);
    bodyHTML += `<div class="strat-layer" style="top:${y}px;height:${h}px">
      <div class="strat-color-strip" style="background:${color}">${l.soilType.substring(0,3)}</div>
      <div class="strat-info" style="background:linear-gradient(to right,${color}15,#fff)">${l.soilType}<br><span style="font-size:9px;color:#888">N=${l.avgN}</span></div>
    </div>`;
    cumDepth += l.thickness;
  });
  // Water table marker
  if (STATE.gwlDepth < maxDepth) {
    bodyHTML += `<div class="marker-line water" style="top:${STATE.gwlDepth * pxPerM}px"><span class="marker-badge water">GWL</span></div>`;
  }
  // Bearing level marker
  const bearingDepth = STATE.groundEL - (STATE.bearingEL - STATE.embedDepth);
  if (bearingDepth > 0 && bearingDepth < maxDepth) {
    bodyHTML += `<div class="marker-line excavation" style="top:${bearingDepth * pxPerM}px"><span class="marker-badge excavation">선단 EL</span></div>`;
  }
  bodyHTML += `</div>`;

  // N-value column
  bodyHTML += `<div style="position:relative;height:${totalH}px">`;
  // Scale labels
  bodyHTML += `<div style="display:flex;justify-content:space-between;font-size:8px;color:#888;margin-bottom:2px"><span>0</span><span>25</span><span>50</span></div>`;
  STATE.sptData.forEach(s => {
    const y = s.depth * pxPerM - 5;
    const nCapped = Math.min(s.N, 50);
    const barW = (nCapped / 50) * 100;
    const isRefusal = s.N >= 50;
    bodyHTML += `<div class="nval-bar-row" style="top:${y}px">
      <div class="nval-bar ${isRefusal?'refusal':'normal'}" style="width:${Math.max(barW, 3)}%"></div>
      <span class="nval-label ${isRefusal?'refusal':'normal'}">${s.N}</span>
    </div>`;
  });
  bodyHTML += `</div>`;
  bodyHTML += `</div>`; // close panel-columns

  document.getElementById('panelBody').innerHTML = bodyHTML;
}

// ===== VERIFICATION MODAL =====
function renderVerifyModal(type) {
  const vd = type === 'steel' ? VERIFY_DATA.steel : VERIFY_DATA.phc;
  const vResult = calcPile({
    pileType: vd.pileType, diameter_mm: vd.diameter_mm, thickness_mm: vd.thickness_mm,
    phcGrade: vd.phcGrade, pileTopEL: vd.pileTopEL, groundEL: vd.groundEL,
    bearingEL: vd.bearingEL, gwlDepth: vd.gwlDepth, sptData: vd.sptData,
    layers: vd.layers, alpha_kh: vd.alpha_kh || 1, delta_cm: vd.delta_cm || 1.5,
    sigmaMax_kN: vd.sigmaMax, corrosionThickness_mm: vd.corrosionThk || 2,
    qu_kPa: vd.qu_kPa || 32460, Sd_m: vd.Sd_m || 0.15, td_m: vd.td_m || 0.002,
    rockPhi_deg: vd.rockPhi || 35, bearingMethod: vd.bearingMethod, jointCount: vd.jointCount || 1, jointType: vd.jointType || "welding",
    embedDepth: vd.embedDepth || STATE.embedDepth || 1
  });

  const cur = STATE.result;
  let html = `<div class="modal-tabs">
    <button class="modal-tab ${type==='phc'?'active':''}" onclick="renderVerifyModal('phc')">PHC 검증 (NBH-03)</button>
    <button class="modal-tab ${type==='steel'?'active':''}" onclick="renderVerifyModal('steel')">강관 검증 (NBH-09)</button>
  </div>`;

  html += `<div class="verify-compare">
    <div class="verify-col">
      <h3>&#128203; 검증 데이터: ${vd.label}</h3>
      <table><thead><tr><th>항목</th><th>값</th></tr></thead><tbody>
        <tr><td class="left">Pile</td><td>${vd.pileType} D${vd.diameter_mm}x${vd.thickness_mm}t</td></tr>
        <tr><td class="left">Length</td><td>${fmt(vResult.pileLength)} m</td></tr>
        <tr><td class="left">Qa (Vertical)</td><td style="font-weight:700;color:var(--primary-navy)">${fmt(vResult.Qa_applied)} kN</td></tr>
        <tr><td class="left">Ha (Horizontal)</td><td style="font-weight:700;color:var(--accent-coral)">${fmt(vResult.Ha_applied)} kN</td></tr>
        <tr><td class="left">Pull-out</td><td style="font-weight:700;color:var(--accent-green)">${fmt(vResult.Qpull)} kN</td></tr>
        <tr><td class="left">Settlement</td><td style="font-weight:700">${fmt(vResult.St)} mm ${vResult.St<25?'OK':'NG'}</td></tr>
        <tr><td class="left">Qu (극한)</td><td>${fmt(vResult.Qu)} kN</td></tr>
        <tr><td class="left">Qp (재료)</td><td>${fmt(vResult.Qp_material)} kN</td></tr>
        <tr><td class="left">Qa (지반)</td><td>${fmt(vResult.Qa_ground)} kN</td></tr>
        <tr><td class="left">Kh_min</td><td>${fmt(vResult.Kh_min,1)} kN/m3</td></tr>
        <tr><td class="left">Pile Class</td><td>${vResult.pileClass}</td></tr>
      </tbody></table>
      <button class="btn" style="margin-top:10px;width:100%" onclick="applyVerifyData('${type}')">&#8594; 이 데이터를 메인에 적용</button>
    </div>
    <div class="verify-col">
      <h3>&#128200; 현재 계산 결과${cur ? ` (${STATE.boreholeNo})` : ''}</h3>
      ${cur ? `<table><thead><tr><th>항목</th><th>값</th></tr></thead><tbody>
        <tr><td class="left">Pile</td><td>${STATE.pileType} D${STATE.diameter_mm}x${STATE.thickness_mm}t</td></tr>
        <tr><td class="left">Length</td><td>${fmt(cur.pileLength)} m</td></tr>
        <tr><td class="left">Qa (Vertical)</td><td style="font-weight:700;color:var(--primary-navy)">${fmt(cur.Qa_applied)} kN</td></tr>
        <tr><td class="left">Ha (Horizontal)</td><td style="font-weight:700;color:var(--accent-coral)">${fmt(cur.Ha_applied)} kN</td></tr>
        <tr><td class="left">Pull-out</td><td style="font-weight:700;color:var(--accent-green)">${fmt(cur.Qpull)} kN</td></tr>
        <tr><td class="left">Settlement</td><td style="font-weight:700">${fmt(cur.St)} mm ${cur.St<25?'OK':'NG'}</td></tr>
        <tr><td class="left">Qu (극한)</td><td>${fmt(cur.Qu)} kN</td></tr>
        <tr><td class="left">Qp (재료)</td><td>${fmt(cur.Qp_material)} kN</td></tr>
        <tr><td class="left">Qa (지반)</td><td>${fmt(cur.Qa_ground)} kN</td></tr>
        <tr><td class="left">Kh_min</td><td>${fmt(cur.Kh_min,1)} kN/m3</td></tr>
        <tr><td class="left">Pile Class</td><td>${cur.pileClass}</td></tr>
      </tbody></table>` : '<p style="color:var(--text-muted);padding:20px">아직 계산 결과가 없습니다. Input 탭에서 데이터를 입력하세요.</p>'}
    </div>
  </div>`;

  document.getElementById('verifyBody').innerHTML = html;
}

function applyVerifyData(type) {
  const vd = type === 'steel' ? VERIFY_DATA.steel : VERIFY_DATA.phc;
  STATE.pileType = vd.pileType; STATE.diameter_mm = vd.diameter_mm; STATE.thickness_mm = vd.thickness_mm;
  STATE.phcGrade = vd.phcGrade || "A"; STATE.boreholeNo = vd.boreholeNo;
  STATE.groundEL = vd.groundEL; STATE.bearingEL = vd.bearingEL; STATE.pileTopEL = vd.pileTopEL;
  STATE.gwlDepth = vd.gwlDepth; STATE.bearingMethod = vd.bearingMethod; STATE.sigmaMax = vd.sigmaMax;
  STATE.embedDepth = vd.embedDepth || 1;
  STATE.alpha_kh = vd.alpha_kh || 1; STATE.delta_cm = vd.delta_cm || 1.5;
  STATE.corrosionThk = vd.corrosionThk || 2; STATE.qu_kPa = vd.qu_kPa || 32460;
  STATE.Sd_m = vd.Sd_m || 0.15; STATE.td_m = vd.td_m || 0.002; STATE.rockPhi = vd.rockPhi || 35;
  STATE.jointCount = vd.jointCount || 1; STATE.jointType = vd.jointType || "welding";
  STATE.sptData = JSON.parse(JSON.stringify(vd.sptData));
  STATE.layers = JSON.parse(JSON.stringify(vd.layers));
  closeVerifyModal();
  recalculate();
  showToast(`${vd.label} 데이터가 메인에 적용되었습니다`, 'success');
}

function openVerifyModal() {
  document.getElementById('verifyOverlay').classList.add('open');
  renderVerifyModal('phc');
}

// ===== SPT PASTE =====
function openPasteModal() {
  document.getElementById('pasteOverlay').classList.add('open');
  document.getElementById('pasteArea').value = '';
  document.getElementById('pastePreviewArea').style.display = 'none';
  document.getElementById('pasteApplyBtn').disabled = true;
  window._parsedSPTCache = null;
}
function closePasteModal() { document.getElementById('pasteOverlay').classList.remove('open'); }

// ===== SMART SPT PARSER =====

/** 1단계: 행을 열로 분리 (탭 우선, 없으면 공백 기반 스마트 분리) */
function splitRowCols(line) {
  // 탭이 있으면 탭 구분
  if (line.indexOf('\t') >= 0) return line.split('\t').map(c => c.trim());
  // 탭 없으면 공백 분리 후 한글 토큰 병합
  const tokens = line.split(/\s+/).filter(c => c.length > 0);
  // 한글+문자가 이전 토큰에 이어지는 경우 병합 (예: "풍화암 ç" → "풍화암ç", "퇴적층 (SM)" → "퇴적층(SM)")
  const merged = [];
  for (let i = 0; i < tokens.length; i++) {
    const t = tokens[i];
    const prev = merged.length > 0 ? merged[merged.length - 1] : '';
    const prevIsKorean = /[가-힣]/.test(prev);
    const curIsKorean = /[가-힣]/.test(t);
    const curIsParenOrCode = /^[\(\[]/.test(t) || /^[A-Z]{1,3}[\)\]]?$/.test(t);
    // 병합 조건: 이전이 한글이고 현재도 한글/괄호/코드
    if (prevIsKorean && (curIsKorean || curIsParenOrCode)) {
      merged[merged.length - 1] = prev + t;
    } else {
      merged.push(t);
    }
  }
  return merged;
}

/** 2단계: 헤더/단위/빈 행 판별 */
function classifyRow(cols) {
  const joined = cols.join(' ').toLowerCase();
  // 헤더 키워드
  const headerKW = ['no.','el.','el+','depth','깊이','n값','n value','remark','비고','blow','spt,','표고','심도','지층','토질'];
  if (headerKW.some(kw => joined.includes(kw))) return 'header';
  // 단위 행
  const unitKW = ['blow/30cm','blow/30','m/m','kn/m','kg/m','t/m'];
  const unitOnly = cols.filter(c => c.length > 0);
  if (unitOnly.length > 0 && unitOnly.every(c => /^[m\/\s\-\(\)]+$/.test(c) || unitKW.some(u => c.toLowerCase().includes(u)))) return 'unit';
  // 유효 숫자가 2개 미만인 행은 빈 행 처리 (No.만 있는 행 등)
  const validNums = cols.filter(c => /\d/.test(c) && !isNaN(parseFloat(c.replace(/[,]/g,''))));
  if (validNums.length < 2) return 'empty';
  return 'data';
}

/** 3단계: 컬럼 역할 자동 추론 (헤더 행 활용) */
function detectColumnRoles(dataRows, headerRows) {
  if (dataRows.length === 0) return null;
  headerRows = headerRows || [];
  const maxCols = Math.max(...dataRows.map(r => r.length));
  const colStats = [];
  for (let c = 0; c < maxCols; c++) {
    const vals = dataRows.map(r => r[c] || '').filter(v => v.length > 0);
    const nums = vals.map(v => parseFloat(v.replace(/[,]/g,''))).filter(v => !isNaN(v));
    const hasKorean = vals.some(v => /[가-힣]/.test(v));
    const allInt = nums.length > 0 && nums.every(v => Number.isInteger(v));
    const isSequential = nums.length >= 2 && nums.every((v,i) => i === 0 || v >= nums[i-1]);
    const isStrictSeq = nums.length >= 2 && nums.every((v,i) => i === 0 || v === nums[i-1] + 1);
    const avg = nums.length > 0 ? nums.reduce((a,b)=>a+b,0)/nums.length : 0;
    const min = nums.length > 0 ? Math.min(...nums) : 0;
    const max = nums.length > 0 ? Math.max(...nums) : 0;
    // 값들의 변동성 (표준편차/평균)
    const variance = nums.length > 1 ? Math.sqrt(nums.reduce((s,v) => s + (v-avg)*(v-avg), 0) / nums.length) : 0;
    const cv = avg > 0 ? variance / avg : 0; // 변동계수
    colStats.push({ idx: c, nums, hasKorean, allInt, isSequential, isStrictSeq, avg, min, max, total: vals.length, numCount: nums.length, nonNumCount: vals.length - nums.length, cv });
  }

  const roles = new Array(maxCols).fill(null);
  const assigned = new Set();
  const numericCols = colStats.filter(s => s.numCount >= 2);

  // 0) 헤더 키워드 기반 사전 감지 (우선 순위 높음)
  // 데이터 열 수와 가장 일치하는 헤더 행만 사용 (열 수가 다른 헤더는 인덱스 불일치)
  const headerHints = new Array(maxCols).fill('');
  const sortedHeaders = [...headerRows].sort((a,b) => b.length - a.length);
  // 가장 긴 헤더(데이터 열 수와 가까운)를 우선 사용; 열 수가 90% 이상 일치하는 것만
  const bestHeader = sortedHeaders.find(r => r.length >= maxCols * 0.9);
  if (bestHeader) {
    bestHeader.forEach((cell, i) => { if (i < maxCols) headerHints[i] = (cell || '').toLowerCase(); });
  } else if (sortedHeaders.length > 0 && sortedHeaders[0].length === maxCols) {
    sortedHeaders[0].forEach((cell, i) => { if (i < maxCols) headerHints[i] = (cell || '').toLowerCase(); });
  }
  // N값 헤더 키워드: 최종 N값을 나타내는 열 (비고(n1+n2), N값, 합계(n1+n2) 등)
  // "타격수", "1차", "2차", "3차" 등 개별 blow count는 제외
  let headerNIdx = -1;
  const nValueKW = ['n값', 'n1+n2', 'n1 + n2', 'n value', 'spt-n', 'spt n'];
  const sumKW = ['합계'];
  const blowKW = ['타격수', '1차', '2차', '3차', 'blow'];
  for (let c = 0; c < maxCols; c++) {
    const h = headerHints[c];
    // 직접 N값 키워드 매칭
    if (nValueKW.some(kw => h.includes(kw))) { headerNIdx = c; break; }
  }
  // N값 직접 키워드 없으면, "합계" 열 중 "타격수" 블록이 아닌 것 찾기
  if (headerNIdx < 0) {
    for (let c = 0; c < maxCols; c++) {
      const h = headerHints[c];
      if (sumKW.some(kw => h.includes(kw)) && !blowKW.some(kw => h.includes(kw))) {
        // "합계" 열이 타격수 합계가 아닌 최종 N값 합계인지 확인
        // 주변 열에 "타격수" 키워드가 있으면 이건 blow count 합계이므로 스킵
        const nearby = [c-1, c+1].filter(i => i >= 0 && i < maxCols);
        const nearbyIsBlow = nearby.some(i => blowKW.some(kw => headerHints[i].includes(kw)));
        if (!nearbyIsBlow) { headerNIdx = c; break; }
      }
    }
  }

  // 1) Remark: 한글 포함 열 (비숫자 비율 높은)
  const remarkCand = colStats.filter(s => s.hasKorean && s.nonNumCount >= 1);
  if (remarkCand.length > 0) {
    const best = remarkCand.reduce((a,b) => a.nonNumCount > b.nonNumCount ? a : b);
    roles[best.idx] = 'remark'; assigned.add(best.idx);
  }

  // 2) No.: 1,2,3... 정확한 순차 정수열, 첫 번째 값 = 1, 첫 번째 열 우선
  const noCand = numericCols.filter(s => !assigned.has(s.idx) && s.isStrictSeq && s.allInt && s.min === 1);
  if (noCand.length > 0) {
    // 첫 번째 열(idx=0)이 후보에 있으면 그것만 No.로 인정
    const firstCol = noCand.find(s => s.idx === 0);
    if (firstCol) { roles[firstCol.idx] = 'no'; assigned.add(firstCol.idx); }
    // 첫 번째 열이 아니면 No. 지정 안 함 (Depth일 수 있음)
  }

  // 3) EL: 값이 큼 (50~300), 감소 경향, 변동계수 작음
  const elCand = numericCols.filter(s => !assigned.has(s.idx) && s.avg > 50 && s.avg < 300 && s.min > 10);
  if (elCand.length > 0) {
    const decr = elCand.filter(s => s.nums.length >= 2 && s.nums[0] > s.nums[s.nums.length-1]);
    const pool = decr.length > 0 ? decr : elCand;
    const best = pool.reduce((a,b) => Math.abs(a.avg - 130) < Math.abs(b.avg - 130) ? a : b);
    roles[best.idx] = 'el'; assigned.add(best.idx);
  }

  // 4) Depth: 순차 증가, 0~100 범위, 등간격 경향
  const depthCand = numericCols.filter(s => !assigned.has(s.idx) && s.isSequential && s.min >= 0 && s.max <= 100 && s.avg < 60);
  if (depthCand.length > 0) {
    // 등간격성 점수: 인접 차이의 분산이 작을수록 Depth일 가능성 높음
    const best = depthCand.reduce((a,b) => {
      const aDiffs = a.nums.slice(1).map((v,i) => v - a.nums[i]);
      const bDiffs = b.nums.slice(1).map((v,i) => v - b.nums[i]);
      const aVar = aDiffs.length > 0 ? Math.sqrt(aDiffs.reduce((s,v) => { const m = aDiffs.reduce((a2,b2)=>a2+b2,0)/aDiffs.length; return s+(v-m)*(v-m); },0)/aDiffs.length) : 999;
      const bVar = bDiffs.length > 0 ? Math.sqrt(bDiffs.reduce((s,v) => { const m = bDiffs.reduce((a2,b2)=>a2+b2,0)/bDiffs.length; return s+(v-m)*(v-m); },0)/bDiffs.length) : 999;
      // 점수: 등간격(분산 작음) + 첫값 작음 + 변동계수 작음
      const aScore = -aVar * 10 - a.min - a.cv * 5;
      const bScore = -bVar * 10 - b.min - b.cv * 5;
      return aScore >= bScore ? a : b;
    });
    roles[best.idx] = 'depth'; assigned.add(best.idx);
  }

  // 5) N값: 헤더 힌트 우선, 없으면 통계 기반
  if (headerNIdx >= 0 && !assigned.has(headerNIdx)) {
    // 헤더 키워드로 N값 열이 확정된 경우
    const stat = colStats.find(s => s.idx === headerNIdx);
    if (stat && stat.numCount >= 2) {
      roles[headerNIdx] = 'n'; assigned.add(headerNIdx);
    }
  }
  if (!roles.includes('n')) {
    const nCand = numericCols.filter(s => !assigned.has(s.idx) && s.min >= 0 && s.max <= 100);
    if (nCand.length > 0) {
      const best = nCand.reduce((a,b) => {
        // N값 특성: 정수, 비순차적(변동계수 큼), 0~60 범위, 값의 범위가 넓음
        const aRange = a.max - a.min;
        const bRange = b.max - b.min;
        const aScore = (a.allInt ? 10 : 0) + (a.avg <= 50 ? 5 : 0) + (a.cv > 0.3 ? 3 : 0) + (!a.isStrictSeq ? 2 : 0)
          + (aRange > 5 ? 5 : 0) + (a.avg >= 5 ? 3 : 0) + (aRange <= 2 ? -15 : 0);
        const bScore = (b.allInt ? 10 : 0) + (b.avg <= 50 ? 5 : 0) + (b.cv > 0.3 ? 3 : 0) + (!b.isStrictSeq ? 2 : 0)
          + (bRange > 5 ? 5 : 0) + (b.avg >= 5 ? 3 : 0) + (bRange <= 2 ? -15 : 0);
        return aScore >= bScore ? a : b;
      });
      roles[best.idx] = 'n'; assigned.add(best.idx);
    }
  }

  // 2열만 있고 depth/n만 필요한 간단한 케이스
  if (maxCols === 2 && !roles.includes('n')) {
    const unassigned = colStats.filter(s => !assigned.has(s.idx) && s.numCount >= 2);
    if (unassigned.length > 0) { roles[unassigned[0].idx] = 'n'; assigned.add(unassigned[0].idx); }
  }

  // depth 없으면 el에서 역산하므로 OK. 둘 다 없으면 fallback
  if (!roles.includes('depth') && !roles.includes('el')) {
    const fallback = numericCols.filter(s => !assigned.has(s.idx) && s.isSequential);
    if (fallback.length > 0) { roles[fallback[0].idx] = 'depth'; assigned.add(fallback[0].idx); }
  }

  // n이 여전히 없으면 남은 숫자열 중 하나
  if (!roles.includes('n')) {
    const fallback = numericCols.filter(s => !assigned.has(s.idx));
    if (fallback.length > 0) { roles[fallback[0].idx] = 'n'; assigned.add(fallback[0].idx); }
  }

  return { roles, maxCols, colStats };
}

/** 4단계: 데이터 행에서 SPT 레코드 추출 */
function extractSPTRecords(dataRows, detection) {
  const { roles } = detection;
  const depthIdx = roles.indexOf('depth');
  const elIdx = roles.indexOf('el');
  const nIdx = roles.indexOf('n');
  const remarkIdx = roles.indexOf('remark');

  // EL로부터 depth 역산 시 기준 표고 결정
  // EL 열의 최대값을 groundEL 기준으로 사용 (첫 번째 데이터가 최상부)
  let elBase = STATE.groundEL;
  if (elIdx >= 0 && depthIdx < 0) {
    const firstEL = dataRows.find(r => r[elIdx] && !isNaN(parseFloat(r[elIdx])));
    if (firstEL) {
      const depthCol = dataRows.map(r => r[elIdx] ? parseFloat(r[elIdx]) : NaN).filter(v => !isNaN(v));
      if (depthCol.length > 0) elBase = Math.max(...depthCol) + 1; // 최고 표고 + 1m = 지반고 추정
    }
  }

  const records = [];
  dataRows.forEach((cols, rowIdx) => {
    const rawN = nIdx >= 0 && cols[nIdx] ? parseFloat(cols[nIdx].replace(/[,]/g,'')) : NaN;
    if (isNaN(rawN)) return; // N값 없으면 스킵

    let depth = NaN, el = NaN;
    if (depthIdx >= 0 && cols[depthIdx]) depth = parseFloat(cols[depthIdx].replace(/[,]/g,''));
    if (elIdx >= 0 && cols[elIdx]) el = parseFloat(cols[elIdx].replace(/[,]/g,''));

    // depth 없으면 el로부터 역산
    if (isNaN(depth) && !isNaN(el)) {
      depth = elBase - el;
    }
    // 둘 다 없으면 행 번호로 추정 (1m 간격)
    if (isNaN(depth)) depth = rowIdx + 1;
    // depth가 음수이면 보정
    if (depth < 0) depth = Math.abs(depth);

    let remark = remarkIdx >= 0 && cols[remarkIdx] ? cols[remarkIdx].trim() : '';
    // 비정상 문자 제거 후 매핑
    remark = remark.replace(/[^\uAC00-\uD7AF\u3131-\u3163a-zA-Z0-9\(\)\s\-\/]/g, '').trim();
    const mapped = mapSoilName(remark);

    records.push({
      depth: Math.round(depth * 100) / 100,
      N: Math.min(Math.max(Math.round(rawN), 0), 60),
      el: !isNaN(el) ? Math.round(el * 100) / 100 : null,
      remark: mapped || '퇴적층(SM)'
    });
  });

  // depth 기준 정렬
  records.sort((a,b) => a.depth - b.depth);
  return records;
}

/** 전처리: 텍스트 정규화 + 줄바꿈 없는 한 줄 데이터 복원 */
function preprocessPasteText(text) {
  let t = text
    .replace(/\uFF0C/g, ',')       // 전각 쉼표
    .replace(/\uFF0E/g, '.')       // 전각 마침표
    .replace(/[ç©★●◆■□△▲▽▼※\u200B\uFEFF]/g, '') // 비정상/특수문자/ZWS 제거
    .trim();
  // 줄바꿈이 거의 없는 한 줄 데이터인 경우: 행 분리 복원
  const lineCount = (t.match(/\n/g) || []).length;
  const numCount = (t.match(/\d+\.?\d*/g) || []).length;
  if (lineCount < 3 && numCount > 10) {
    // 단위행 키워드 뒤 숫자 → 줄바꿈 (예: 'blow/30cm 1' → 'blow/30cm\n1')
    t = t.replace(/(blow\/30cm|m\/m|kn\/m)\s+(\d)/gi, '$1\n$2');
    // 전각공백(　) 뒤 숫자 → 줄바꿈 (빈 셀 다음 새 행)
    t = t.replace(/\u3000\s*(\d)/g, '\n$1');
    // 한글/괄호 뒤 공백+숫자 → 줄바꿈 (예: '성토층 2' → '성토층\n2')
    t = t.replace(/([가-힣\)]) +(\d)/g, '$1\n$2');
  }
  // 전각 공백 → 반각 (줄바꿈 복원 후 처리)
  t = t.replace(/\u3000/g, ' ');
  return t;
}

/** 메인 파싱 함수: 텍스트 → SPT 레코드 배열 */
function smartParseSPT(text) {
  const cleaned = preprocessPasteText(text);
  if (!cleaned) return { records: [], info: '', headerSkipped: 0, emptySkipped: 0 };

  const rawLines = cleaned.split('\n');
  let headerSkipped = 0, unitSkipped = 0, emptySkipped = 0;
  const dataRows = [];

  const headerRows = [];
  rawLines.forEach(line => {
    const trimmed = line.trim();
    if (!trimmed) { emptySkipped++; return; }
    const cols = splitRowCols(trimmed);
    const cls = classifyRow(cols);
    if (cls === 'header') { headerSkipped++; headerRows.push(cols); return; }
    if (cls === 'unit') { unitSkipped++; return; }
    if (cls === 'empty') { emptySkipped++; return; }
    dataRows.push(cols);
  });

  if (dataRows.length === 0) return { records: [], info: '유효 데이터 없음', headerSkipped, emptySkipped };

  const detection = detectColumnRoles(dataRows, headerRows);
  if (!detection) return { records: [], info: '컬럼 감지 실패', headerSkipped, emptySkipped };

  const records = extractSPTRecords(dataRows, detection);

  // 감지 정보 문자열
  const roleNames = { no: 'No.', el: 'EL', depth: 'Depth', n: 'N값', remark: '비고' };
  const detectedStr = detection.roles.map((r,i) => r ? (i+1) + '열=' + roleNames[r] : null).filter(Boolean).join(', ');
  const info = '컬럼감지: ' + detectedStr + ' | 헤더 ' + headerSkipped + '행, 빈행 ' + emptySkipped + '행 제거';

  return { records, info, headerSkipped, emptySkipped, detection };
}

/** 실시간 미리보기 */
let _previewDebounce = null;
function previewPastedSPT() {
  clearTimeout(_previewDebounce);
  _previewDebounce = setTimeout(() => {
    const text = document.getElementById('pasteArea').value.trim();
    const previewArea = document.getElementById('pastePreviewArea');
    const applyBtn = document.getElementById('pasteApplyBtn');
    if (!text) { previewArea.style.display = 'none'; applyBtn.disabled = true; window._parsedSPTCache = null; return; }

    const result = smartParseSPT(text);
    window._parsedSPTCache = result.records;

    if (result.records.length === 0) {
      previewArea.style.display = 'block';
      document.getElementById('pastePreviewCount').textContent = '유효 데이터 없음';
      document.getElementById('pastePreviewCount').style.color = 'var(--accent-coral)';
      document.getElementById('pasteDetectInfo').textContent = result.info;
      document.getElementById('pastePreviewBody').innerHTML = '<tr><td colspan="5" style="color:var(--text-muted);padding:12px">인식 가능한 SPT 데이터가 없습니다</td></tr>';
      applyBtn.disabled = true;
      return;
    }

    previewArea.style.display = 'block';
    document.getElementById('pastePreviewCount').textContent = result.records.length + '개 SPT 데이터 인식';
    document.getElementById('pastePreviewCount').style.color = 'var(--primary-navy)';
    document.getElementById('pasteDetectInfo').textContent = result.info;

    let tbody = '';
    result.records.forEach((r, i) => {
      tbody += '<tr><td>' + (i+1) + '</td><td>' + r.depth + '</td><td>' + (r.el != null ? r.el : '-') + '</td><td style="font-weight:700">' + r.N + '</td><td>' + r.remark + '</td></tr>';
    });
    document.getElementById('pastePreviewBody').innerHTML = tbody;
    applyBtn.disabled = false;
  }, 200);
}

/** 적용 (미리보기 데이터를 STATE에 반영) */
/** 붙여넣기 적용 시 기존 업로드/다공 데이터를 모두 초기화하고 새 데이터로 완전 대체 */
function clearPreviousData() {
  STATE.uploadedData = null;
  STATE.allResults = new Map();
}

function applyParsedSPT() {
  const records = window._parsedSPTCache;
  if (!records || records.length === 0) { showToast('적용할 데이터가 없습니다', 'warning'); return; }
  clearPreviousData();
  STATE.sptData = records.map(r => ({ depth: r.depth, N: Math.min(r.N, 50), remark: r.remark }));

  // EL 데이터가 있으면 지반고(groundEL) 자동 추정
  // 표시 공식: displayEL = groundEL - depth + 1  ∴ groundEL = EL + depth - 1
  // 첫 번째 유효 레코드 기준 (최상부 데이터가 가장 정확)
  const elRecords = records.filter(r => r.el != null && r.depth > 0);
  if (elRecords.length > 0) {
    const first = elRecords[0];
    const newGroundEL = Math.round((first.el + first.depth - 1) * 100) / 100;
    STATE.groundEL = newGroundEL;
  }

  autoGenerateLayers();
  closePasteModal();
  recalculate();
  const elMsg = elRecords.length > 0 ? ' / 지반고 EL=' + STATE.groundEL + 'm 반영' : '';
  showToast(records.length + '개 SPT 데이터 적용 완료 (기존 데이터 초기화' + elMsg + ')', 'success');
}

// 하위 호환: 기존 parsePastedSPT 호출 시에도 동작
function parsePastedSPT() {
  const text = document.getElementById('pasteArea').value.trim();
  if (!text) { showToast('데이터를 입력하세요', 'warning'); return; }
  const result = smartParseSPT(text);
  if (result.records.length === 0) { showToast('유효한 데이터를 찾을 수 없습니다', 'error'); return; }
  clearPreviousData();
  STATE.sptData = result.records.map(r => ({ depth: r.depth, N: Math.min(r.N, 50), remark: r.remark }));

  // EL 데이터가 있으면 지반고(groundEL) 자동 추정
  const elRecords = result.records.filter(r => r.el != null && r.depth > 0);
  if (elRecords.length > 0) {
    const first = elRecords[0];
    STATE.groundEL = Math.round((first.el + first.depth - 1) * 100) / 100;
  }

  autoGenerateLayers();
  closePasteModal();
  recalculate();
  showToast(result.records.length + '개 SPT 데이터 적용 완료 (기존 데이터 초기화)', 'success');
}

function autoGenerateLayers() {
  if (STATE.sptData.length === 0) return;
  const groups = [];
  let cur = null;
  STATE.sptData.forEach(s => {
    const soil = s.remark || '퇴적층(SM)';
    if (!cur || cur.soilType !== soil) {
      if (cur) cur.depthTo = s.depth - 0.5;
      cur = { soilType: soil, depthFrom: cur ? cur.depthTo : 0, depthTo: s.depth + 0.5, ns: [s.N] };
      groups.push(cur);
    } else { cur.ns.push(s.N); cur.depthTo = s.depth + 0.5; }
  });
  STATE.layers = groups.map(g => ({
    soilType: g.soilType,
    depthFrom: parseFloat(g.depthFrom.toFixed(2)),
    depthTo: parseFloat(g.depthTo.toFixed(2)),
    thickness: parseFloat((g.depthTo - g.depthFrom).toFixed(2)),
    avgN: parseFloat((g.ns.reduce((a,b)=>a+b,0)/g.ns.length).toFixed(1)),
    unitWeight: UW_DEF[g.soilType] || 18,
    _sptDetail: g.ns.map((n,i) => (g.depthFrom + i + 0.5).toFixed(0) + 'm(N=' + n + ')').join(', '),
    _sptCount: g.ns.length
  }));
}

// ===== MULTI-BOREHOLE STORE =====
const BH_RESULTS = {};

function calcAllBoreholes() {
  if (!STATE.uploadedData) return;
  STATE.uploadedData.forEach(bh => {
    const p = {
      pileType: STATE.pileType, diameter_mm: STATE.diameter_mm, thickness_mm: STATE.thickness_mm,
      phcGrade: STATE.phcGrade, pileTopEL: STATE.pileTopEL, groundEL: bh.groundEL || STATE.groundEL,
      bearingEL: bh.bearingEL || STATE.bearingEL, gwlDepth: bh.gwlDepth || STATE.gwlDepth,
      sptData: bh.sptData, layers: bh.layers,
      alpha_kh: STATE.alpha_kh, delta_cm: STATE.delta_cm, sigmaMax_kN: STATE.sigmaMax,
      corrosionThickness_mm: STATE.corrosionThk, qu_kPa: STATE.qu_kPa,
      Sd_m: STATE.Sd_m, td_m: STATE.td_m, rockPhi_deg: STATE.rockPhi,
      bearingMethod: STATE.bearingMethod, jointCount: STATE.jointCount, jointType: STATE.jointType,
      useFill: STATE.useFill, plannedEL: STATE.plannedEL, fillN: STATE.fillN,
      embedDepth: STATE.embedDepth
    };
    try { BH_RESULTS[bh.holeNo] = calcPile(p); } catch(e) { BH_RESULTS[bh.holeNo] = null; }
  });
}

// ===== EXCEL EXPORT (전체 시추공 종합) =====
function exportExcel() {
  if (typeof XLSX === 'undefined') { showToast('SheetJS 라이브러리 로딩 중...', 'warning'); return; }
  const wb = XLSX.utils.book_new();
  const isPHC = STATE.pileType === 'PHC';
  const pileDesc = isPHC ? `PHC ${STATE.phcGrade}종 D${STATE.diameter_mm}×${STATE.thickness_mm}t` : `강관 D${STATE.diameter_mm}×${STATE.thickness_mm}t`;
  const bhs = STATE.uploadedData && STATE.uploadedData.length > 0 ? STATE.uploadedData : null;
  const fmt2 = v => v != null ? Number(Number(v).toFixed(2)) : '-';

  // ── Sheet 1: 설계조건 ──
  const condData = [
    ['말뚝 기초 설계 종합 보고서'],
    ['작성일', (new Date()).toISOString().slice(0,10)],
    [],
    ['[설계 조건]'],
    ['말뚝 종류', pileDesc],
    ['지지방법', STATE.bearingMethod === 'rock' ? '암반근입' : 'Meyerhof (토사)'],
    ['말뚝두부 EL(m)', STATE.pileTopEL],
    ['근입 깊이(m)', STATE.embedDepth],
    ['alpha (Kh)', STATE.alpha_kh],
    ['허용변위 (cm)', STATE.delta_cm],
    [isPHC ? '허용압축응력 (kN/m²)' : '항복응력 (kN/m²)', STATE.sigmaMax],
    ['이음 방법', STATE.jointType + ' × ' + STATE.jointCount + '개소'],
  ];
  if (!isPHC) {
    condData.push(['부식두께 (mm)', STATE.corrosionThk]);
    if (STATE.bearingMethod === 'rock') {
      condData.push(['qu (kPa)', STATE.qu_kPa], ['Sd (m)', STATE.Sd_m], ['td (m)', STATE.td_m], ['Rock Phi (deg)', STATE.rockPhi]);
    }
  }
  if (STATE.useFill) {
    const cfDiff = STATE.plannedEL - STATE.groundEL;
    if (cfDiff > 0) {
      condData.push([], ['[성토 조건]'], ['계획고 EL(m)', STATE.plannedEL], ['성토재 N값', STATE.fillN],
        ['성토고 (m)', fmt2(cfDiff)]);
    } else if (cfDiff < 0) {
      condData.push([], ['[절토 조건]'], ['계획고 EL(m)', STATE.plannedEL],
        ['절토 깊이 (m)', fmt2(Math.abs(cfDiff))], ['설계지반면 EL(m)', STATE.plannedEL]);
    }
  }
  XLSX.utils.book_append_sheet(wb, XLSX.utils.aoa_to_sheet(condData), '설계조건');

  // ── Sheet 2: 종합 결과 ──
  const sumHdr = ['No','시추공','지반고(EL)','선단EL','지하수위(GL,m)','말뚝길이(m)',
    'Qa_수직(kN)','Qp_재료(kN)','Qa_지반(kN)','Qu_주면(kN)',
    'Ha_수평(kN)','Kh(kN/m³)','인발(kN)','침하(mm)','판정'];
  const sumData = [sumHdr];
  const getResults = (holeNo, r, bh) => {
    if (!r) return [holeNo,'-','-','-','-','-','-','-','-','-','-','-','-'];
    return [holeNo, fmt2(bh ? bh.groundEL : STATE.groundEL), fmt2(r.tipEL), fmt2(bh ? bh.gwlDepth : STATE.gwlDepth), fmt2(r.pileLength),
      fmt2(r.Qa_applied), fmt2(r.Qp_material), fmt2(r.Qa_ground), fmt2(r.Qu_skin),
      fmt2(r.Ha_applied), fmt2(r.Kh_min), fmt2(r.Qpull), fmt2(r.St), r.St < 25 ? 'OK' : 'NG'];
  };
  if (bhs) {
    bhs.forEach((bh, i) => {
      const r = BH_RESULTS[bh.holeNo];
      sumData.push([i+1, ...getResults(bh.holeNo, r, bh)]);
    });
  } else {
    sumData.push([1, ...getResults(STATE.boreholeNo, STATE.result, null)]);
  }
  XLSX.utils.book_append_sheet(wb, XLSX.utils.aoa_to_sheet(sumData), '종합결과');

  // ── Sheet 3: SPT 데이터 ──
  const sptSheet = [['시추공','깊이(m)','EL.+','N값','지층']];
  if (bhs) {
    bhs.forEach(bh => {
      (bh.sptData||[]).forEach(s => sptSheet.push([bh.holeNo, s.depth, fmt2((bh.groundEL||0) - s.depth + 1), s.N, s.remark||'']));
      sptSheet.push([]); // blank row between boreholes
    });
  } else {
    STATE.sptData.forEach(s => sptSheet.push([STATE.boreholeNo, s.depth, fmt2(STATE.groundEL - s.depth + 1), s.N, s.remark||'']));
  }
  XLSX.utils.book_append_sheet(wb, XLSX.utils.aoa_to_sheet(sptSheet), 'SPT데이터');

  // ── Sheet 4: 지층 정보 ──
  const laySheet = [['시추공','지층','깊이 상단(m)','깊이 하단(m)','두께(m)','평균N','단위중량(kN/m³)','분류']];
  if (bhs) {
    bhs.forEach(bh => {
      (bh.layers||[]).forEach(l => laySheet.push([bh.holeNo, l.soilType, l.depthFrom, l.depthTo, l.thickness, l.avgN, l.unitWeight, SOIL_CLS[l.soilType]||'sand']));
      laySheet.push([]);
    });
  } else {
    STATE.layers.forEach(l => laySheet.push([STATE.boreholeNo, l.soilType, l.depthFrom, l.depthTo, l.thickness, l.avgN, l.unitWeight, SOIL_CLS[l.soilType]||'sand']));
  }
  XLSX.utils.book_append_sheet(wb, XLSX.utils.aoa_to_sheet(laySheet), '지층정보');

  // ── Sheet 5: 계산 상세 (각 시추공별 주면마찰력) ──
  const detHdr = ['시추공','지층','두께(m)','N값','분류','As(m²)','주면마찰(kN)','누적주면(kN)'];
  const detData = [detHdr];
  const addDetail = (holeNo, r) => {
    if (!r || !r.processedLayers) return;
    let cumSkin = 0;
    r.processedLayers.forEach(pl => {
      const skinF = (pl.skinFriction_sand || 0) + (pl.skinFriction_clay || 0);
      cumSkin += skinF;
      detData.push([holeNo, pl.soilType, fmt2(pl.thickness), fmt2(pl.avgN), pl.soilClass||'sand', fmt2(pl.As), fmt2(skinF), fmt2(cumSkin)]);
    });
    detData.push([]);
  };
  if (bhs) {
    bhs.forEach(bh => addDetail(bh.holeNo, BH_RESULTS[bh.holeNo]));
  } else {
    addDetail(STATE.boreholeNo, STATE.result);
  }
  XLSX.utils.book_append_sheet(wb, XLSX.utils.aoa_to_sheet(detData), '주면마찰상세');

  XLSX.writeFile(wb, '말뚝기초설계_' + pileDesc.replace(/[×\s]/g,'') + '_' + (new Date()).toISOString().slice(0,10) + '.xlsx');
  showToast('엑셀 파일 다운로드 완료 (5개 시트)', 'success');
}

// ===== OVERALL RESULTS TAB (merged with Dashboard) =====
// ===== QUANTITY ESTIMATION =====
function calcQuantities() {
  const isPHC = STATE.pileType === 'PHC';
  const pileSpec = isPHC ? 'PHC ' + STATE.diameter_mm + 'mm ' + STATE.phcGrade + '\uC885' : '\uAC15\uAD00 ' + STATE.diameter_mm + 'mm';
  const items = [];

  if (STATE.uploadedData && STATE.uploadedData.length > 0) {
    STATE.uploadedData.forEach(bh => {
      const r = BH_RESULTS[bh.holeNo];
      if (!r) return;
      items.push({
        holeNo: bh.holeNo,
        pileLength: r.pileLength,
        weight_ton: (r.W_unit * r.pileLength) / 9.80665,
        volume_m3: r.Ap_net * r.pileLength,
        surface_m2: r.U * r.pileLength,
        W_unit: r.W_unit, Ap_net: r.Ap_net, U: r.U
      });
    });
  } else if (STATE.result) {
    const r = STATE.result;
    items.push({
      holeNo: STATE.boreholeNo,
      pileLength: r.pileLength,
      weight_ton: (r.W_unit * r.pileLength) / 9.80665,
      volume_m3: r.Ap_net * r.pileLength,
      surface_m2: r.U * r.pileLength,
      W_unit: r.W_unit, Ap_net: r.Ap_net, U: r.U
    });
  }

  const lengths = items.map(i => i.pileLength);
  return {
    items,
    pileSpec,
    totalPiles: items.length,
    totalLength: lengths.reduce((s, v) => s + v, 0),
    totalWeight_ton: items.reduce((s, i) => s + i.weight_ton, 0),
    totalVolume_m3: items.reduce((s, i) => s + i.volume_m3, 0),
    totalSurface_m2: items.reduce((s, i) => s + i.surface_m2, 0),
    avgLength: lengths.length > 0 ? lengths.reduce((s, v) => s + v, 0) / lengths.length : 0,
    minLength: lengths.length > 0 ? Math.min(...lengths) : 0,
    maxLength: lengths.length > 0 ? Math.max(...lengths) : 0
  };
}

function renderQuantitySection(q, isMulti) {
  const f2 = v => v.toFixed(2);
  const f1 = v => v.toFixed(1);
  const f3 = v => v.toFixed(3);
  let html = `<div style="margin:16px 0 12px;padding:12px 16px;background:linear-gradient(135deg,#faf5ff,#f0f4ff);
    border:1px solid #c7d2fe;border-radius:8px">
    <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:10px">
      <div style="font-size:13px;font-weight:700;color:#4338ca;display:flex;align-items:center;gap:6px">
        &#128230; \uBB3C\uB7C9 \uC0B0\uC815</div>
      <span style="font-size:10px;color:var(--text-muted);background:#e0e7ff;padding:2px 8px;border-radius:10px;font-weight:600">
        ${q.pileSpec} | ${q.totalPiles}\uAC1C\uC18C</span>
    </div>
    <div style="display:grid;grid-template-columns:repeat(4,1fr);gap:8px">
      <div style="background:#fff;padding:10px;border-radius:6px;text-align:center;border:1px solid #e2e8f0">
        <div style="font-size:18px;font-weight:800;color:var(--primary-navy);font-family:var(--font-mono)">${q.totalPiles}</div>
        <div style="font-size:9px;color:var(--text-muted);margin-top:2px">\uCD1D \uB9D0\uB69D \uBCF8\uC218</div>
      </div>
      <div style="background:#fff;padding:10px;border-radius:6px;text-align:center;border:1px solid #e2e8f0">
        <div style="font-size:18px;font-weight:800;color:var(--primary-navy);font-family:var(--font-mono)">${f1(q.totalLength)}</div>
        <div style="font-size:9px;color:var(--text-muted);margin-top:2px">\uCD1D \uB9D0\uB69D \uAE38\uC774 (m)</div>
      </div>
      <div style="background:#fff;padding:10px;border-radius:6px;text-align:center;border:1px solid #e2e8f0">
        <div style="font-size:18px;font-weight:800;color:#7c3aed;font-family:var(--font-mono)">${f2(q.totalWeight_ton)}</div>
        <div style="font-size:9px;color:var(--text-muted);margin-top:2px">\uCD1D \uC911\uB7C9 (ton)</div>
      </div>
      <div style="background:#fff;padding:10px;border-radius:6px;text-align:center;border:1px solid #e2e8f0">
        <div style="font-size:18px;font-weight:800;color:#059669;font-family:var(--font-mono)">${f3(q.totalVolume_m3)}</div>
        <div style="font-size:9px;color:var(--text-muted);margin-top:2px">\uCD1D \uC7AC\uB8CC \uCCB4\uC801 (m\u00B3)</div>
      </div>
    </div>`;

  if (isMulti) {
    html += `<div style="display:grid;grid-template-columns:repeat(4,1fr);gap:8px;margin-top:8px">
      <div style="background:#fff;padding:8px;border-radius:6px;text-align:center;border:1px solid #e2e8f0">
        <div style="font-size:14px;font-weight:700;color:var(--text-primary);font-family:var(--font-mono)">${f2(q.avgLength)}</div>
        <div style="font-size:9px;color:var(--text-muted);margin-top:1px">\uD3C9\uADE0 \uAE38\uC774 (m)</div>
      </div>
      <div style="background:#fff;padding:8px;border-radius:6px;text-align:center;border:1px solid #e2e8f0">
        <div style="font-size:14px;font-weight:700;color:#dc2626;font-family:var(--font-mono)">${f2(q.maxLength)}</div>
        <div style="font-size:9px;color:var(--text-muted);margin-top:1px">\uCD5C\uC7A5 \uAE38\uC774 (m)</div>
      </div>
      <div style="background:#fff;padding:8px;border-radius:6px;text-align:center;border:1px solid #e2e8f0">
        <div style="font-size:14px;font-weight:700;color:#2563eb;font-family:var(--font-mono)">${f2(q.minLength)}</div>
        <div style="font-size:9px;color:var(--text-muted);margin-top:1px">\uCD5C\uB2E8 \uAE38\uC774 (m)</div>
      </div>
      <div style="background:#fff;padding:8px;border-radius:6px;text-align:center;border:1px solid #e2e8f0">
        <div style="font-size:14px;font-weight:700;color:var(--text-primary);font-family:var(--font-mono)">${f1(q.totalSurface_m2)}</div>
        <div style="font-size:9px;color:var(--text-muted);margin-top:1px">\uCD1D \uD45C\uBA74\uC801 (m\u00B2)</div>
      </div>
    </div>`;
    // 시추공별 물량 상세 테이블 (접기/펼치기)
    html += `<details style="margin-top:10px">
      <summary style="cursor:pointer;font-size:11px;font-weight:600;color:#4338ca;padding:4px 0">
        \uC2DC\uCD94\uACF5\uBCC4 \uBB3C\uB7C9 \uC0C1\uC138 \u25BC</summary>
      <table style="width:100%;margin-top:6px;font-size:11px;border-collapse:collapse">
        <thead><tr style="background:#f1f5f9">
          <th style="padding:5px 8px;text-align:left;font-weight:600;border-bottom:1px solid #e2e8f0">\uC2DC\uCD94\uACF5</th>
          <th style="padding:5px 8px;text-align:right;font-weight:600;border-bottom:1px solid #e2e8f0">\uB9D0\uB69D\uAE38\uC774(m)</th>
          <th style="padding:5px 8px;text-align:right;font-weight:600;border-bottom:1px solid #e2e8f0">\uC911\uB7C9(ton)</th>
          <th style="padding:5px 8px;text-align:right;font-weight:600;border-bottom:1px solid #e2e8f0">\uCCB4\uC801(m\u00B3)</th>
          <th style="padding:5px 8px;text-align:right;font-weight:600;border-bottom:1px solid #e2e8f0">\uD45C\uBA74\uC801(m\u00B2)</th>
        </tr></thead><tbody>`;
    q.items.forEach(it => {
      html += `<tr style="border-bottom:1px solid #f1f5f9">
        <td style="padding:4px 8px;font-weight:600;color:var(--primary-navy)">${it.holeNo}</td>
        <td style="padding:4px 8px;text-align:right;font-family:var(--font-mono)">${f2(it.pileLength)}</td>
        <td style="padding:4px 8px;text-align:right;font-family:var(--font-mono)">${f3(it.weight_ton)}</td>
        <td style="padding:4px 8px;text-align:right;font-family:var(--font-mono)">${f3(it.volume_m3)}</td>
        <td style="padding:4px 8px;text-align:right;font-family:var(--font-mono)">${f1(it.surface_m2)}</td>
      </tr>`;
    });
    html += `<tr style="background:#f8fafc;font-weight:700;border-top:2px solid #cbd5e1">
      <td style="padding:5px 8px">\uD569\uACC4</td>
      <td style="padding:5px 8px;text-align:right;font-family:var(--font-mono)">${f1(q.totalLength)}</td>
      <td style="padding:5px 8px;text-align:right;font-family:var(--font-mono);color:#7c3aed">${f2(q.totalWeight_ton)}</td>
      <td style="padding:5px 8px;text-align:right;font-family:var(--font-mono);color:#059669">${f3(q.totalVolume_m3)}</td>
      <td style="padding:5px 8px;text-align:right;font-family:var(--font-mono)">${f1(q.totalSurface_m2)}</td>
    </tr></tbody></table></details>`;
  }
  html += `</div>`;
  return html;
}

function renderOverallTab() {
  const el = document.getElementById('tab-overall');
  if (!STATE.uploadedData || STATE.uploadedData.length === 0) {
    const r = STATE.result;
    if (!r) { el.innerHTML = '<p style="color:var(--text-muted);padding:20px">계산 결과가 없습니다.</p>'; return; }
    const q = calcQuantities();
    el.innerHTML = `<h3 class="sec-title">종합 계산 결과</h3>
    <table><thead><tr><th>시추공</th><th>수직 Qa(kN)</th><th>수평 Ha(kN)</th><th>인발(kN)</th><th>침하(mm)</th><th>판정</th></tr></thead>
    <tbody><tr><td style="font-weight:700">${STATE.boreholeNo}</td>
    <td style="font-weight:700;color:var(--primary-navy)">${fmt(r.Qa_applied)}</td>
    <td style="font-weight:700;color:var(--accent-coral)">${fmt(r.Ha_applied)}</td>
    <td style="font-weight:700;color:var(--accent-green)">${fmt(r.Qpull)}</td>
    <td>${fmt(r.St)}</td>
    <td style="font-weight:700;color:${r.St<25?'var(--status-pass)':'var(--status-fail)'}">${r.St<25?'OK':'NG'}</td>
    </tr></tbody></table>` + renderQuantitySection(q, false);
    return;
  }
  calcAllBoreholes();
  const bhs = STATE.uploadedData;
  const results = Object.values(BH_RESULTS).filter(r => r);
  const count = bhs.length;
  const avgQa = results.length > 0 ? (results.reduce((s,r) => s + r.Qa_applied, 0) / results.length).toFixed(1) : '-';
  const avgHa = results.length > 0 ? (results.reduce((s,r) => s + r.Ha_applied, 0) / results.length).toFixed(1) : '-';
  const okCount = results.filter(r => r.St < 25).length;
  const q = calcQuantities();

  let html = `<div style="display:flex;justify-content:space-between;align-items:center">
    <h3 class="sec-title" style="margin:0">종합 계산 결과 (전체 시추공)</h3>
    <div style="display:flex;gap:6px">
      <button class="ai-btn" onclick="runBoreholeAnalysis()" style="padding:7px 16px;font-size:11px">&#9889; AI 시추공 분석</button>
      <button class="ai-btn" onclick="openChatPanel()" style="padding:7px 16px;font-size:11px;background:linear-gradient(135deg,#4f46e5,#7c3aed)">&#128172; AI 채팅</button>
    </div>
  </div>`;
  // Stats cards
  html += `<div class="dash-stats">
    <div class="dash-stat"><div class="ds-val">${count}</div><div class="ds-label">시추공 수</div></div>
    <div class="dash-stat"><div class="ds-val">${avgQa}</div><div class="ds-label">평균 Qa (kN)</div></div>
    <div class="dash-stat"><div class="ds-val">${avgHa}</div><div class="ds-label">평균 Ha (kN)</div></div>
    <div class="dash-stat"><div class="ds-val">${okCount}/${results.length}</div><div class="ds-label">침하 OK</div></div>
  </div>`;
  // Quantity estimation
  html += renderQuantitySection(q, true);
  // Toolbar
  html += `<div class="dash-toolbar">
    <input type="text" id="overallSearch" placeholder="시추공 검색..." oninput="filterOverallTable(this.value)">
    <button class="btn btn-sm" onclick="exportExcel()">엑셀 내보내기</button>
  </div>`;
  // Bar chart
  const maxQa = Math.max(...results.map(r=>r.Qa_applied), 1);
  html += `<div style="margin-bottom:20px">
  <div style="font-size:11px;font-weight:600;color:var(--text-secondary);margin-bottom:8px">수직지지력 비교</div>`;
  bhs.forEach(bh => {
    const r = BH_RESULTS[bh.holeNo];
    if (!r) return;
    const pct = (r.Qa_applied / maxQa * 100).toFixed(0);
    html += `<div style="display:flex;align-items:center;gap:8px;margin-bottom:4px">
      <span style="width:60px;font-size:10px;font-weight:600;text-align:right">${bh.holeNo}</span>
      <div style="flex:1;height:18px;background:#f1f5f9;border-radius:3px;overflow:hidden">
        <div style="width:${pct}%;height:100%;background:linear-gradient(to right,var(--primary-steel),var(--primary-navy));border-radius:3px"></div>
      </div>
      <span style="font-size:11px;font-weight:700;font-family:var(--font-mono);min-width:60px">${fmt(r.Qa_applied)}</span>
    </div>`;
  });
  html += `</div>`;
  // Enhanced table with sparklines
  html += `<div id="overallTableWrap">`;
  html += buildOverallTable(bhs);
  html += `</div>`;
  el.innerHTML = html;
}

function buildOverallTable(bhs) {
  let html = `<table class="dash-table"><thead><tr>
    <th>시추공</th><th>지반고(m)</th><th>N값 분포</th><th>말뚝길이(m)</th>
    <th>Qa(kN)</th><th>Ha(kN)</th><th>인발(kN)</th><th>침하(mm)</th><th>판정</th><th></th>
  </tr></thead><tbody>`;
  bhs.forEach((bh, i) => {
    const r = BH_RESULTS[bh.holeNo];
    const sparkW = 80;
    let spark = `<svg width="${sparkW}" height="16" style="vertical-align:middle">`;
    if (bh.sptData) {
      const step = sparkW / Math.max(bh.sptData.length - 1, 1);
      bh.sptData.forEach((s, j) => {
        const h = (Math.min(s.N,50)/50)*14;
        spark += `<rect x="${j*step}" y="${16-h}" width="${Math.max(step-1,2)}" height="${h}" fill="${s.N>=50?'#2E7D32':'#1976d2'}" rx="1"/>`;
      });
    }
    spark += '</svg>';
    const ok = r && r.St < 25;
    html += `<tr>
      <td style="font-weight:700;color:var(--primary-navy);cursor:pointer" onclick="selectBoreholeFromSidebar(${i})">${bh.holeNo}</td>
      <td>${bh.groundEL != null ? bh.groundEL.toFixed(1) : '-'}</td>
      <td>${spark}</td>
      <td>${r ? fmt(r.pileLength) : '-'}</td>
      <td style="font-weight:700">${r ? fmt(r.Qa_applied) : '-'}</td>
      <td>${r ? fmt(r.Ha_applied) : '-'}</td>
      <td>${r ? fmt(r.Qpull) : '-'}</td>
      <td>${r ? fmt(r.St) : '-'}</td>
      <td><span style="color:${ok?'var(--status-pass)':'var(--status-fail)'};font-weight:700">${r ? (ok?'OK':'NG') : '-'}</span></td>
      <td><button class="btn btn-sm btn-outline" onclick="selectBoreholeFromSidebar(${i})">선택</button></td>
    </tr>`;
  });
  html += '</tbody></table>';
  return html;
}

function filterOverallTable(q) {
  if (!STATE.uploadedData) return;
  const filtered = q ? STATE.uploadedData.filter(b => b.holeNo.toLowerCase().includes(q.toLowerCase())) : STATE.uploadedData;
  const wrap = document.getElementById('overallTableWrap');
  if (wrap) wrap.innerHTML = buildOverallTable(filtered);
}

// ===== REPORT TAB =====
function renderReportTab() {
  const el = document.getElementById('tab-report');
  const r = STATE.result;
  if (!r) { el.innerHTML = '<p style="color:var(--text-muted);padding:20px">계산 결과가 없습니다.</p>'; return; }
  const isPHC = STATE.pileType === "PHC";
  const spec = getSpecInfo();
  let html = `<div style="display:flex;justify-content:space-between;align-items:center">
    <h3 class="sec-title" style="margin:0">상세 계산서 — ${STATE.boreholeNo}</h3>
    <div style="display:flex;gap:6px">
      <button class="ai-btn" onclick="generateAIReport()" style="padding:7px 16px;font-size:11px">&#9889; AI 보고서 생성</button>
      <button class="ai-btn" onclick="openChatPanel()" style="padding:7px 16px;font-size:11px;background:linear-gradient(135deg,#4f46e5,#7c3aed)">&#128172; AI 채팅</button>
    </div>
  </div>`;

  // ============ Section 1: 설계 조건 ============
  html += `<div class="report-section"><div class="report-title">1. 설계 조건</div>
  <table><thead><tr><th>항목</th><th>값</th><th>항목</th><th>값</th></tr></thead><tbody>
  <tr><td class="left">말뚝 종류</td><td>${isPHC?'PHC '+STATE.phcGrade+'종':'강관말뚝'}</td><td class="left">직경 (D)</td><td>${STATE.diameter_mm} mm = ${fmt(r.D,4)} m</td></tr>
  <tr><td class="left">두께 (t)</td><td>${STATE.thickness_mm} mm = ${fmt(r.t,4)} m</td><td class="left">말뚝 길이 (L)</td><td>${fmt(r.pileLength)} m</td></tr>
  <tr><td class="left">지반고 (GL)</td><td>EL.${fmt(STATE.groundEL,2)} m</td><td class="left">지하수위 (GWL)</td><td>GL-${fmt(STATE.gwlDepth,2)} m (EL.${fmt(r.gwlEL,2)} m)</td></tr>
  <tr><td class="left">말뚝두부 EL</td><td>EL.${fmt(STATE.pileTopEL,2)} m</td><td class="left">지지층 EL (상단)</td><td>EL.${fmt(STATE.bearingEL,2)} m</td></tr>
  <tr><td class="left">근입 깊이</td><td>${fmt(r.embedDepth)} m</td><td class="left">선단 지지층 EL</td><td>EL.${fmt(r.tipEL,2)} m</td></tr>
  <tr><td class="left">절성토</td><td>${r.cutFillDepth > 0 ? '성토 '+fmt(r.fillHeight)+'m' : r.cutFillDepth < 0 ? '<span style="color:#1e40af;font-weight:600">절토 '+fmt(r.cutDepth)+'m</span>' : '없음'} (${fmt(r.cutFillDepth)} m)</td><td class="left">둘레 (U)</td><td>$\\pi D = \\pi \\times ${fmt(r.D,4)} = ${fmt(r.U,4)}$ m</td></tr>
  <tr><td class="left">탄성계수 (E)</td><td>${(r.E/1e6).toFixed(1)} GPa = ${(r.E/1e3).toFixed(0)} kN/m²</td><td class="left">단면2차모멘트 (I)</td><td>${fmtE(r.I)} m⁴</td></tr>
  <tr><td class="left">선단면적 (Ap)</td><td>${fmt(r.Ap_tip,4)} m²</td><td class="left">순단면적 (An)</td><td>${fmt(r.Ap_net,4)} m²</td></tr>
  <tr><td class="left">단면계수 (Zp)</td><td>${fmtE(r.Zp)} m³</td><td class="left">휨강성 (EI)</td><td>${fmt(r.EI,1)} kN·m²</td></tr>
  <tr><td class="left">자중 (W)</td><td>${fmt(r.W_unit,2)} kN/m</td><td class="left">이음부</td><td>${STATE.jointType} × ${STATE.jointCount}개소</td></tr>
  ${!isPHC?`<tr><td class="left">부식두께</td><td>${STATE.corrosionThk} mm</td><td class="left">강관단면적 (At)</td><td>${fmt(r.At_steel,6)} m²</td></tr>
  <tr><td class="left">내부면적 (Ai)</td><td>${fmt(r.Ai_steel,6)} m²</td><td class="left">지지방법</td><td>${STATE.bearingMethod==='rock'?'암반근입':'Meyerhof(토사)'}</td></tr>`:''}
  </tbody></table>`;

  // SPT Data Table
  html += `<div style="margin-top:14px"><strong style="font-size:11px;color:var(--primary-navy)">SPT N값 현황</strong></div>
  <table style="margin-top:6px"><thead><tr><th>깊이(m)</th><th>N값</th><th>지층</th></tr></thead><tbody>
  ${STATE.sptData.map(s => `<tr><td>${fmt(s.depth,1)}</td><td style="font-weight:700;color:${s.N>=50?'var(--status-pass)':'var(--primary-navy)'}">${s.N}</td><td class="left">${s.remark||''}</td></tr>`).join('')}
  </tbody></table>`;

  // Layer Table
  html += `<div style="margin-top:14px"><strong style="font-size:11px;color:var(--primary-navy)">지층 평균 정리</strong></div>
  <table style="margin-top:6px"><thead><tr><th>지층</th><th>두께(m)</th><th>평균N</th><th>단위중량(kN/m³)</th><th>분류</th></tr></thead><tbody>
  ${STATE.layers.map(l => { const d = l._sptDetail || ''; const c = l._sptCount || 0; const tip = c > 0 ? '산정근거: ' + c + '개 SPT\\n' + d : 'SPT없음, 기본값 적용'; return `<tr><td class="left">${l.soilType}</td><td>${fmt(l.thickness)}</td><td><span class="calc-tip">${fmt(l.avgN,1)}<span class="tip-content">${tip}</span></span></td><td>${l.unitWeight}</td><td><span class="soil-badge ${SOIL_CLS[l.soilType]||'sand'}">${SOIL_CLS[l.soilType]||'sand'}</span></td></tr>`; }).join('')}
  </tbody></table></div>`;

  // ============ Section 2: 수직지지력 ============
  html += `<div class="report-section"><div class="report-title">2. 수직 허용지지력 (KDS 11 50 40)</div>`;

  // 2.1 Material
  html += `<div class="report-step"><span class="step-num">1</span><strong>재료 허용연직지지력 (Qp)</strong>
  <div style="margin-top:8px;font-size:11px;color:var(--text-secondary)">기준: KDS 11 50 40 (2018) — 말뚝재료의 허용연직지지력</div>
  <div style="margin-top:6px">$$Q_p = \\left(1 - \\frac{\\mu_1 + \\mu_2}{100}\\right) \\times Q_{ap}$$</div>

  <div style="margin-top:10px;padding:8px;background:#f8f9fa;border-radius:4px">
  <div style="font-size:11px;font-weight:600;color:var(--primary-navy);margin-bottom:4px">▸ 세장비 감소율 (μ₁)</div>
  <div style="font-size:11px">$L/d = ${fmt(r.pileLength)} \\div ${fmt(r.D,4)} = ${fmt(r.L_over_d,1)}$</div>
  <div style="font-size:11px">세장비 한계값 $n = ${r.n_slender}$ ${isPHC?'(PHC말뚝)':'(강관말뚝)'}</div>
  <div style="font-size:11px">${r.L_over_d > r.n_slender ?
    `$L/d = ${fmt(r.L_over_d,1)} > n = ${r.n_slender}$ 이므로 세장비 감소 적용` :
    `$L/d = ${fmt(r.L_over_d,1)} \\leq n = ${r.n_slender}$ 이므로 세장비 감소 없음`}</div>
  <div style="font-size:11px;font-weight:600">$\\mu_1 = ${r.mu1 > 0 ? `\\min\\left(\\left(\\frac{${fmt(r.L_over_d,1)}}{${r.n_slender}} - 1\\right) \\times 100,\\; 30\\right)` : '0'} = ${fmt(r.mu1)}\\%$</div>
  </div>

  <div style="margin-top:8px;padding:8px;background:#f8f9fa;border-radius:4px">
  <div style="font-size:11px;font-weight:600;color:var(--primary-navy);margin-bottom:4px">▸ 이음부 감소율 (μ₂)</div>
  <div style="font-size:11px">이음방법: ${STATE.jointType==='welding'?'용접':STATE.jointType==='bolt'?'볼트':'충전'}, 이음수: ${STATE.jointCount}개소</div>
  <div style="font-size:11px">${STATE.jointType==='welding' ? `용접이음: 1개소당 5% → ${STATE.jointCount} × 5 = ${fmt(r.mu2)}%` : STATE.jointType==='bolt' ? `볼트이음: 1개소당 10% → ${STATE.jointCount} × 10 = ${fmt(r.mu2)}%` : `충전이음: min(${STATE.jointCount},2)×20 + max(${STATE.jointCount}-2,0)×30 = ${fmt(r.mu2)}%`}</div>
  <div style="font-size:11px;font-weight:600">$\\mu_2 = ${fmt(r.mu2)}\\%$</div>
  </div>

  <div style="margin-top:8px;padding:8px;background:#f8f9fa;border-radius:4px">
  <div style="font-size:11px;font-weight:600;color:var(--primary-navy);margin-bottom:4px">▸ 허용축하중 (Qap)</div>
  <div style="font-size:11px">${isPHC ? `PHC ${STATE.phcGrade}종 D${STATE.diameter_mm}×${STATE.thickness_mm}t 규격값 (KS F 4306)` : `강관 D${STATE.diameter_mm}×${STATE.thickness_mm}t 규격값`}</div>
  <div style="font-size:11px;font-weight:600">$Q_{ap} = ${fmt(r.Qap)}$ kN</div>
  </div>

  <div style="margin-top:10px;padding:10px;background:#e8f5e9;border-radius:4px;border:1px solid #a5d6a7">
  <div style="font-size:12px;font-weight:700;color:var(--status-pass)">$Q_p = \\left(1 - \\frac{${fmt(r.mu1)} + ${fmt(r.mu2)}}{100}\\right) \\times ${fmt(r.Qap)} = \\left(1 - \\frac{${fmt(r.mu1+r.mu2)}}{100}\\right) \\times ${fmt(r.Qap)} = ${fmt(1-(r.mu1+r.mu2)/100, 4)} \\times ${fmt(r.Qap)} = ${fmt(r.Qp_material)}$ kN</div>
  </div></div>`;

  // 2.2 Rock tip (if applicable)
  if (!isPHC && r.rockCalcDetails) {
    const rc = r.rockCalcDetails;
    html += `<div class="report-step"><span class="step-num">2</span><strong>암반 선단지지력 — 구조물기초설계기준 (p305)</strong>
    <div style="margin-top:8px">$$P_u = 443 \\times q_u^{1/2} \\times A_t^{2/5} \\times A_i^{1/3}$$</div>
    <div style="margin-top:6px;font-size:11px">$q_u = \\min(${fmt(rc.qu_lab)},\\;10000) = ${fmt(rc.qu_eff)}$ kPa (일축압축강도, 상한 10,000 kPa 적용)</div>
    <div style="font-size:11px">$A_t = ${fmt(rc.At_m2,6)}$ m² (강관 순단면적)</div>
    <div style="font-size:11px">$A_i = ${fmt(rc.Ai_m2,6)}$ m² (강관 내부면적)</div>
    <div style="margin-top:6px;padding:8px;background:#fff3e0;border-radius:4px">
    <div style="font-size:11px;font-weight:700">$P_u = 443 \\times ${fmt(rc.qu_eff)}^{0.5} \\times ${fmt(rc.At_m2,6)}^{0.4} \\times ${fmt(rc.Ai_m2,6)}^{0.333}$</div>
    <div style="font-size:11px;font-weight:700">$= 443 \\times ${fmt(Math.pow(rc.qu_eff,0.5),2)} \\times ${fmt(Math.pow(rc.At_m2,0.4),4)} \\times ${fmt(Math.pow(rc.Ai_m2,1/3),4)} = ${fmt(rc.Pu_tip)}$ kN</div>
    </div></div>`;

    html += `<div class="report-step"><span class="step-num">3</span><strong>Goodman 방법 (도로교설계기준 2008, p863)</strong>
    <div style="margin-top:8px">$$Q_u = q_u \\times (N_\\phi + 1) \\times A_p$$</div>
    <div style="margin-top:6px;font-size:11px">$\\phi_{rock} = ${rc.phi_rock}°$ (암반 내부마찰각)</div>
    <div style="font-size:11px">$N_\\phi = \\tan^2\\left(45° + \\frac{${rc.phi_rock}°}{2}\\right) = \\tan^2(${45+rc.phi_rock/2}°) = ${fmt(rc.N_phi,3)}$</div>
    <div style="font-size:11px">$A_p = \\frac{\\pi}{4} D^2 = \\frac{\\pi}{4} \\times ${fmt(r.D,4)}^2 = ${fmt(rc.Ap_full,4)}$ m²</div>
    <div style="margin-top:6px;padding:8px;background:#fff3e0;border-radius:4px">
    <div style="font-size:11px;font-weight:700">$Q_u = ${fmt(rc.qu_lab)} \\times (${fmt(rc.N_phi,3)} + 1) \\times ${fmt(rc.Ap_full,4)} = ${fmt(rc.qu_lab)} \\times ${fmt(rc.N_phi+1,3)} \\times ${fmt(rc.Ap_full,4)} = ${fmt(rc.Pu_goodman)}$ kN</div>
    </div></div>`;

    html += `<div class="report-step"><span class="step-num">4</span><strong>Canadian FEM (도로교설계기준 2008, p862)</strong>
    <div style="margin-top:8px">$$Q_u = 3 \\times q_u \\times K_{sp} \\times d \\times A_p$$</div>
    <div style="margin-top:6px;font-size:11px">$S_d = ${rc.Sd}$ m (불연속면 간격), $t_d = ${rc.td}$ m (불연속면 두께)</div>
    <div style="font-size:11px">$$K_{sp} = \\frac{3 + S_d/D}{10\\sqrt{1 + 300 \\cdot t_d / S_d}} = \\frac{3 + ${rc.Sd}/${fmt(r.D,4)}}{10\\sqrt{1 + 300 \\times ${rc.td}/${rc.Sd}}} = \\frac{${fmt(3+rc.Sd/r.D,3)}}{10 \\times ${fmt(Math.sqrt(1+300*rc.td/rc.Sd),3)}} = ${fmt(rc.Ksp,4)}$$</div>
    <div style="margin-top:6px;padding:8px;background:#fff3e0;border-radius:4px">
    <div style="font-size:11px;font-weight:700">$Q_u = 3 \\times ${fmt(rc.qu_lab)} \\times ${fmt(rc.Ksp,4)} \\times 2 \\times ${fmt(rc.Ap_full,4)} = ${fmt(rc.Pu_canadian)}$ kN</div>
    </div></div>`;

    html += `<div class="report-step" style="background:#e3f2fd"><span class="step-num">5</span><strong>선단지지력 선정</strong>
    <div style="margin-top:6px;font-size:11px">3가지 방법 비교:</div>
    <table style="margin-top:4px"><thead><tr><th>방법</th><th>Pu (kN)</th></tr></thead><tbody>
    <tr><td class="left">구조물기초설계기준</td><td style="font-weight:700${rc.Pu_tip===rc.Pu_selected?';color:var(--status-pass)':''}">${fmt(rc.Pu_tip)}</td></tr>
    <tr><td class="left">Goodman</td><td style="font-weight:700${rc.Pu_goodman===rc.Pu_selected?';color:var(--status-pass)':''}">${fmt(rc.Pu_goodman)}</td></tr>
    <tr><td class="left">Canadian FEM</td><td style="font-weight:700${rc.Pu_canadian===rc.Pu_selected?';color:var(--status-pass)':''}">${fmt(rc.Pu_canadian)}</td></tr>
    </tbody></table>
    <div style="margin-top:6px;font-size:12px;font-weight:700;color:var(--status-pass)">$P_u = \\min(${fmt(rc.Pu_tip)},\\; ${fmt(rc.Pu_goodman)},\\; ${fmt(rc.Pu_canadian)}) = ${fmt(rc.Pu_selected)}$ kN ← 최솟값 채택</div>
    </div>`;
  }

  // 2.3 Ground capacity
  const tipStepNo = (!isPHC && r.rockCalcDetails) ? 6 : 2;
  html += `<div class="report-step"><span class="step-num">${tipStepNo}</span><strong>지반 허용연직지지력</strong>
  <div style="margin-top:8px;font-size:11px;color:var(--text-secondary)">기준: Meyerhof 공식 (사질토), KDS 11 50 40</div>
  <div style="margin-top:6px">$$Q_u = ${r.rockCalcDetails?'P_u':'250 \\cdot N_{tip} \\cdot A_p'} + \\sum 2 N_s A_s + \\sum 6.25 N_c A_c$$</div>`;

  // Tip
  if (!r.rockCalcDetails) {
    const tipN = r.N_tip;
    html += `<div style="margin-top:8px;padding:8px;background:#f8f9fa;border-radius:4px">
    <div style="font-size:11px;font-weight:600;color:var(--primary-navy)">▸ 선단지지력</div>
    <div style="font-size:11px">$N_{tip} = \\min(N_{최하단},\\; 50) = \\min(${STATE.sptData.length>0?STATE.sptData[STATE.sptData.length-1].N:50},\\; 50) = ${tipN}$</div>
    <div style="font-size:11px">$A_p = \\frac{\\pi}{4} D^2 = \\frac{\\pi}{4} \\times ${fmt(r.D,4)}^2 = ${fmt(r.Ap_tip,4)}$ m²</div>
    <div style="font-size:11px;font-weight:700">$P_u = 250 \\times ${tipN} \\times ${fmt(r.Ap_tip,4)} = ${fmt(r.Qu_tip)}$ kN</div>
    </div>`;
  } else {
    html += `<div style="margin-top:6px;font-size:11px;font-weight:700">선단지지력: $P_u = ${fmt(r.rockCalcDetails.Pu_selected)}$ kN (암반근입, 위에서 산정)</div>`;
  }

  // Skin friction table
  html += `<div style="margin-top:10px;padding:8px;background:#f8f9fa;border-radius:4px">
  <div style="font-size:11px;font-weight:600;color:var(--primary-navy);margin-bottom:4px">▸ 주면마찰력 상세</div>
  <div style="font-size:11px;margin-bottom:4px">둘레 $U = ${fmt(r.U,4)}$ m</div>
  <table style="margin-top:4px"><thead><tr><th>지층</th><th>분류</th><th>L(m)</th><th>N</th><th>As=U×L</th><th>사질토: 2NAs</th><th>점성토: 6.25NAc</th></tr></thead><tbody>`;
  r.processedLayers.forEach(l => {
    const elT = r.groundEL != null ? fmt(r.groundEL - l.depthFrom, 2) : '-';
    const elB = r.groundEL != null ? fmt(r.groundEL - l.depthTo, 2) : '-';
    html += `<tr${l.truncated ? ' style="background:#fff8e1"' : ''}>
    <td class="left">${l.soilType}</td>
    <td><span class="soil-badge ${l.soilClass}">${l.soilClass}</span></td>
    <td style="white-space:nowrap"><span style="font-size:10px;color:#495057">EL.${elT}~${elB}</span><br><strong>${fmt(l.thickness)}</strong>${l.truncated?'<span style="color:#c62828;font-size:9px">(절단)</span>':''}</td><td>${fmt(l.avgN,1)}</td>
    <td>$${fmt(r.U,4)} \\times ${fmt(l.thickness)} = ${fmt(l.As,3)}$</td>
    <td>${l.soilClass==='sand'?`$2 \\times ${fmt(Math.min(l.avgN,30),1)} \\times ${fmt(l.As,3)} = ${fmt(l.skinFriction_sand)}$`:'-'}</td>
    <td>${l.soilClass==='clay'?`$6.25 \\times ${fmt(Math.min(l.avgN,30),1)} \\times ${fmt(l.As,3)} = ${fmt(l.skinFriction_clay)}$`:'-'}</td>
    </tr>`;
  });
  html += `<tr style="background:#e8eaf6;font-weight:700"><td class="left" colspan="5">합계</td><td>${fmt(r.sum_2NsAs)}</td><td>${fmt(r.sum_625NcAc)}</td></tr>`;
  html += `</tbody></table></div>`;

  // Qu and Qa
  html += `<div style="margin-top:10px;padding:10px;background:#e8f5e9;border-radius:4px;border:1px solid #a5d6a7">
  <div style="font-size:11px;font-weight:700">$Q_u = ${fmt(r.Qu_tip)} + ${fmt(r.sum_2NsAs)} + ${fmt(r.sum_625NcAc)} = ${fmt(r.Qu)}$ kN</div>
  <div style="font-size:11px;font-weight:700;margin-top:4px">$Q_a = \\frac{Q_u}{FS} = \\frac{${fmt(r.Qu)}}{${r.FS}} = ${fmt(r.Qa_ground)}$ kN</div>
  </div>`;

  // Final selection
  const sumStepNo = tipStepNo + 1;
  html += `<div class="report-step" style="margin-top:10px;background:#e3f2fd"><span class="step-num">${sumStepNo}</span><strong>수직지지력 종합 비교</strong>
  <table style="margin-top:6px"><thead><tr><th>구분</th><th>지지력 (kN)</th><th>비고</th></tr></thead><tbody>
  <tr><td class="left">재료 허용지지력 (Qp)</td><td style="font-weight:700">${fmt(r.Qp_material)}</td><td class="left">${isPHC?'PHC '+STATE.phcGrade+'종':'강관'} 규격기반</td></tr>
  <tr><td class="left">지반 허용지지력 (Qa)</td><td style="font-weight:700">${fmt(r.Qa_ground)}</td><td class="left">Qu/${r.FS} 적용</td></tr>
  </tbody></table>
  <div style="margin-top:8px;font-size:13px;font-weight:800;color:var(--status-pass)">$$\\therefore Q_{a,적용} = \\min(${fmt(r.Qp_material)},\\; ${fmt(r.Qa_ground)}) = ${fmt(r.Qa_applied)} \\text{ kN}$$</div>
  <div style="font-size:10px;color:var(--text-secondary)">${r.Qa_applied === r.Qp_material ? '→ 재료 허용지지력이 지배 (Qp < Qa)' : '→ 지반 허용지지력이 지배 (Qa < Qp)'}</div>
  </div>`;
  html += `</div>`;

  // ============ Section 3: 수평지지력 ============
  html += `<div class="report-section"><div class="report-title">3. 수평 허용지지력</div>`;

  // 3.1 Kh
  html += `<div class="report-step"><span class="step-num">1</span><strong>수평 지반반력계수 (Kh) 산정</strong>
  <div style="margin-top:8px;font-size:11px;color:var(--text-secondary)">GL~1/β (${fmt(r.invBeta,2)}m) 범위 N<50 평균 사용</div>
  <div style="font-size:11px;font-weight:600">$N_{평균} = ${r.N_kh}$, $\\alpha = ${STATE.alpha_kh}$</div>
  <div style="margin-top:6px;font-size:11px">$E_0 = 2800N = 2800 \\times ${r.N_kh} = ${r.Eo2800}$ kN/m²</div>
  <div style="font-size:11px">$E_0' = 1000N = 1000 \\times ${r.N_kh} = ${r.Eo1000}$ kN/m²</div>

  <table style="margin-top:8px"><thead><tr><th>산정 방법</th><th>산정식</th><th>Kh (kN/m³)</th></tr></thead><tbody>
  <tr style="background:${r.Kh_min===r.Kh1?'#fef9c3':'inherit'}"><td class="left">도로교 (2008)</td><td class="left" style="font-size:10px">$1.208 \\times (\\alpha E_0)^{1.1} \\times D^{-0.31} \\times (EI)^{-0.1}$<br>$= 1.208 \\times (${STATE.alpha_kh} \\times ${r.Eo2800})^{1.1} \\times ${fmt(r.D,4)}^{-0.31} \\times ${fmt(r.EI_h,1)}^{-0.1}$</td><td style="font-weight:700">${fmt(r.Kh1,1)}</td></tr>
  <tr style="background:${r.Kh_min===r.Kh2?'#fef9c3':'inherit'}"><td class="left">福岡 (Fukuoka)</td><td class="left" style="font-size:10px">$6910 \\times N^{0.406} = 6910 \\times ${r.N_kh}^{0.406}$</td><td style="font-weight:700">${fmt(r.Kh2,1)}</td></tr>
  <tr style="background:${r.Kh_min===r.Kh3?'#fef9c3':'inherit'}"><td class="left">横山 (Yokoyama)</td><td class="left" style="font-size:10px">$2000N = 2000 \\times ${r.N_kh}$</td><td style="font-weight:700">${fmt(r.Kh3,1)}</td></tr>
  <tr style="background:${r.Kh_min===r.Kh4?'#fef9c3':'inherit'}"><td class="left">지반공학회 (1996)</td><td class="left" style="font-size:10px">$1.208 \\times (\\alpha \\times 1000N)^{1.1} \\times D^{-0.31} \\times (EI)^{-0.1}$<br>$= 1.208 \\times (${STATE.alpha_kh} \\times ${r.Eo1000})^{1.1} \\times ${fmt(r.D,4)}^{-0.31} \\times ${fmt(r.EI_h,1)}^{-0.1}$</td><td style="font-weight:700">${fmt(r.Kh4,1)}</td></tr>
  </tbody></table>
  <div style="margin-top:8px;font-size:12px;font-weight:700;color:var(--status-pass)">$K_h = \\min(${fmt(r.Kh1,1)},\\; ${fmt(r.Kh2,1)},\\; ${fmt(r.Kh3,1)},\\; ${fmt(r.Kh4,1)}) = ${fmt(r.Kh_min,1)}$ kN/m³ ← 최솟값 채택</div>
  </div>`;

  // 3.2 Pile classification
  html += `<div class="report-step"><span class="step-num">2</span><strong>말뚝 분류 및 특성치</strong>
  <div style="margin-top:8px;font-size:11px">$$\\beta = \\left(\\frac{K_h \\cdot D}{4 \\cdot EI}\\right)^{0.25} = \\left(\\frac{${fmt(r.Kh_min,1)} \\times ${fmt(r.D,4)}}{4 \\times ${fmt(r.EI_h,1)}}\\right)^{0.25} = ${fmt(r.beta,6)} \\text{ m}^{-1}$$</div>
  <div style="font-size:11px">$1/\\beta = ${fmt(r.invBeta,2)}$ m (수평저항 관여 깊이)</div>
  <div style="font-size:11px">$n_h = K_h \\cdot D \\div (1/\\beta) = ${fmt(r.Kh_min,1)} \\times ${fmt(r.D,4)} \\div ${fmt(1/r.beta,4)} = ${fmt(r.Kh_min*r.D*r.beta,2)}$ kN/m³</div>
  <div style="font-size:11px">$\\eta = (n_h / EI)^{0.2} = ${fmt(r.eta,6)}$ m⁻¹</div>
  <div style="font-size:11px;font-weight:700;margin-top:4px">$\\eta L = ${fmt(r.eta,6)} \\times ${fmt(r.pileLength)} = ${fmt(r.etaL,2)}$</div>
  <div style="font-size:11px;margin-top:4px;padding:6px;background:#e0f2fe;border-radius:4px">
  ${r.etaL < 2 ? '$\\eta L < 2$ → <strong>짧은말뚝 (short pile)</strong>' : r.etaL <= 4 ? '$2 \\leq \\eta L \\leq 4$ → <strong>중간말뚝 (intermediate)</strong>' : '$\\eta L > 4$ → <strong>긴말뚝 (long pile)</strong>'}
  </div></div>`;

  // 3.3 Brom Case-1
  html += `<div class="report-step"><span class="step-num">3</span><strong>Brom 방법 — Case-1 (변위 제한)</strong>
  <div style="margin-top:8px;font-size:11px;color:var(--text-secondary)">허용수평변위: $\\delta = ${STATE.delta_cm}$ cm = ${fmt(STATE.delta_cm/100,4)} m</div>
  <div style="font-size:11px">$\\phi = \\sqrt{12 N} + 15 = \\sqrt{12 \\times ${r.N_kh}} + 15 = ${fmt(r.phi_deg,1)}°$</div>
  <div style="font-size:11px">$K_p = \\frac{1+\\sin\\phi}{1-\\sin\\phi} = \\frac{1+\\sin${fmt(r.phi_deg,1)}°}{1-\\sin${fmt(r.phi_deg,1)}°} = ${fmt(r.Kp,3)}$</div>
  <div style="font-size:11px">$\\gamma = ${r.gamma_top}$ kN/m³ (최상위 지층 단위중량)</div>

  <div style="margin-top:6px;font-size:11px">변위에 의한 수평하중:</div>
  <div style="font-size:11px">$H = 4\\beta^3 \\cdot EI \\cdot \\delta = 4 \\times ${fmt(r.beta,6)}^3 \\times ${fmt(r.EI_h,1)} \\times ${fmt(STATE.delta_cm/100,4)} = ${fmt(r.H_disp)}$ kN</div>
  <div style="font-size:11px">$M_y = \\frac{H}{2\\beta} = \\frac{${fmt(r.H_disp)}}{2 \\times ${fmt(r.beta,6)}} = ${fmt(r.My_case1)}$ kN·m</div>

  <div style="margin-top:4px;font-size:11px">${r.pileClass === '긴말뚝' ?
    `긴말뚝: $H_u = 2.38 \\times \\left(\\frac{M_y}{K_p \\gamma D^4}\\right)^{2/3} \\times K_p \\gamma D^3 = ${fmt(r.Hu_brom1)}$ kN` :
    r.pileClass === '짧은말뚝' ?
    `짧은말뚝: $H_u = 1.5 K_p \\gamma D L^2 = 1.5 \\times ${fmt(r.Kp,3)} \\times ${r.gamma_top} \\times ${fmt(r.D,4)} \\times ${fmt(r.pileLength)}^2 = ${fmt(r.Hu_brom1)}$ kN` :
    `중간말뚝: 보간법 적용 → $H_u = ${fmt(r.Hu_brom1)}$ kN`}</div>
  <div style="font-size:12px;font-weight:700;margin-top:4px">$H_a = \\frac{H_u}{2.5} = \\frac{${fmt(r.Hu_brom1)}}{2.5} = ${fmt(r.Ha_brom1)}$ kN</div>
  </div>`;

  // 3.4 Brom Case-2
  html += `<div class="report-step"><span class="step-num">4</span><strong>Brom 방법 — Case-2 (항복 응력)</strong>
  <div style="margin-top:8px;font-size:11px">$\\sigma_{max} = ${STATE.sigmaMax}$ kN/m² ${isPHC?'(PHC 허용압축응력)':'(강관 항복응력)'}</div>
  <div style="font-size:11px">$Z_p = I / (D/2) = ${fmtE(r.I_h)} / ${fmt(r.D/2,4)} = ${fmtE(r.Zp_h)}$ m³</div>
  <div style="font-size:11px">$M_y = Z_p \\times \\sigma_{max} = ${fmtE(r.Zp_h)} \\times ${STATE.sigmaMax} = ${fmt(r.My_case2)}$ kN·m</div>
  <div style="font-size:11px">${r.pileClass === '긴말뚝' ?
    `긴말뚝: $H_u = 2.38 \\times \\left(\\frac{M_y}{K_p \\gamma D^4}\\right)^{2/3} \\times K_p \\gamma D^3 = ${fmt(r.Hu_brom2)}$ kN` :
    `$H_u = ${fmt(r.Hu_brom2)}$ kN (Case-1과 동일 적용)`}</div>
  <div style="font-size:12px;font-weight:700;margin-top:4px">$H_a = \\frac{H_u}{2.5} = \\frac{${fmt(r.Hu_brom2)}}{2.5} = ${fmt(r.Ha_brom2)}$ kN</div>

  <div style="margin-top:8px;font-size:11px;font-weight:700">Brom 결과: $H_a = \\min(${fmt(r.Ha_brom1)},\\; ${fmt(r.Ha_brom2)}) = ${fmt(r.Ha_brom)}$ kN</div>
  </div>`;

  // 3.5 Chang
  html += `<div class="report-step"><span class="step-num">5</span><strong>Chang 방법</strong>
  <div style="margin-top:8px">$$H_a = \\frac{\\delta \\cdot K_h \\cdot D}{\\beta} = \\frac{${fmt(STATE.delta_cm/100,4)} \\times ${fmt(r.Kh_min,1)} \\times ${fmt(r.D,4)}}{${fmt(r.beta,6)}} = ${fmt(r.Ha_chang)}\\text{ kN}$$</div>
  </div>`;

  // Final horizontal
  html += `<div class="report-step" style="background:#e3f2fd"><span class="step-num">6</span><strong>수평지지력 종합</strong>
  <table style="margin-top:6px"><thead><tr><th>방법</th><th>Ha (kN)</th></tr></thead><tbody>
  <tr><td class="left">Brom (Case-1: 변위)</td><td style="font-weight:700">${fmt(r.Ha_brom1)}</td></tr>
  <tr><td class="left">Brom (Case-2: 항복)</td><td style="font-weight:700">${fmt(r.Ha_brom2)}</td></tr>
  <tr><td class="left">Brom (최솟값)</td><td style="font-weight:700">${fmt(r.Ha_brom)}</td></tr>
  <tr><td class="left">Chang</td><td style="font-weight:700">${fmt(r.Ha_chang)}</td></tr>
  </tbody></table>
  <div style="margin-top:8px;font-size:13px;font-weight:800;color:var(--status-pass)">$$\\therefore H_{a,적용} = \\min(${fmt(r.Ha_brom)},\\; ${fmt(r.Ha_chang)}) = ${fmt(r.Ha_applied)} \\text{ kN}$$</div>
  <div style="font-size:10px;color:var(--text-secondary)">${r.Ha_applied === r.Ha_brom ? '→ Brom 방법이 지배' : '→ Chang 방법이 지배'}</div>
  </div></div>`;

  // ============ Section 4: 인발 ============
  html += `<div class="report-section"><div class="report-title">4. 인발 저항력</div>
  <div class="report-step"><span class="step-num">1</span><strong>인발 저항력 산정</strong>
  <div style="margin-top:8px">$$Q_{pull} = \\frac{Q_{u,skin}}{FS} + W_p$$</div>

  <div style="margin-top:8px;padding:8px;background:#f8f9fa;border-radius:4px">
  <div style="font-size:11px;font-weight:600;color:var(--primary-navy)">▸ 주면마찰력</div>
  <div style="font-size:11px">$Q_{u,skin} = \\sum 2N_sA_s + \\sum 6.25N_cA_c = ${fmt(r.sum_2NsAs)} + ${fmt(r.sum_625NcAc)} = ${fmt(r.Qu_skin)}$ kN</div>
  </div>

  <div style="margin-top:8px;padding:8px;background:#f8f9fa;border-radius:4px">
  <div style="font-size:11px;font-weight:600;color:var(--primary-navy)">▸ 말뚝 유효자중 (Wp)</div>
  <div style="font-size:11px">지하수위 위 길이: $l_1 = \\max(${fmt(STATE.pileTopEL)} - ${fmt(r.gwlEL,2)},\\; 0) = ${fmt(r.l1)}$ m</div>
  <div style="font-size:11px">지하수위 아래 길이: $l_2 = L - l_1 = ${fmt(r.pileLength)} - ${fmt(r.l1)} = ${fmt(r.l2)}$ m</div>
  <div style="font-size:11px">$W_p = W_{단위} \\times L - A_p \\times l_2 \\times \\gamma_w = ${fmt(r.W_unit,2)} \\times ${fmt(r.pileLength)} - ${fmt(r.Ap_tip,4)} \\times ${fmt(r.l2)} \\times 10 = ${fmt(r.Wp)}$ kN</div>
  </div>

  <div style="margin-top:10px;padding:10px;background:#e8f5e9;border-radius:4px;border:1px solid #a5d6a7">
  <div style="font-size:12px;font-weight:700;color:var(--status-pass)">$$Q_{pull} = \\frac{${fmt(r.Qu_skin)}}{${r.FS}} + ${fmt(r.Wp)} = ${fmt(r.Qu_skin/r.FS)} + ${fmt(r.Wp)} = ${fmt(r.Qpull)} \\text{ kN}$$</div>
  </div></div></div>`;

  // ============ Section 5: 침하량 ============
  const ok = r.St < 25;
  html += `<div class="report-section"><div class="report-title">5. 침하량 검토</div>
  <div class="report-step"><span class="step-num">1</span><strong>침하량 산정 (Vesic, 1977)</strong>
  <div style="margin-top:8px">$$S_t = S_s + S_p + S_{ps}$$</div>
  <div style="font-size:11px;color:var(--text-secondary)">$S_s$: 축방향 압축침하 | $S_p$: 선단부 침하 | $S_{ps}$: 주면부 침하</div>

  <div style="margin-top:10px;padding:8px;background:#f8f9fa;border-radius:4px">
  <div style="font-size:11px;font-weight:600;color:var(--primary-navy)">▸ 하중 분배</div>
  <div style="font-size:11px">선단비: $Q_{tip}/Q_u = ${fmt(r.Qu_tip)}/${fmt(r.Qu)} = ${fmt(r.ratio_tip,3)}$</div>
  <div style="font-size:11px">$Q_{ps} = Q_a \\times 선단비 = ${fmt(r.Qa_applied)} \\times ${fmt(r.ratio_tip,3)} = ${fmt(r.Qps)}$ kN (선단 분담)</div>
  <div style="font-size:11px">$Q_{fs} = Q_a \\times (1 - 선단비) = ${fmt(r.Qa_applied)} \\times ${fmt(1-r.ratio_tip,3)} = ${fmt(r.Qfs)}$ kN (주면 분담)</div>
  </div>

  <div style="margin-top:8px;padding:8px;background:#f8f9fa;border-radius:4px">
  <div style="font-size:11px;font-weight:600;color:var(--primary-navy)">▸ 축방향 압축침하 (Ss)</div>
  <div style="font-size:11px">$$S_s = \\frac{(Q_{ps} + 0.67 Q_{fs}) \\times L}{A_n \\times E} = \\frac{(${fmt(r.Qps)} + 0.67 \\times ${fmt(r.Qfs)}) \\times ${fmt(r.pileLength)} \\times 1000}{${fmt(r.Ap_net,4)} \\times ${r.E}} = ${fmt(r.Ss)} \\text{ mm}$$</div>
  </div>

  <div style="margin-top:8px;padding:8px;background:#f8f9fa;border-radius:4px">
  <div style="font-size:11px;font-weight:600;color:var(--primary-navy)">▸ 선단부 하중에 의한 침하 (Sp)</div>
  <div style="font-size:11px">$C_p = ${r.Cp}$ (점성토/모래 경험상수)</div>
  <div style="font-size:11px">$q_p = Q_{u,tip}/A_p = ${fmt(r.Qu_tip)}/${fmt(r.Ap_tip,4)} = ${fmt(r.qp,1)}$ kN/m²</div>
  <div style="font-size:11px">$$S_p = \\frac{Q_{ps} \\times C_p}{D \\times q_p} \\times 1000 = \\frac{${fmt(r.Qps)} \\times ${r.Cp}}{${fmt(r.D,4)} \\times ${fmt(r.qp,1)}} \\times 1000 = ${fmt(r.Sp)} \\text{ mm}$$</div>
  </div>

  <div style="margin-top:8px;padding:8px;background:#f8f9fa;border-radius:4px">
  <div style="font-size:11px;font-weight:600;color:var(--primary-navy)">▸ 주면부 하중에 의한 침하 (Sps)</div>
  <div style="font-size:11px">$C_s = (0.93 + 0.16\\sqrt{L/D}) \\times C_p = (0.93 + 0.16\\sqrt{${fmt(r.pileLength)}/${fmt(r.D,4)}}) \\times ${r.Cp} = ${fmt(r.Cs,4)}$</div>
  <div style="font-size:11px">$$S_{ps} = \\frac{Q_{fs} \\times C_s}{L \\times q_p} \\times 1000 = \\frac{${fmt(r.Qfs)} \\times ${fmt(r.Cs,4)}}{${fmt(r.pileLength)} \\times ${fmt(r.qp,1)}} \\times 1000 = ${fmt(r.Sps,3)} \\text{ mm}$$</div>
  </div>

  <div style="margin-top:10px;padding:10px;background:${ok?'#e8f5e9':'#ffebee'};border-radius:4px;border:1px solid ${ok?'#a5d6a7':'#ef9a9a'}">
  <div style="font-size:13px;font-weight:800;color:${ok?'var(--status-pass)':'var(--status-fail)'}">$$S_t = ${fmt(r.Ss)} + ${fmt(r.Sp)} + ${fmt(r.Sps,3)} = ${fmt(r.St)} \\text{ mm}$$</div>
  <div style="font-size:12px;font-weight:700;color:${ok?'var(--status-pass)':'var(--status-fail)'}">판정: ${fmt(r.St)} mm ${ok ? '< 25 mm → OK ✓' : '≥ 25 mm → NG ✗'}</div>
  </div></div></div>`;

  // ============ Section 6: 최종 종합 ============
  html += `<div class="report-section"><div class="report-title">6. 최종 종합 결과</div>
  <table><thead><tr><th>검토 항목</th><th>산정값</th><th>단위</th><th>비고</th></tr></thead><tbody>
  <tr><td class="left" style="font-weight:600">수직 허용지지력 (Qa)</td><td style="font-weight:800;color:var(--primary-navy);font-size:13px">${fmt(r.Qa_applied)}</td><td>kN/본</td><td class="left">min(재료 ${fmt(r.Qp_material)}, 지반 ${fmt(r.Qa_ground)})</td></tr>
  <tr><td class="left" style="font-weight:600">수평 허용지지력 (Ha)</td><td style="font-weight:800;color:var(--accent-coral);font-size:13px">${fmt(r.Ha_applied)}</td><td>kN/본</td><td class="left">min(Brom ${fmt(r.Ha_brom)}, Chang ${fmt(r.Ha_chang)})</td></tr>
  <tr><td class="left" style="font-weight:600">인발 저항력 (Qpull)</td><td style="font-weight:800;color:var(--accent-green);font-size:13px">${fmt(r.Qpull)}</td><td>kN/본</td><td class="left">Qu_skin/FS + Wp</td></tr>
  <tr><td class="left" style="font-weight:600">침하량 (St)</td><td style="font-weight:800;color:${ok?'var(--status-pass)':'var(--status-fail)'}; font-size:13px">${fmt(r.St)}</td><td>mm</td><td class="left" style="font-weight:700;color:${ok?'var(--status-pass)':'var(--status-fail)'}">${ok?'OK (< 25mm)':'NG (≥ 25mm)'}</td></tr>
  </tbody></table>
  <div style="margin-top:12px;padding:8px 12px;background:#f1f5f9;border-radius:5px;font-size:10px;color:#64748b;line-height:1.4">
  <strong>적용기준:</strong> KDS 11 50 40 (2018) | 도로교설계기준 (2008) | 지반공학회 (1996) | Meyerhof (1976)${!isPHC?' | Goodman (1980) | Canadian FEM':''}
  </div></div>`;

  el.innerHTML = html;
  if (window.MathJax && MathJax.typesetPromise) {
    MathJax.typesetPromise([el]).catch(function(err) { console.log('MathJax error:', err); });
  }
}

// ===== RENDER ALL TABS =====
function renderAllTabs() {
  updateHeader();
  renderSidebar();
  renderInputTab();
  renderVerticalTab();
  renderHorizontalTab();
  renderPulloutTab();
  renderSettlementTab();
  renderSummaryTab();
  renderOverallTab();
  renderReportTab();
}

// ===== Calc-tip fixed positioning =====
document.addEventListener('mouseenter', function(e) {
  if (!e.target || !e.target.closest) return;
  const tip = e.target.closest('.calc-tip');
  if (!tip) return;
  const content = tip.querySelector('.tip-content');
  if (!content) return;
  const rect = tip.getBoundingClientRect();
  // Try above first
  content.style.left = Math.max(8, Math.min(rect.left + rect.width / 2 - 125, window.innerWidth - 260)) + 'px';
  if (rect.top > 120) {
    content.style.top = '';
    content.style.bottom = (window.innerHeight - rect.top + 6) + 'px';
  } else {
    content.style.bottom = '';
    content.style.top = (rect.bottom + 6) + 'px';
  }
}, true);

// ===== INIT =====
recalculate();

// Tab switching (already bound above, just close script)
</script>

</body>
</html>
